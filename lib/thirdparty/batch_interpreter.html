<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>the refinery.lib.thirdparty.batch_interpreter documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.thirdparty.batch_interpreter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L1-L388" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Based on source code from: https://github.com/DissectMalware/batch_deobfuscator
# Original License: MIT License
# Copyright (c) 2018 Malwrologist
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# NOTE: The code was refactored and the following modifications were made:
#  - allow stripping used variable definitions
#  - allow stripping echo commands
#  - allow stripping comments
#  - allow processing of strings rather than files
from __future__ import annotations

import re
import os
import io

from dataclasses import dataclass, field
from enum import Enum, IntFlag, auto
from typing import Dict, Generator, List, NamedTuple, Optional
from collections import defaultdict


class _T(str, Enum):
    OPEN    = &#39;(&#39; # noqa
    CLOSE   = &#39;)&#39; # noqa
    ESCAPE  = &#39;^&#39; # noqa
    CONNECT = &#39;&amp;&#39; # noqa
    PIPE    = &#39;|&#39; # noqa
    QUOTE   = &#39;&#34;&#39; # noqa
    V1      = &#39;%&#39; # noqa
    V2      = &#39;!&#39; # noqa
    SPACE   = &#39; &#39; # noqa


class _S(int, Enum):
    INIT = auto()
    STRING = auto()
    ESCAPE = auto()
    VARIABLE_TYPE1 = auto()
    VARIABLE_TYPE2 = auto()


class STRIP(IntFlag):
    DEFINITION = 0b001 # noqa
    ECHO       = 0b010 # noqa
    COMMENT    = 0b100 # noqa
    ALL        = 0b111 # noqa
    NONE       = 0b000 # noqa


@dataclass
class ScriptVariable:
    definitions: Dict[int, str] = field(default_factory=dict)
    evaluations: List[int] = field(default_factory=list)

    @property
    def value(self):
        latest = max(self.definitions)
        return self.definitions[latest]


class DeobfuscatedLine(NamedTuple):
    depth: int
    value: str


class BatchDeobfuscator:
    variables: Dict[str, ScriptVariable]
    pending_subcommand: Optional[str]

    def __init__(self):
        if os.name == &#39;nt&#39;:
            variables = {name.lower(): value for name, value in os.environ.items()}
        else:
            variables = {
                &#39;allusersprofile&#39;                 : &#39;C:\\ProgramData&#39;,
                &#39;appdata&#39;                         : &#39;C:\\Users\\puncher\\AppData\\Roaming&#39;,
                &#39;commonprogramfiles&#39;              : &#39;C:\\Program Files\\Common Files&#39;,
                &#39;commonprogramfiles(x86)&#34;&#39;        : &#39;C:\\Program Files (x86)\\Common Files&#39;,
                &#39;commonprogramw6432&#39;              : &#39;C:\\Program Files\\Common Files&#39;,
                &#39;computername&#39;                    : &#39;MISCREANTTEARS&#39;,
                &#39;comspec&#39;                         : &#39;C:\\WINDOWS\\system32\\cmd.exe&#39;,
                &#39;driverdata&#39;                      : &#39;C:\\Windows\\System32\\Drivers\\DriverData&#39;,
                &#39;fps_browser_app_profile_string&#39;  : &#39;Internet Explorer&#39;,
                &#39;fps_browser_user_profile_string&#39; : &#39;Default&#39;,
                &#39;homedrive&#39;                       : &#39;C:&#39;,
                &#39;homepath&#39;                        : &#39;\\Users\\puncher&#39;,
                &#39;java_home&#39;                       : &#39;C:\\Program Files\\Amazon Corretto\\jdk11.0.7_10&#39;,
                &#39;localappdata&#39;                    : &#39;C:\\Users\\puncher\\AppData\\Local&#39;,
                &#39;logonserver&#39;                     : &#39;\\\\MISCREANTTEARS&#39;,
                &#39;number_of_processors&#39;            : &#39;4&#39;,
                &#39;onedrive&#39;                        : &#39;C:\\Users\\puncher\\OneDrive&#39;,
                &#39;os&#39;                              : &#39;Windows_NT&#39;,
                &#39;path&#39;                            : &#39;C:\\Program Files\\Amazon Corretto\\jdk11.0.7_10\\bin;C:\\WINDOWS\\system32;&#39;
                                                    &#39;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerS&#39;
                                                    &#39;hell\\v1.0\\;C:\\Program Files\\dotnet\\;C:\\Program Files\\Microsoft SQL Se&#39;
                                                    &#39;rver\\130\\Tools\\Binn\\;C:\\Users\\puncher\\AppData\\Local\\Microsoft\\Wind&#39;
                                                    &#39;owsApps;%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps;&#39;,
                &#39;pathext&#39;                         : &#39;.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC&#39;,
                &#39;processor_architecture&#39;          : &#39;AMD64&#39;,
                &#39;processor_identifier&#39;            : &#39;Intel Core Ti-83 Family 6 Model 158 Stepping 10, GenuineIntel&#39;,
                &#39;processor_level&#39;                 : &#39;6&#39;,
                &#39;processor_revision&#39;              : &#39;9e0a&#39;,
                &#39;programdata&#39;                     : &#39;C:\\ProgramData&#39;,
                &#39;programfiles&#39;                    : &#39;C:\\Program Files&#39;,
                &#39;programfiles(x86)&#34;&#39;              : &#39;C:\\Program Files (x86)&#39;,
                &#39;programw6432&#39;                    : &#39;C:\\Program Files&#39;,
                &#39;psmodulepath&#39;                    : &#39;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules\\&#39;,
                &#39;public&#39;                          : &#39;C:\\Users\\Public&#39;,
                &#39;sessionname&#39;                     : &#39;Console&#39;,
                &#39;systemdrive&#39;                     : &#39;C:&#39;,
                &#39;systemroot&#39;                      : &#39;C:\\WINDOWS&#39;,
                &#39;temp&#39;                            : &#39;C:\\Users\\puncher\\AppData\\Local\\Temp&#39;,
                &#39;tmp&#39;                             : &#39;C:\\Users\\puncher\\AppData\\Local\\Temp&#39;,
                &#39;userdomain&#39;                      : &#39;MISCREANTTEARS&#39;,
                &#39;userdomain_roamingprofile&#39;       : &#39;MISCREANTTEARS&#39;,
                &#39;username&#39;                        : &#39;puncher&#39;,
                &#39;userprofile&#39;                     : &#39;C:\\Users\\puncher&#39;,
                &#39;windir&#39;                          : &#39;C:\\WINDOWS&#39;,
                &#39;__compat_layer&#39;                  : &#39;DetectorsMessageBoxErrors&#39;,
            }
        self.pending_subcommand = None
        self.variables = defaultdict(ScriptVariable)
        for name, value in variables.items():
            self.variables[name].definitions[-1] = value

    def read_logical_lines(self, text: str):
        logical_line = io.StringIO()
        for line in text.splitlines(False):
            if not line.endswith(_T.ESCAPE):
                logical_line.write(line)
                yield logical_line.getvalue()
                logical_line.seek(0)
                logical_line.truncate(0)
            else:
                logical_line.write(line)
                logical_line.write(&#39;\n&#39;)

    def commands(self, logical_line: str) -&gt; Generator[str, None, None]:
        state = _S.INIT
        start = 0
        for offset, token in enumerate(logical_line):
            if state is _S.INIT:
                if token == _T.QUOTE:
                    state = _S.STRING
                elif token == _T.ESCAPE:
                    state = _S.ESCAPE
                elif token == _T.CONNECT or token == _T.PIPE:
                    yield logical_line[start:offset].strip()
                    start = offset + 1
            elif state is _S.STRING:
                if token == _T.QUOTE:
                    state = state.INIT
            elif state is _S.ESCAPE:
                state = _S.INIT
        last_command = logical_line[start:].strip()
        if last_command:
            yield last_command

    def evaluate_variable(self, lno, variable):
        pattern = (
            r&#39;&#39;&#39;(?P&lt;delim&gt;%|!)\s*(?P&lt;name&gt;[\w#$&#39;()*+,-.?@\[\]`{}~ ]+)&#39;&#39;&#39;
            r&#39;&#39;&#39;(:~\s*(?P&lt;index&gt;[+-]?\d+)\s*,\s*(?P&lt;length&gt;[+-]?\d+)\s*)?(?P=delim)&#39;&#39;&#39;)
        match = re.fullmatch(pattern, variable)
        if match is None:
            return variable
        var = self.variables.get(match.group(&#39;name&#39;).lower())
        if var is None:
            return variable
        value = var.value
        var.evaluations.append(lno)
        if match.group(&#39;index&#39;):
            index = int(match.group(&#39;index&#39;))
            length = int(match.group(&#39;length&#39;))
            if length &gt;= 0:
                value = value[index : length + index]
            else:
                value = value[index : length]
            return value
        return value

    def interpret(self, lno: int, command: str) -&gt; None:
        command = command.strip()
        index = 0
        last = len(command) - 1
        while index &lt; last and (command[index] == _T.SPACE or command[index] == _T.OPEN):
            if command[index] == _T.OPEN:
                while last &gt; index and (command[last] == _T.SPACE or command[last] == _T.CLOSE):
                    if command[last] == _T.CLOSE:
                        last -= 1
                        break
                    last -= 1
            index += 1
        command = command[index : last + 1]
        if command.lower().startswith(&#39;cmd&#39;):
            pattern = r&#34;\s*(call)?cmd(.exe)?\s*((\/A|\/U|\/Q|\/D)\s+|((\/E|\/F|\/V):(ON|OFF))\s*)*(\/c|\/r)\s*(?P&lt;cmd&gt;.*)&#34;
            match = re.search(pattern, command, re.IGNORECASE)
            if match and match.group(&#39;cmd&#39;):
                cmd = match.group(&#39;cmd&#39;).strip(_T.QUOTE)
                self.pending_subcommand = cmd
        else:
            pattern = (
                r&#34;(\s*(call)?\s*set\s+\&#34;?(?P&lt;var&gt;[\w#$&#39;()*+,-.?@\[\]`{}~ ]+)=\s*(?P&lt;val&gt;[^\&#34;\n]*)\&#34;?)|&#34;
                r&#34;(\s*(call)?\s*set\s+/p\s+\&#34;?(?P&lt;input&gt;[\w#$&#39;()*+,-.?@\[\]`{}~ ]+)=[^\&#34;\n]*\&#34;?)&#34;
            )
            match = re.search(pattern, command, re.IGNORECASE)
            if match is None:
                return
            var = match.group(&#39;input&#39;)
            if var is not None:
                var = var.lower()
                val = &#39;__input__&#39;
            else:
                var = match.group(&#39;var&#39;).lower()
                val = match.group(&#39;val&#39;)
            self.variables[var].definitions[lno] = val

    def normalize(self, lno: int, command: str):
        result = &#39;&#39;
        state = _S.INIT
        stack = []
        for token in command:
            if state == _S.INIT:
                if token == _T.QUOTE:
                    state = _S.STRING
                    result += token
                elif token in &#39;,;\t&#39;:
                    # commas (&#34;,&#34;) are replaced by spaces, unless they are part of a string in doublequotes
                    # semicolons (&#34;;&#34;) are replaced by spaces, unless they are part of a string in doublequotes
                    # tabs are replaced by a single space
                    # http://www.robvanderwoude.com/parameters.php
                    result += _T.SPACE
                elif token == _T.ESCAPE:
                    state = _S.ESCAPE
                    stack.append(_S.INIT)
                elif token == _T.V1:
                    variable_start = len(result)
                    result += _T.V1
                    stack.append(_S.INIT)
                    state = _S.VARIABLE_TYPE1
                elif token == _T.V2:
                    variable_start = len(result)
                    result += _T.V1
                    stack.append(_S.INIT)
                    state = _S.VARIABLE_TYPE2
                else:
                    result += token
            elif state == _S.STRING:
                if token == _T.QUOTE:
                    state = _S.INIT
                    result += token
                elif token == _T.V1:
                    variable_start = len(result)
                    result += _T.V1
                    stack.append(_S.STRING)
                    state = _S.VARIABLE_TYPE1
                elif token == _T.V2:
                    variable_start = len(result)
                    result += _T.V1
                    stack.append(_S.STRING)
                    state = _S.VARIABLE_TYPE2
                elif token == _T.ESCAPE:
                    state = _S.ESCAPE
                    stack.append(_S.STRING)
                else:
                    result += token
            elif state == _S.VARIABLE_TYPE1:
                if token.isdigit() and result[-1] == _T.V1:
                    result += token
                    state = stack.pop()
                elif token == _T.V1 and result[-1] != _T.V1:
                    result += _T.V1
                    value = self.evaluate_variable(lno, result[variable_start:].lower())
                    result = result[:variable_start]
                    result += value
                    state = stack.pop()
                elif token == _T.V1:
                    variable_start = len(result)
                    result += token
                elif token == _T.QUOTE:
                    if stack[-1] == _S.STRING:
                        result += token
                        stack.pop()
                        state = _S.INIT
                    else:
                        result += token
                elif token == _T.ESCAPE:
                    state = _S.ESCAPE
                    stack.append(_S.VARIABLE_TYPE1)
                else:
                    result += token
            elif state == _S.VARIABLE_TYPE2:
                if token == _T.V2 and result[-1] != _T.V1:
                    result += _T.V1
                    value = self.evaluate_variable(lno, result[variable_start:].lower())
                    result = result[:variable_start]
                    result += value
                    state = stack.pop()
                elif token == _T.V2:
                    variable_start = len(result)
                    result += token
                elif token == _T.QUOTE:
                    if stack[-1] == _S.STRING:
                        result += token
                        stack.pop()
                        state = _S.INIT
                    else:
                        result += token
                elif token == _T.ESCAPE:
                    state = _S.ESCAPE
                    stack.append(_S.VARIABLE_TYPE1)
                else:
                    result += token
            elif state == _S.ESCAPE:
                result += token
                state = stack.pop()
        return result.strip()

    def _interpret(self, text: str, lno: int = 0, depth: int = 0) -&gt; Generator[DeobfuscatedLine, None, None]:
        for line in self.read_logical_lines(text):
            for command in self.commands(line):
                normalized = self.normalize(lno, command)
                self.interpret(lno, normalized)
                yield DeobfuscatedLine(depth, normalized)
                lno += 1
                if self.pending_subcommand is not None:
                    subcommand = BatchDeobfuscator()
                    for name, var in self.variables.items():
                        subcommand.variables[name].definitions[-1] = var.value
                    for result in subcommand._interpret(self.pending_subcommand, lno, depth + 1):
                        yield result
                        lno += 1
                    self.pending_subcommand = None

    def deobfuscate(
        self,
        text: str,
        mode: STRIP = STRIP.NONE
    ) -&gt; str:
        lines = list(self._interpret(text))
        used = set()

        if mode &amp; STRIP.DEFINITION:
            for variable in self.variables.values():
                if variable.evaluations:
                    used.update(variable.definitions.keys())

        def tab(depth):
            return &#39; &#39; * 3 * depth

        def output():
            depth = 0
            for lno, line in enumerate(lines):
                if lno in used:
                    continue
                if not line.value:
                    continue
                cmd = line.value.split()[0].lower()
                cmd, _, _ = cmd.partition(&#39;/&#39;)
                if mode &amp; STRIP.ECHO and cmd == &#39;echo&#39;:
                    continue
                if mode &amp; STRIP.COMMENT and (line.value.startswith(&#39;::&#39;) or cmd == &#39;rem&#39;):
                    continue
                if line.depth &gt; depth:
                    yield F&#39;{tab(depth)}:: SUBCOMMAND&#39;
                depth = line.depth
                yield F&#39;{tab(depth)}{line.value}&#39;

        return &#39;\n&#39;.join(output())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.thirdparty.batch_interpreter.STRIP"><code class="flex name class">
<span>class <span class="ident">STRIP</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L62-L67" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class STRIP(IntFlag):
    DEFINITION = 0b001 # noqa
    ECHO       = 0b010 # noqa
    COMMENT    = 0b100 # noqa
    ALL        = 0b111 # noqa
    NONE       = 0b000 # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.thirdparty.batch_interpreter.STRIP.DEFINITION"><code class="name">var <span class="ident">DEFINITION</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.STRIP.ECHO"><code class="name">var <span class="ident">ECHO</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.STRIP.COMMENT"><code class="name">var <span class="ident">COMMENT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.STRIP.ALL"><code class="name">var <span class="ident">ALL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.STRIP.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.ScriptVariable"><code class="flex name class">
<span>class <span class="ident">ScriptVariable</span></span>
<span>(</span><span>definitions=&lt;factory&gt;, evaluations=&lt;factory&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>ScriptVariable(definitions: 'Dict[int, str]' = <factory>, evaluations: 'List[int]' = <factory>)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L71-L78" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ScriptVariable:
    definitions: Dict[int, str] = field(default_factory=dict)
    evaluations: List[int] = field(default_factory=list)

    @property
    def value(self):
        latest = max(self.definitions)
        return self.definitions[latest]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.thirdparty.batch_interpreter.ScriptVariable.definitions"><code class="name">var <span class="ident">definitions</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.ScriptVariable.evaluations"><code class="name">var <span class="ident">evaluations</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.thirdparty.batch_interpreter.ScriptVariable.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L75-L78" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def value(self):
    latest = max(self.definitions)
    return self.definitions[latest]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.DeobfuscatedLine"><code class="flex name class">
<span>class <span class="ident">DeobfuscatedLine</span></span>
<span>(</span><span>depth, value)</span>
</code></dt>
<dd>
<section class="desc"><p>DeobfuscatedLine(depth, value)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L81-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DeobfuscatedLine(NamedTuple):
    depth: int
    value: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.thirdparty.batch_interpreter.DeobfuscatedLine.depth"><code class="name">var <span class="ident">depth</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.DeobfuscatedLine.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator"><code class="flex name class">
<span>class <span class="ident">BatchDeobfuscator</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L86-L388" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BatchDeobfuscator:
    variables: Dict[str, ScriptVariable]
    pending_subcommand: Optional[str]

    def __init__(self):
        if os.name == &#39;nt&#39;:
            variables = {name.lower(): value for name, value in os.environ.items()}
        else:
            variables = {
                &#39;allusersprofile&#39;                 : &#39;C:\\ProgramData&#39;,
                &#39;appdata&#39;                         : &#39;C:\\Users\\puncher\\AppData\\Roaming&#39;,
                &#39;commonprogramfiles&#39;              : &#39;C:\\Program Files\\Common Files&#39;,
                &#39;commonprogramfiles(x86)&#34;&#39;        : &#39;C:\\Program Files (x86)\\Common Files&#39;,
                &#39;commonprogramw6432&#39;              : &#39;C:\\Program Files\\Common Files&#39;,
                &#39;computername&#39;                    : &#39;MISCREANTTEARS&#39;,
                &#39;comspec&#39;                         : &#39;C:\\WINDOWS\\system32\\cmd.exe&#39;,
                &#39;driverdata&#39;                      : &#39;C:\\Windows\\System32\\Drivers\\DriverData&#39;,
                &#39;fps_browser_app_profile_string&#39;  : &#39;Internet Explorer&#39;,
                &#39;fps_browser_user_profile_string&#39; : &#39;Default&#39;,
                &#39;homedrive&#39;                       : &#39;C:&#39;,
                &#39;homepath&#39;                        : &#39;\\Users\\puncher&#39;,
                &#39;java_home&#39;                       : &#39;C:\\Program Files\\Amazon Corretto\\jdk11.0.7_10&#39;,
                &#39;localappdata&#39;                    : &#39;C:\\Users\\puncher\\AppData\\Local&#39;,
                &#39;logonserver&#39;                     : &#39;\\\\MISCREANTTEARS&#39;,
                &#39;number_of_processors&#39;            : &#39;4&#39;,
                &#39;onedrive&#39;                        : &#39;C:\\Users\\puncher\\OneDrive&#39;,
                &#39;os&#39;                              : &#39;Windows_NT&#39;,
                &#39;path&#39;                            : &#39;C:\\Program Files\\Amazon Corretto\\jdk11.0.7_10\\bin;C:\\WINDOWS\\system32;&#39;
                                                    &#39;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerS&#39;
                                                    &#39;hell\\v1.0\\;C:\\Program Files\\dotnet\\;C:\\Program Files\\Microsoft SQL Se&#39;
                                                    &#39;rver\\130\\Tools\\Binn\\;C:\\Users\\puncher\\AppData\\Local\\Microsoft\\Wind&#39;
                                                    &#39;owsApps;%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps;&#39;,
                &#39;pathext&#39;                         : &#39;.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC&#39;,
                &#39;processor_architecture&#39;          : &#39;AMD64&#39;,
                &#39;processor_identifier&#39;            : &#39;Intel Core Ti-83 Family 6 Model 158 Stepping 10, GenuineIntel&#39;,
                &#39;processor_level&#39;                 : &#39;6&#39;,
                &#39;processor_revision&#39;              : &#39;9e0a&#39;,
                &#39;programdata&#39;                     : &#39;C:\\ProgramData&#39;,
                &#39;programfiles&#39;                    : &#39;C:\\Program Files&#39;,
                &#39;programfiles(x86)&#34;&#39;              : &#39;C:\\Program Files (x86)&#39;,
                &#39;programw6432&#39;                    : &#39;C:\\Program Files&#39;,
                &#39;psmodulepath&#39;                    : &#39;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules\\&#39;,
                &#39;public&#39;                          : &#39;C:\\Users\\Public&#39;,
                &#39;sessionname&#39;                     : &#39;Console&#39;,
                &#39;systemdrive&#39;                     : &#39;C:&#39;,
                &#39;systemroot&#39;                      : &#39;C:\\WINDOWS&#39;,
                &#39;temp&#39;                            : &#39;C:\\Users\\puncher\\AppData\\Local\\Temp&#39;,
                &#39;tmp&#39;                             : &#39;C:\\Users\\puncher\\AppData\\Local\\Temp&#39;,
                &#39;userdomain&#39;                      : &#39;MISCREANTTEARS&#39;,
                &#39;userdomain_roamingprofile&#39;       : &#39;MISCREANTTEARS&#39;,
                &#39;username&#39;                        : &#39;puncher&#39;,
                &#39;userprofile&#39;                     : &#39;C:\\Users\\puncher&#39;,
                &#39;windir&#39;                          : &#39;C:\\WINDOWS&#39;,
                &#39;__compat_layer&#39;                  : &#39;DetectorsMessageBoxErrors&#39;,
            }
        self.pending_subcommand = None
        self.variables = defaultdict(ScriptVariable)
        for name, value in variables.items():
            self.variables[name].definitions[-1] = value

    def read_logical_lines(self, text: str):
        logical_line = io.StringIO()
        for line in text.splitlines(False):
            if not line.endswith(_T.ESCAPE):
                logical_line.write(line)
                yield logical_line.getvalue()
                logical_line.seek(0)
                logical_line.truncate(0)
            else:
                logical_line.write(line)
                logical_line.write(&#39;\n&#39;)

    def commands(self, logical_line: str) -&gt; Generator[str, None, None]:
        state = _S.INIT
        start = 0
        for offset, token in enumerate(logical_line):
            if state is _S.INIT:
                if token == _T.QUOTE:
                    state = _S.STRING
                elif token == _T.ESCAPE:
                    state = _S.ESCAPE
                elif token == _T.CONNECT or token == _T.PIPE:
                    yield logical_line[start:offset].strip()
                    start = offset + 1
            elif state is _S.STRING:
                if token == _T.QUOTE:
                    state = state.INIT
            elif state is _S.ESCAPE:
                state = _S.INIT
        last_command = logical_line[start:].strip()
        if last_command:
            yield last_command

    def evaluate_variable(self, lno, variable):
        pattern = (
            r&#39;&#39;&#39;(?P&lt;delim&gt;%|!)\s*(?P&lt;name&gt;[\w#$&#39;()*+,-.?@\[\]`{}~ ]+)&#39;&#39;&#39;
            r&#39;&#39;&#39;(:~\s*(?P&lt;index&gt;[+-]?\d+)\s*,\s*(?P&lt;length&gt;[+-]?\d+)\s*)?(?P=delim)&#39;&#39;&#39;)
        match = re.fullmatch(pattern, variable)
        if match is None:
            return variable
        var = self.variables.get(match.group(&#39;name&#39;).lower())
        if var is None:
            return variable
        value = var.value
        var.evaluations.append(lno)
        if match.group(&#39;index&#39;):
            index = int(match.group(&#39;index&#39;))
            length = int(match.group(&#39;length&#39;))
            if length &gt;= 0:
                value = value[index : length + index]
            else:
                value = value[index : length]
            return value
        return value

    def interpret(self, lno: int, command: str) -&gt; None:
        command = command.strip()
        index = 0
        last = len(command) - 1
        while index &lt; last and (command[index] == _T.SPACE or command[index] == _T.OPEN):
            if command[index] == _T.OPEN:
                while last &gt; index and (command[last] == _T.SPACE or command[last] == _T.CLOSE):
                    if command[last] == _T.CLOSE:
                        last -= 1
                        break
                    last -= 1
            index += 1
        command = command[index : last + 1]
        if command.lower().startswith(&#39;cmd&#39;):
            pattern = r&#34;\s*(call)?cmd(.exe)?\s*((\/A|\/U|\/Q|\/D)\s+|((\/E|\/F|\/V):(ON|OFF))\s*)*(\/c|\/r)\s*(?P&lt;cmd&gt;.*)&#34;
            match = re.search(pattern, command, re.IGNORECASE)
            if match and match.group(&#39;cmd&#39;):
                cmd = match.group(&#39;cmd&#39;).strip(_T.QUOTE)
                self.pending_subcommand = cmd
        else:
            pattern = (
                r&#34;(\s*(call)?\s*set\s+\&#34;?(?P&lt;var&gt;[\w#$&#39;()*+,-.?@\[\]`{}~ ]+)=\s*(?P&lt;val&gt;[^\&#34;\n]*)\&#34;?)|&#34;
                r&#34;(\s*(call)?\s*set\s+/p\s+\&#34;?(?P&lt;input&gt;[\w#$&#39;()*+,-.?@\[\]`{}~ ]+)=[^\&#34;\n]*\&#34;?)&#34;
            )
            match = re.search(pattern, command, re.IGNORECASE)
            if match is None:
                return
            var = match.group(&#39;input&#39;)
            if var is not None:
                var = var.lower()
                val = &#39;__input__&#39;
            else:
                var = match.group(&#39;var&#39;).lower()
                val = match.group(&#39;val&#39;)
            self.variables[var].definitions[lno] = val

    def normalize(self, lno: int, command: str):
        result = &#39;&#39;
        state = _S.INIT
        stack = []
        for token in command:
            if state == _S.INIT:
                if token == _T.QUOTE:
                    state = _S.STRING
                    result += token
                elif token in &#39;,;\t&#39;:
                    # commas (&#34;,&#34;) are replaced by spaces, unless they are part of a string in doublequotes
                    # semicolons (&#34;;&#34;) are replaced by spaces, unless they are part of a string in doublequotes
                    # tabs are replaced by a single space
                    # http://www.robvanderwoude.com/parameters.php
                    result += _T.SPACE
                elif token == _T.ESCAPE:
                    state = _S.ESCAPE
                    stack.append(_S.INIT)
                elif token == _T.V1:
                    variable_start = len(result)
                    result += _T.V1
                    stack.append(_S.INIT)
                    state = _S.VARIABLE_TYPE1
                elif token == _T.V2:
                    variable_start = len(result)
                    result += _T.V1
                    stack.append(_S.INIT)
                    state = _S.VARIABLE_TYPE2
                else:
                    result += token
            elif state == _S.STRING:
                if token == _T.QUOTE:
                    state = _S.INIT
                    result += token
                elif token == _T.V1:
                    variable_start = len(result)
                    result += _T.V1
                    stack.append(_S.STRING)
                    state = _S.VARIABLE_TYPE1
                elif token == _T.V2:
                    variable_start = len(result)
                    result += _T.V1
                    stack.append(_S.STRING)
                    state = _S.VARIABLE_TYPE2
                elif token == _T.ESCAPE:
                    state = _S.ESCAPE
                    stack.append(_S.STRING)
                else:
                    result += token
            elif state == _S.VARIABLE_TYPE1:
                if token.isdigit() and result[-1] == _T.V1:
                    result += token
                    state = stack.pop()
                elif token == _T.V1 and result[-1] != _T.V1:
                    result += _T.V1
                    value = self.evaluate_variable(lno, result[variable_start:].lower())
                    result = result[:variable_start]
                    result += value
                    state = stack.pop()
                elif token == _T.V1:
                    variable_start = len(result)
                    result += token
                elif token == _T.QUOTE:
                    if stack[-1] == _S.STRING:
                        result += token
                        stack.pop()
                        state = _S.INIT
                    else:
                        result += token
                elif token == _T.ESCAPE:
                    state = _S.ESCAPE
                    stack.append(_S.VARIABLE_TYPE1)
                else:
                    result += token
            elif state == _S.VARIABLE_TYPE2:
                if token == _T.V2 and result[-1] != _T.V1:
                    result += _T.V1
                    value = self.evaluate_variable(lno, result[variable_start:].lower())
                    result = result[:variable_start]
                    result += value
                    state = stack.pop()
                elif token == _T.V2:
                    variable_start = len(result)
                    result += token
                elif token == _T.QUOTE:
                    if stack[-1] == _S.STRING:
                        result += token
                        stack.pop()
                        state = _S.INIT
                    else:
                        result += token
                elif token == _T.ESCAPE:
                    state = _S.ESCAPE
                    stack.append(_S.VARIABLE_TYPE1)
                else:
                    result += token
            elif state == _S.ESCAPE:
                result += token
                state = stack.pop()
        return result.strip()

    def _interpret(self, text: str, lno: int = 0, depth: int = 0) -&gt; Generator[DeobfuscatedLine, None, None]:
        for line in self.read_logical_lines(text):
            for command in self.commands(line):
                normalized = self.normalize(lno, command)
                self.interpret(lno, normalized)
                yield DeobfuscatedLine(depth, normalized)
                lno += 1
                if self.pending_subcommand is not None:
                    subcommand = BatchDeobfuscator()
                    for name, var in self.variables.items():
                        subcommand.variables[name].definitions[-1] = var.value
                    for result in subcommand._interpret(self.pending_subcommand, lno, depth + 1):
                        yield result
                        lno += 1
                    self.pending_subcommand = None

    def deobfuscate(
        self,
        text: str,
        mode: STRIP = STRIP.NONE
    ) -&gt; str:
        lines = list(self._interpret(text))
        used = set()

        if mode &amp; STRIP.DEFINITION:
            for variable in self.variables.values():
                if variable.evaluations:
                    used.update(variable.definitions.keys())

        def tab(depth):
            return &#39; &#39; * 3 * depth

        def output():
            depth = 0
            for lno, line in enumerate(lines):
                if lno in used:
                    continue
                if not line.value:
                    continue
                cmd = line.value.split()[0].lower()
                cmd, _, _ = cmd.partition(&#39;/&#39;)
                if mode &amp; STRIP.ECHO and cmd == &#39;echo&#39;:
                    continue
                if mode &amp; STRIP.COMMENT and (line.value.startswith(&#39;::&#39;) or cmd == &#39;rem&#39;):
                    continue
                if line.depth &gt; depth:
                    yield F&#39;{tab(depth)}:: SUBCOMMAND&#39;
                depth = line.depth
                yield F&#39;{tab(depth)}{line.value}&#39;

        return &#39;\n&#39;.join(output())</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.variables"><code class="name">var <span class="ident">variables</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.pending_subcommand"><code class="name">var <span class="ident">pending_subcommand</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.read_logical_lines"><code class="name flex">
<span>def <span class="ident">read_logical_lines</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L146-L156" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_logical_lines(self, text: str):
    logical_line = io.StringIO()
    for line in text.splitlines(False):
        if not line.endswith(_T.ESCAPE):
            logical_line.write(line)
            yield logical_line.getvalue()
            logical_line.seek(0)
            logical_line.truncate(0)
        else:
            logical_line.write(line)
            logical_line.write(&#39;\n&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.commands"><code class="name flex">
<span>def <span class="ident">commands</span></span>(<span>self, logical_line)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L158-L177" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def commands(self, logical_line: str) -&gt; Generator[str, None, None]:
    state = _S.INIT
    start = 0
    for offset, token in enumerate(logical_line):
        if state is _S.INIT:
            if token == _T.QUOTE:
                state = _S.STRING
            elif token == _T.ESCAPE:
                state = _S.ESCAPE
            elif token == _T.CONNECT or token == _T.PIPE:
                yield logical_line[start:offset].strip()
                start = offset + 1
        elif state is _S.STRING:
            if token == _T.QUOTE:
                state = state.INIT
        elif state is _S.ESCAPE:
            state = _S.INIT
    last_command = logical_line[start:].strip()
    if last_command:
        yield last_command</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.evaluate_variable"><code class="name flex">
<span>def <span class="ident">evaluate_variable</span></span>(<span>self, lno, variable)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L179-L199" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def evaluate_variable(self, lno, variable):
    pattern = (
        r&#39;&#39;&#39;(?P&lt;delim&gt;%|!)\s*(?P&lt;name&gt;[\w#$&#39;()*+,-.?@\[\]`{}~ ]+)&#39;&#39;&#39;
        r&#39;&#39;&#39;(:~\s*(?P&lt;index&gt;[+-]?\d+)\s*,\s*(?P&lt;length&gt;[+-]?\d+)\s*)?(?P=delim)&#39;&#39;&#39;)
    match = re.fullmatch(pattern, variable)
    if match is None:
        return variable
    var = self.variables.get(match.group(&#39;name&#39;).lower())
    if var is None:
        return variable
    value = var.value
    var.evaluations.append(lno)
    if match.group(&#39;index&#39;):
        index = int(match.group(&#39;index&#39;))
        length = int(match.group(&#39;length&#39;))
        if length &gt;= 0:
            value = value[index : length + index]
        else:
            value = value[index : length]
        return value
    return value</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, lno, command)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L201-L235" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def interpret(self, lno: int, command: str) -&gt; None:
    command = command.strip()
    index = 0
    last = len(command) - 1
    while index &lt; last and (command[index] == _T.SPACE or command[index] == _T.OPEN):
        if command[index] == _T.OPEN:
            while last &gt; index and (command[last] == _T.SPACE or command[last] == _T.CLOSE):
                if command[last] == _T.CLOSE:
                    last -= 1
                    break
                last -= 1
        index += 1
    command = command[index : last + 1]
    if command.lower().startswith(&#39;cmd&#39;):
        pattern = r&#34;\s*(call)?cmd(.exe)?\s*((\/A|\/U|\/Q|\/D)\s+|((\/E|\/F|\/V):(ON|OFF))\s*)*(\/c|\/r)\s*(?P&lt;cmd&gt;.*)&#34;
        match = re.search(pattern, command, re.IGNORECASE)
        if match and match.group(&#39;cmd&#39;):
            cmd = match.group(&#39;cmd&#39;).strip(_T.QUOTE)
            self.pending_subcommand = cmd
    else:
        pattern = (
            r&#34;(\s*(call)?\s*set\s+\&#34;?(?P&lt;var&gt;[\w#$&#39;()*+,-.?@\[\]`{}~ ]+)=\s*(?P&lt;val&gt;[^\&#34;\n]*)\&#34;?)|&#34;
            r&#34;(\s*(call)?\s*set\s+/p\s+\&#34;?(?P&lt;input&gt;[\w#$&#39;()*+,-.?@\[\]`{}~ ]+)=[^\&#34;\n]*\&#34;?)&#34;
        )
        match = re.search(pattern, command, re.IGNORECASE)
        if match is None:
            return
        var = match.group(&#39;input&#39;)
        if var is not None:
            var = var.lower()
            val = &#39;__input__&#39;
        else:
            var = match.group(&#39;var&#39;).lower()
            val = match.group(&#39;val&#39;)
        self.variables[var].definitions[lno] = val</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self, lno, command)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L237-L336" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize(self, lno: int, command: str):
    result = &#39;&#39;
    state = _S.INIT
    stack = []
    for token in command:
        if state == _S.INIT:
            if token == _T.QUOTE:
                state = _S.STRING
                result += token
            elif token in &#39;,;\t&#39;:
                # commas (&#34;,&#34;) are replaced by spaces, unless they are part of a string in doublequotes
                # semicolons (&#34;;&#34;) are replaced by spaces, unless they are part of a string in doublequotes
                # tabs are replaced by a single space
                # http://www.robvanderwoude.com/parameters.php
                result += _T.SPACE
            elif token == _T.ESCAPE:
                state = _S.ESCAPE
                stack.append(_S.INIT)
            elif token == _T.V1:
                variable_start = len(result)
                result += _T.V1
                stack.append(_S.INIT)
                state = _S.VARIABLE_TYPE1
            elif token == _T.V2:
                variable_start = len(result)
                result += _T.V1
                stack.append(_S.INIT)
                state = _S.VARIABLE_TYPE2
            else:
                result += token
        elif state == _S.STRING:
            if token == _T.QUOTE:
                state = _S.INIT
                result += token
            elif token == _T.V1:
                variable_start = len(result)
                result += _T.V1
                stack.append(_S.STRING)
                state = _S.VARIABLE_TYPE1
            elif token == _T.V2:
                variable_start = len(result)
                result += _T.V1
                stack.append(_S.STRING)
                state = _S.VARIABLE_TYPE2
            elif token == _T.ESCAPE:
                state = _S.ESCAPE
                stack.append(_S.STRING)
            else:
                result += token
        elif state == _S.VARIABLE_TYPE1:
            if token.isdigit() and result[-1] == _T.V1:
                result += token
                state = stack.pop()
            elif token == _T.V1 and result[-1] != _T.V1:
                result += _T.V1
                value = self.evaluate_variable(lno, result[variable_start:].lower())
                result = result[:variable_start]
                result += value
                state = stack.pop()
            elif token == _T.V1:
                variable_start = len(result)
                result += token
            elif token == _T.QUOTE:
                if stack[-1] == _S.STRING:
                    result += token
                    stack.pop()
                    state = _S.INIT
                else:
                    result += token
            elif token == _T.ESCAPE:
                state = _S.ESCAPE
                stack.append(_S.VARIABLE_TYPE1)
            else:
                result += token
        elif state == _S.VARIABLE_TYPE2:
            if token == _T.V2 and result[-1] != _T.V1:
                result += _T.V1
                value = self.evaluate_variable(lno, result[variable_start:].lower())
                result = result[:variable_start]
                result += value
                state = stack.pop()
            elif token == _T.V2:
                variable_start = len(result)
                result += token
            elif token == _T.QUOTE:
                if stack[-1] == _S.STRING:
                    result += token
                    stack.pop()
                    state = _S.INIT
                else:
                    result += token
            elif token == _T.ESCAPE:
                state = _S.ESCAPE
                stack.append(_S.VARIABLE_TYPE1)
            else:
                result += token
        elif state == _S.ESCAPE:
            result += token
            state = stack.pop()
    return result.strip()</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.deobfuscate"><code class="name flex">
<span>def <span class="ident">deobfuscate</span></span>(<span>self, text, mode=STRIP.NONE)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/thirdparty/batch_interpreter.py#L354-L388" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def deobfuscate(
    self,
    text: str,
    mode: STRIP = STRIP.NONE
) -&gt; str:
    lines = list(self._interpret(text))
    used = set()

    if mode &amp; STRIP.DEFINITION:
        for variable in self.variables.values():
            if variable.evaluations:
                used.update(variable.definitions.keys())

    def tab(depth):
        return &#39; &#39; * 3 * depth

    def output():
        depth = 0
        for lno, line in enumerate(lines):
            if lno in used:
                continue
            if not line.value:
                continue
            cmd = line.value.split()[0].lower()
            cmd, _, _ = cmd.partition(&#39;/&#39;)
            if mode &amp; STRIP.ECHO and cmd == &#39;echo&#39;:
                continue
            if mode &amp; STRIP.COMMENT and (line.value.startswith(&#39;::&#39;) or cmd == &#39;rem&#39;):
                continue
            if line.depth &gt; depth:
                yield F&#39;{tab(depth)}:: SUBCOMMAND&#39;
            depth = line.depth
            yield F&#39;{tab(depth)}{line.value}&#39;

    return &#39;\n&#39;.join(output())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib.thirdparty" href="index.html">refinery.lib.thirdparty</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.thirdparty.batch_interpreter.STRIP" href="#refinery.lib.thirdparty.batch_interpreter.STRIP">STRIP</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.thirdparty.batch_interpreter.ScriptVariable" href="#refinery.lib.thirdparty.batch_interpreter.ScriptVariable">ScriptVariable</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.thirdparty.batch_interpreter.DeobfuscatedLine" href="#refinery.lib.thirdparty.batch_interpreter.DeobfuscatedLine">DeobfuscatedLine</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator" href="#refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator">BatchDeobfuscator</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.read_logical_lines" href="#refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.read_logical_lines">read_logical_lines</a></code></li>
<li><code><a title="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.commands" href="#refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.commands">commands</a></code></li>
<li><code><a title="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.evaluate_variable" href="#refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.evaluate_variable">evaluate_variable</a></code></li>
<li><code><a title="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.interpret" href="#refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.interpret">interpret</a></code></li>
<li><code><a title="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.normalize" href="#refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.normalize">normalize</a></code></li>
<li><code><a title="refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.deobfuscate" href="#refinery.lib.thirdparty.batch_interpreter.BatchDeobfuscator.deobfuscate">deobfuscate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>