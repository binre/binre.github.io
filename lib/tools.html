<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>the refinery.lib.tools documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.tools</code></h1>
</header>
<section id="section-intro">
<p>Miscellaneous helper functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L1-L500" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Miscellaneous helper functions.
&#34;&#34;&#34;
import datetime
import functools
import inspect
import itertools
import logging
import os
import sys
import io
import warnings
import re

from typing import ByteString, Callable, Generator, Iterable, Optional, Tuple, TypeVar
from math import log
from enum import IntFlag


_T = TypeVar(&#39;_T&#39;)


def lookahead(iterator: Iterable[_T]) -&gt; Generator[Tuple[bool, _T], None, None]:
    &#34;&#34;&#34;
    Implements a new iterator from a given one which returns elements `(last, item)` where each
    `item` is taken from the original iterator and `last` is a boolean indicating whether this is
    the last item.
    &#34;&#34;&#34;
    last = False
    it = iter(iterator)
    try:
        peek = next(it)
    except StopIteration:
        return
    while not last:
        item = peek
        try:
            peek = next(it)
        except StopIteration:
            last = True
        yield last, item


def get_terminal_size(default=0):
    &#34;&#34;&#34;
    Returns the size of the currently attached terminal. If the environment variable
    `REFINERY_TERM_SIZE` is set to an integer value, it takes prescedence. If the width of the
    terminal cannot be determined or if the width is less than 8 characters, the function
    returns zero.
    &#34;&#34;&#34;
    from refinery.lib.environment import environment
    ev_terminal_size = environment.term_size.value
    if ev_terminal_size &gt; 0:
        return ev_terminal_size
    width = default
    for stream in (sys.stderr, sys.stdout):
        if stream.isatty():
            try:
                width = os.get_terminal_size(stream.fileno()).columns
            except Exception:
                width = default
            else:
                break
    return default if width &lt; 2 else width - 1


def terminalfit(text: str, delta: int = 0, width: int = 0, parsep: str = &#39;\n\n&#39;, **kw) -&gt; str:
    &#34;&#34;&#34;
    Reformats text to fit the given width while not mangling bullet point lists.
    &#34;&#34;&#34;
    import textwrap
    import re

    width = width or get_terminal_size()
    width = width - delta

    def isol(t): return re.match(R&#39;^\(\d+\)|\d+[.:;]&#39;, t)
    def isul(t): return t.startswith(&#39;-&#39;) or t.startswith(&#39;*&#39;)
    def issp(t): return t.startswith(&#39;  &#39;)

    text = text.replace(&#39;\r&#39;, &#39;&#39;)

    def bulletpoint(line):
        wrapped = textwrap.wrap(line, width - 2, **kw)
        indent = &#39;  &#39; if isul(line) else &#39;   &#39;
        wrapped[1:] = [&#39;{}{}&#39;.format(indent, line) for line in wrapped[1:]]
        return &#39;\n&#39;.join(wrapped)

    def fitted(paragraphs):
        for k, p in enumerate(paragraphs):
            if p.startswith(&#39; &#39;):
                yield p
                continue
            ol, ul = isol(p), isul(p)
            if ol or ul:
                input_lines = p.splitlines(keepends=False)
                unwrapped_line = input_lines[0].rstrip()
                lines = []
                if (ol and all(isol(t) or issp(t) for t in input_lines) or ul and all(isul(t) or issp(t) for t in input_lines)):
                    for line in input_lines[1:]:
                        if not (ol and isol(line) or ul and isul(line)):
                            unwrapped_line += &#39; &#39; + line.strip()
                            continue
                        lines.append(bulletpoint(unwrapped_line))
                        unwrapped_line = line.rstrip()
                    lines.append(bulletpoint(unwrapped_line))
                    yield &#39;\n&#39;.join(lines)
                    continue
            yield &#39;\n&#39;.join(textwrap.wrap(p, width, **kw))

    return parsep.join(fitted(text.split(&#39;\n\n&#39;)))


def documentation(unit):
    &#34;&#34;&#34;
    Return the documentation string of a given unit as it should be displayed on the command line.
    Certain pdoc3-specific reference strings are removed.
    &#34;&#34;&#34;
    import re
    docs = inspect.getdoc(unit)
    docs = re.sub(R&#39;`refinery\.(?:\w+\.)*(\w+)`&#39;, R&#39;\1&#39;, docs)
    return docs.replace(&#39;`&#39;, &#39;&#39;)


def begin(iterable: Iterable[_T]) -&gt; Optional[Tuple[_T, Iterable[_T]]]:
    &#34;&#34;&#34;
    Iterates the first element of an iterator and returns None if this fails. Otherwise, it returns
    both the first element and a new iterable which will return the same elements as the input.
    &#34;&#34;&#34;
    try:
        body = iter(iterable)
        head = next(body)
    except StopIteration:
        return None
    else:
        def _fused():
            yield head
            yield from body
        return head, _fused()


def skipfirst(iterable: Iterable[_T]) -&gt; Generator[_T, None, None]:
    &#34;&#34;&#34;
    Returns an interable where the first element of the input iterable was skipped.
    &#34;&#34;&#34;
    it = iter(iterable)
    next(it)
    yield from it


def autoinvoke(method: Callable[..., _T], keywords: dict) -&gt; _T:
    &#34;&#34;&#34;
    For each parameter that `method` expects, this function looks for an entry in `keywords` which
    has the same name as that parameter. `autoinvoke` then calls `method` with all matching
    parameters forwarded in the appropriate manner.
    &#34;&#34;&#34;

    kwdargs = {}
    posargs = []
    varargs = []
    kwdjoin = False

    for p in inspect.signature(method).parameters.values():
        if p.kind is p.VAR_KEYWORD:
            kwdjoin = True
        try:
            value = keywords.pop(p.name)
        except KeyError:
            if p.kind is p.VAR_KEYWORD:
                continue
            value = p.default
            if value is p.empty:
                raise ValueError(F&#39;missing required parameter {p.name}&#39;)
        if p.kind is p.POSITIONAL_OR_KEYWORD or p.kind is p.POSITIONAL_ONLY:
            if value == p.default:
                # when equality holds, we force identity
                value = p.default
            posargs.append(value)
        elif p.kind is p.VAR_POSITIONAL:
            varargs = value
        elif p.kind is p.KEYWORD_ONLY:
            kwdargs[p.name] = value

    if kwdjoin:
        kwdargs.update(keywords)

    return method(*posargs, *varargs, **kwdargs)


def entropy_fallback(data: ByteString) -&gt; float:
    &#34;&#34;&#34;
    This method is called by `refinery.lib.tools.entropy` when the `numpy` module is not available.
    It computes the shannon entropy of the input byte string and is written in pure Python.
    &#34;&#34;&#34;
    if isinstance(data, memoryview):
        # this copy is better than re-implementing count in Python for memory views
        data = bytes(data)
    histogram = {b: data.count(b) for b in range(0x100)}
    S = [histogram[b] / len(data) for b in histogram]
    return 0.0 + -sum(p * log(p, 2) for p in S if p) / 8.0


def entropy(data: ByteString) -&gt; float:
    &#34;&#34;&#34;
    Computes the entropy of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    try:
        import numpy
    except ImportError:
        return entropy_fallback(data)
    hist = numpy.unique(memoryview(data), return_counts=True)[1]
    prob = hist / len(data)
    # 8 bits are the maximum number of bits of information in a byte
    return 0.0 - (numpy.log2(prob) * prob).sum() / 8.0


def index_of_coincidence(data: bytearray) -&gt; float:
    &#34;&#34;&#34;
    Computes the index of coincidence of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    N = len(data)
    if N &lt; 2:
        return 0.0
    try:
        import numpy
    except ImportError:
        C = [data.count(b) for b in range(0x100)]
    else:
        C = numpy.histogram(
            numpy.frombuffer(data, dtype=numpy.uint8),
            numpy.arange(0x100))[0]
    d = 1 / N / (N - 1)
    return float(sum(x * (x - 1) * d for x in C))


def isstream(obj) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether `obj` is a stream. This is currently done by simply testing whether the object
    has an attribute called `read`.
    &#34;&#34;&#34;
    return hasattr(obj, &#39;read&#39;)


def isbuffer(obj) -&gt; bool:
    &#34;&#34;&#34;
    Test whether `obj` is an object that supports the buffer API, like a bytes or bytearray object.
    &#34;&#34;&#34;
    try:
        with memoryview(obj):
            return True
    except TypeError:
        return False


def splitchunks(
    data: ByteString,
    size: int,
    step: Optional[int] = None,
    truncate: bool = False
) -&gt; Iterable[ByteString]:
    &#34;&#34;&#34;
    Split `data` into chunks of size `size`. The cursor advances by `step` bytes after extracting a
    block, the default value for `step` is equal to `size`. The boolean parameter `truncate`
    specifies whether any chunks of size smaller than `size` are generated or whether to abort as
    soon as the last complete chunk of the given size is extracted.
    &#34;&#34;&#34;
    if step is None:
        step = size
    if len(data) &lt;= size:
        if not truncate or len(data) == size:
            yield data
        return
    for k in range(0, len(data), step):
        chunk = data[k:k + size]
        if not chunk:
            break
        if len(chunk) &lt; size and truncate:
            break
        yield chunk


def make_buffer_mutable(data: ByteString):
    &#34;&#34;&#34;
    Returns a mutable version of the input data. Already mutable inputs are returned
    as themselves, i.e. no copy operation occurs in these cases.
    &#34;&#34;&#34;
    if isinstance(data, bytearray):
        return data
    if isinstance(data, memoryview) and not data.readonly:
        return data
    return bytearray(data)


def infinitize(it):
    if not isinstance(it, (
        itertools.cycle,
        itertools.repeat,
        itertools.count
    )):
        if not hasattr(it, &#39;__iter__&#39;) and not hasattr(it, &#39;__next__&#39;):
            it = (it, )
        return itertools.cycle(it)
    return it


try:
    cached_property = functools.cached_property
except AttributeError:
    def cached_property(p):
        return property(functools.lru_cache(maxsize=1)(p))


class NoLogging:
    &#34;&#34;&#34;
    A context manager to prevent various unwanted kinds of logging messages to appear.
    The class is initialized with a given mode that encodes the logging channels to be
    suppressed. After the context is exited, the original logging behavior is restored.
    &#34;&#34;&#34;

    class Mode(IntFlag):
        &#34;&#34;&#34;
        A set of flags for different logging mechanisms to be suppressed.
        &#34;&#34;&#34;
        STD_OUT = 0b0001
        &#34;&#34;&#34;Silence the standard output channel.&#34;&#34;&#34;
        STD_ERR = 0b0010
        &#34;&#34;&#34;Silence the standard error channel.&#34;&#34;&#34;
        WARNING = 0b0100
        &#34;&#34;&#34;Silence the Python warning module.&#34;&#34;&#34;
        LOGGING = 0b1000
        &#34;&#34;&#34;Silence the Python logging module.&#34;&#34;&#34;
        ALL     = 0b1111 # noqa
        &#34;&#34;&#34;Silence all known logging mechanisms.&#34;&#34;&#34;

    def __init__(self, mode: Mode = Mode.WARNING | Mode.LOGGING):
        self.mode = mode

    def __enter__(self):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.CRITICAL)
        if self.mode &amp; NoLogging.Mode.WARNING:
            self._warning_filters = list(warnings.filters)
            warnings.filterwarnings(&#39;ignore&#39;)
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            self._stderr = sys.stderr
            sys.stderr = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            self._stdout = sys.stdout
            sys.stdout = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        return self

    def __exit__(self, *_):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.NOTSET)
        if self.mode &amp; NoLogging.Mode.WARNING:
            warnings.resetwarnings()
            warnings.filters[:] = self._warning_filters
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            sys.stderr.close()
            sys.stderr = self._stderr
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            sys.stdout.close()
            sys.stdout = self._stdout


class NotOne(LookupError):
    &#34;&#34;&#34;
    A custom exception raised by `refinery.lib.tools.one` if the input iterator does not yield
    exactly one element. The property `empty` indicates whether the iterator was empty; if it is
    false, then the exception was raised because the iterator contained more than one element.
    &#34;&#34;&#34;
    def __init__(self, empty: bool):
        how = &#39;none&#39; if empty else &#39;more&#39;
        super().__init__(F&#39;Expected a single item, but the iterator was {how}&#39;)
        self.empty = empty


def one(iterable: Iterable[_T]) -&gt; _T:
    &#34;&#34;&#34;
    The function expects the input `iterable` to be an iterable that yields exactly one element
    and returns that element. Raises `refinery.lib.tools.NotOne` for invalid inputs.
    &#34;&#34;&#34;
    it = iter(iterable)
    try:
        top = next(it)
    except StopIteration:
        raise NotOne(True)
    try:
        next(it)
    except StopIteration:
        return top
    else:
        raise NotOne(False)


def isodate(iso: str) -&gt; Optional[datetime.datetime]:
    &#34;&#34;&#34;
    Convert an input date string in ISO format to a `datetime` object. Contains fallbacks for early
    Python versions.
    &#34;&#34;&#34;
    if len(iso) not in range(16, 25):
        return None
    iso = iso[:19].replace(&#39; &#39;, &#39;T&#39;, 1)
    try:
        try:
            return datetime.datetime.fromisoformat(iso)
        except AttributeError:
            return datetime.datetime.strptime(iso, &#34;%Y-%m-%dT%H:%M:%S&#34;)
    except ValueError:
        return None


def date_from_timestamp(ts: int):
    &#34;&#34;&#34;
    Convert a UTC timestamp to a datetime object.
    &#34;&#34;&#34;
    if sys.version_info &gt;= (3, 12):
        dt = datetime.datetime.fromtimestamp(ts, datetime.UTC)
    else:
        dt = datetime.datetime.utcfromtimestamp(ts)
    return dt.replace(tzinfo=None)


def integers_of_slice(s: slice) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    Returns an iterable that iterates the integers in the range given by the input slice.
    &#34;&#34;&#34;
    if s.stop is None:
        return itertools.count(s.start or 0, s.step or 1)
    else:
        return range(s.start or 0, s.stop, s.step or 1)


def normalize_word_separators(words: str, unified_separator: str, strip: bool = True):
    &#34;&#34;&#34;
    For a sequence of words separated by whitespace, punctuation, slashes, dashes or underscores,
    normalize all occurrences of one or more of these separators to one given symbol. Leading and
    trailing occurrences of separators are removed.
    &#34;&#34;&#34;
    normalized = re.sub(&#39;[-\\s_.,;:/\\\\]+&#39;, unified_separator, words)
    if strip:
        normalized = normalized.strip(unified_separator)
    return normalized


def normalize_to_display(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to dashes.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;-&#39;, strip)


def normalize_to_identifier(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to underscores.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;_&#39;, strip)


def typename(thing):
    &#34;&#34;&#34;
    Determines the name of the type of an object.
    &#34;&#34;&#34;
    if not isinstance(thing, type):
        thing = type(thing)
    mro = [c for c in thing.__mro__ if c is not object]
    if mro:
        thing = mro[~0]
    try:
        return thing.__name__
    except AttributeError:
        return repr(thing)


def exception_to_string(exception: BaseException, default=None) -&gt; str:
    &#34;&#34;&#34;
    Attempts to convert a given exception to a good description that can be exposed to the user.
    &#34;&#34;&#34;
    if not exception.args:
        return exception.__class__.__name__
    it = (a for a in exception.args if isinstance(a, str))
    if default is None:
        default = str(exception)
    return max(it, key=len, default=default).strip()


def nopdoc(obj: object):
    &#34;&#34;&#34;
    This decorator can be applied to any object to exclude it from the automatically generated
    documentation.
    &#34;&#34;&#34;
    pdoc: dict = sys.modules[obj.__module__].__dict__.setdefault(&#39;__pdoc__&#39;, {})
    pdoc[obj.__qualname__] = False
    return obj</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.tools.lookahead"><code class="name flex">
<span>def <span class="ident">lookahead</span></span>(<span>iterator)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements a new iterator from a given one which returns elements <code>(last, item)</code> where each
<code>item</code> is taken from the original iterator and <code>last</code> is a boolean indicating whether this is
the last item.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L25-L43" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lookahead(iterator: Iterable[_T]) -&gt; Generator[Tuple[bool, _T], None, None]:
    &#34;&#34;&#34;
    Implements a new iterator from a given one which returns elements `(last, item)` where each
    `item` is taken from the original iterator and `last` is a boolean indicating whether this is
    the last item.
    &#34;&#34;&#34;
    last = False
    it = iter(iterator)
    try:
        peek = next(it)
    except StopIteration:
        return
    while not last:
        item = peek
        try:
            peek = next(it)
        except StopIteration:
            last = True
        yield last, item</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.get_terminal_size"><code class="name flex">
<span>def <span class="ident">get_terminal_size</span></span>(<span>default=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the size of the currently attached terminal. If the environment variable
<code>REFINERY_TERM_SIZE</code> is set to an integer value, it takes prescedence. If the width of the
terminal cannot be determined or if the width is less than 8 characters, the function
returns zero.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L46-L66" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_terminal_size(default=0):
    &#34;&#34;&#34;
    Returns the size of the currently attached terminal. If the environment variable
    `REFINERY_TERM_SIZE` is set to an integer value, it takes prescedence. If the width of the
    terminal cannot be determined or if the width is less than 8 characters, the function
    returns zero.
    &#34;&#34;&#34;
    from refinery.lib.environment import environment
    ev_terminal_size = environment.term_size.value
    if ev_terminal_size &gt; 0:
        return ev_terminal_size
    width = default
    for stream in (sys.stderr, sys.stdout):
        if stream.isatty():
            try:
                width = os.get_terminal_size(stream.fileno()).columns
            except Exception:
                width = default
            else:
                break
    return default if width &lt; 2 else width - 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.terminalfit"><code class="name flex">
<span>def <span class="ident">terminalfit</span></span>(<span>text, delta=0, width=0, parsep='\n\n', **kw)</span>
</code></dt>
<dd>
<section class="desc"><p>Reformats text to fit the given width while not mangling bullet point lists.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L69-L113" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def terminalfit(text: str, delta: int = 0, width: int = 0, parsep: str = &#39;\n\n&#39;, **kw) -&gt; str:
    &#34;&#34;&#34;
    Reformats text to fit the given width while not mangling bullet point lists.
    &#34;&#34;&#34;
    import textwrap
    import re

    width = width or get_terminal_size()
    width = width - delta

    def isol(t): return re.match(R&#39;^\(\d+\)|\d+[.:;]&#39;, t)
    def isul(t): return t.startswith(&#39;-&#39;) or t.startswith(&#39;*&#39;)
    def issp(t): return t.startswith(&#39;  &#39;)

    text = text.replace(&#39;\r&#39;, &#39;&#39;)

    def bulletpoint(line):
        wrapped = textwrap.wrap(line, width - 2, **kw)
        indent = &#39;  &#39; if isul(line) else &#39;   &#39;
        wrapped[1:] = [&#39;{}{}&#39;.format(indent, line) for line in wrapped[1:]]
        return &#39;\n&#39;.join(wrapped)

    def fitted(paragraphs):
        for k, p in enumerate(paragraphs):
            if p.startswith(&#39; &#39;):
                yield p
                continue
            ol, ul = isol(p), isul(p)
            if ol or ul:
                input_lines = p.splitlines(keepends=False)
                unwrapped_line = input_lines[0].rstrip()
                lines = []
                if (ol and all(isol(t) or issp(t) for t in input_lines) or ul and all(isul(t) or issp(t) for t in input_lines)):
                    for line in input_lines[1:]:
                        if not (ol and isol(line) or ul and isul(line)):
                            unwrapped_line += &#39; &#39; + line.strip()
                            continue
                        lines.append(bulletpoint(unwrapped_line))
                        unwrapped_line = line.rstrip()
                    lines.append(bulletpoint(unwrapped_line))
                    yield &#39;\n&#39;.join(lines)
                    continue
            yield &#39;\n&#39;.join(textwrap.wrap(p, width, **kw))

    return parsep.join(fitted(text.split(&#39;\n\n&#39;)))</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.documentation"><code class="name flex">
<span>def <span class="ident">documentation</span></span>(<span>unit)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the documentation string of a given unit as it should be displayed on the command line.
Certain pdoc3-specific reference strings are removed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L116-L124" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def documentation(unit):
    &#34;&#34;&#34;
    Return the documentation string of a given unit as it should be displayed on the command line.
    Certain pdoc3-specific reference strings are removed.
    &#34;&#34;&#34;
    import re
    docs = inspect.getdoc(unit)
    docs = re.sub(R&#39;`refinery\.(?:\w+\.)*(\w+)`&#39;, R&#39;\1&#39;, docs)
    return docs.replace(&#39;`&#39;, &#39;&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<section class="desc"><p>Iterates the first element of an iterator and returns None if this fails. Otherwise, it returns
both the first element and a new iterable which will return the same elements as the input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L127-L141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def begin(iterable: Iterable[_T]) -&gt; Optional[Tuple[_T, Iterable[_T]]]:
    &#34;&#34;&#34;
    Iterates the first element of an iterator and returns None if this fails. Otherwise, it returns
    both the first element and a new iterable which will return the same elements as the input.
    &#34;&#34;&#34;
    try:
        body = iter(iterable)
        head = next(body)
    except StopIteration:
        return None
    else:
        def _fused():
            yield head
            yield from body
        return head, _fused()</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.skipfirst"><code class="name flex">
<span>def <span class="ident">skipfirst</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an interable where the first element of the input iterable was skipped.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L144-L150" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def skipfirst(iterable: Iterable[_T]) -&gt; Generator[_T, None, None]:
    &#34;&#34;&#34;
    Returns an interable where the first element of the input iterable was skipped.
    &#34;&#34;&#34;
    it = iter(iterable)
    next(it)
    yield from it</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.autoinvoke"><code class="name flex">
<span>def <span class="ident">autoinvoke</span></span>(<span>method, keywords)</span>
</code></dt>
<dd>
<section class="desc"><p>For each parameter that <code>method</code> expects, this function looks for an entry in <code>keywords</code> which
has the same name as that parameter. <code><a title="refinery.lib.tools.autoinvoke" href="#refinery.lib.tools.autoinvoke">autoinvoke()</a></code> then calls <code>method</code> with all matching
parameters forwarded in the appropriate manner.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L153-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def autoinvoke(method: Callable[..., _T], keywords: dict) -&gt; _T:
    &#34;&#34;&#34;
    For each parameter that `method` expects, this function looks for an entry in `keywords` which
    has the same name as that parameter. `autoinvoke` then calls `method` with all matching
    parameters forwarded in the appropriate manner.
    &#34;&#34;&#34;

    kwdargs = {}
    posargs = []
    varargs = []
    kwdjoin = False

    for p in inspect.signature(method).parameters.values():
        if p.kind is p.VAR_KEYWORD:
            kwdjoin = True
        try:
            value = keywords.pop(p.name)
        except KeyError:
            if p.kind is p.VAR_KEYWORD:
                continue
            value = p.default
            if value is p.empty:
                raise ValueError(F&#39;missing required parameter {p.name}&#39;)
        if p.kind is p.POSITIONAL_OR_KEYWORD or p.kind is p.POSITIONAL_ONLY:
            if value == p.default:
                # when equality holds, we force identity
                value = p.default
            posargs.append(value)
        elif p.kind is p.VAR_POSITIONAL:
            varargs = value
        elif p.kind is p.KEYWORD_ONLY:
            kwdargs[p.name] = value

    if kwdjoin:
        kwdargs.update(keywords)

    return method(*posargs, *varargs, **kwdargs)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.entropy_fallback"><code class="name flex">
<span>def <span class="ident">entropy_fallback</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is called by <code><a title="refinery.lib.tools.entropy" href="#refinery.lib.tools.entropy">entropy()</a></code> when the <code>numpy</code> module is not available.
It computes the shannon entropy of the input byte string and is written in pure Python.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L192-L202" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def entropy_fallback(data: ByteString) -&gt; float:
    &#34;&#34;&#34;
    This method is called by `refinery.lib.tools.entropy` when the `numpy` module is not available.
    It computes the shannon entropy of the input byte string and is written in pure Python.
    &#34;&#34;&#34;
    if isinstance(data, memoryview):
        # this copy is better than re-implementing count in Python for memory views
        data = bytes(data)
    histogram = {b: data.count(b) for b in range(0x100)}
    S = [histogram[b] / len(data) for b in histogram]
    return 0.0 + -sum(p * log(p, 2) for p in S if p) / 8.0</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.entropy"><code class="name flex">
<span>def <span class="ident">entropy</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes the entropy of <code>data</code> over the alphabet of all bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L205-L218" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def entropy(data: ByteString) -&gt; float:
    &#34;&#34;&#34;
    Computes the entropy of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    try:
        import numpy
    except ImportError:
        return entropy_fallback(data)
    hist = numpy.unique(memoryview(data), return_counts=True)[1]
    prob = hist / len(data)
    # 8 bits are the maximum number of bits of information in a byte
    return 0.0 - (numpy.log2(prob) * prob).sum() / 8.0</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.index_of_coincidence"><code class="name flex">
<span>def <span class="ident">index_of_coincidence</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes the index of coincidence of <code>data</code> over the alphabet of all bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L221-L239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def index_of_coincidence(data: bytearray) -&gt; float:
    &#34;&#34;&#34;
    Computes the index of coincidence of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    N = len(data)
    if N &lt; 2:
        return 0.0
    try:
        import numpy
    except ImportError:
        C = [data.count(b) for b in range(0x100)]
    else:
        C = numpy.histogram(
            numpy.frombuffer(data, dtype=numpy.uint8),
            numpy.arange(0x100))[0]
    d = 1 / N / (N - 1)
    return float(sum(x * (x - 1) * d for x in C))</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.isstream"><code class="name flex">
<span>def <span class="ident">isstream</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Tests whether <code>obj</code> is a stream. This is currently done by simply testing whether the object
has an attribute called <code>read</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L242-L247" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isstream(obj) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether `obj` is a stream. This is currently done by simply testing whether the object
    has an attribute called `read`.
    &#34;&#34;&#34;
    return hasattr(obj, &#39;read&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.isbuffer"><code class="name flex">
<span>def <span class="ident">isbuffer</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Test whether <code>obj</code> is an object that supports the buffer API, like a bytes or bytearray object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L250-L258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isbuffer(obj) -&gt; bool:
    &#34;&#34;&#34;
    Test whether `obj` is an object that supports the buffer API, like a bytes or bytearray object.
    &#34;&#34;&#34;
    try:
        with memoryview(obj):
            return True
    except TypeError:
        return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.splitchunks"><code class="name flex">
<span>def <span class="ident">splitchunks</span></span>(<span>data, size, step=None, truncate=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Split <code>data</code> into chunks of size <code>size</code>. The cursor advances by <code>step</code> bytes after extracting a
block, the default value for <code>step</code> is equal to <code>size</code>. The boolean parameter <code>truncate</code>
specifies whether any chunks of size smaller than <code>size</code> are generated or whether to abort as
soon as the last complete chunk of the given size is extracted.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L261-L285" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def splitchunks(
    data: ByteString,
    size: int,
    step: Optional[int] = None,
    truncate: bool = False
) -&gt; Iterable[ByteString]:
    &#34;&#34;&#34;
    Split `data` into chunks of size `size`. The cursor advances by `step` bytes after extracting a
    block, the default value for `step` is equal to `size`. The boolean parameter `truncate`
    specifies whether any chunks of size smaller than `size` are generated or whether to abort as
    soon as the last complete chunk of the given size is extracted.
    &#34;&#34;&#34;
    if step is None:
        step = size
    if len(data) &lt;= size:
        if not truncate or len(data) == size:
            yield data
        return
    for k in range(0, len(data), step):
        chunk = data[k:k + size]
        if not chunk:
            break
        if len(chunk) &lt; size and truncate:
            break
        yield chunk</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.make_buffer_mutable"><code class="name flex">
<span>def <span class="ident">make_buffer_mutable</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a mutable version of the input data. Already mutable inputs are returned
as themselves, i.e. no copy operation occurs in these cases.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L288-L297" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def make_buffer_mutable(data: ByteString):
    &#34;&#34;&#34;
    Returns a mutable version of the input data. Already mutable inputs are returned
    as themselves, i.e. no copy operation occurs in these cases.
    &#34;&#34;&#34;
    if isinstance(data, bytearray):
        return data
    if isinstance(data, memoryview) and not data.readonly:
        return data
    return bytearray(data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.infinitize"><code class="name flex">
<span>def <span class="ident">infinitize</span></span>(<span>it)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L300-L309" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def infinitize(it):
    if not isinstance(it, (
        itertools.cycle,
        itertools.repeat,
        itertools.count
    )):
        if not hasattr(it, &#39;__iter__&#39;) and not hasattr(it, &#39;__next__&#39;):
            it = (it, )
        return itertools.cycle(it)
    return it</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.one"><code class="name flex">
<span>def <span class="ident">one</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<section class="desc"><p>The function expects the input <code>iterable</code> to be an iterable that yields exactly one element
and returns that element. Raises <code><a title="refinery.lib.tools.NotOne" href="#refinery.lib.tools.NotOne">NotOne</a></code> for invalid inputs.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L384-L399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def one(iterable: Iterable[_T]) -&gt; _T:
    &#34;&#34;&#34;
    The function expects the input `iterable` to be an iterable that yields exactly one element
    and returns that element. Raises `refinery.lib.tools.NotOne` for invalid inputs.
    &#34;&#34;&#34;
    it = iter(iterable)
    try:
        top = next(it)
    except StopIteration:
        raise NotOne(True)
    try:
        next(it)
    except StopIteration:
        return top
    else:
        raise NotOne(False)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.isodate"><code class="name flex">
<span>def <span class="ident">isodate</span></span>(<span>iso)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert an input date string in ISO format to a <code>datetime</code> object. Contains fallbacks for early
Python versions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L402-L416" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isodate(iso: str) -&gt; Optional[datetime.datetime]:
    &#34;&#34;&#34;
    Convert an input date string in ISO format to a `datetime` object. Contains fallbacks for early
    Python versions.
    &#34;&#34;&#34;
    if len(iso) not in range(16, 25):
        return None
    iso = iso[:19].replace(&#39; &#39;, &#39;T&#39;, 1)
    try:
        try:
            return datetime.datetime.fromisoformat(iso)
        except AttributeError:
            return datetime.datetime.strptime(iso, &#34;%Y-%m-%dT%H:%M:%S&#34;)
    except ValueError:
        return None</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.date_from_timestamp"><code class="name flex">
<span>def <span class="ident">date_from_timestamp</span></span>(<span>ts)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert a UTC timestamp to a datetime object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L419-L427" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def date_from_timestamp(ts: int):
    &#34;&#34;&#34;
    Convert a UTC timestamp to a datetime object.
    &#34;&#34;&#34;
    if sys.version_info &gt;= (3, 12):
        dt = datetime.datetime.fromtimestamp(ts, datetime.UTC)
    else:
        dt = datetime.datetime.utcfromtimestamp(ts)
    return dt.replace(tzinfo=None)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.integers_of_slice"><code class="name flex">
<span>def <span class="ident">integers_of_slice</span></span>(<span>s)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an iterable that iterates the integers in the range given by the input slice.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L430-L437" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def integers_of_slice(s: slice) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    Returns an iterable that iterates the integers in the range given by the input slice.
    &#34;&#34;&#34;
    if s.stop is None:
        return itertools.count(s.start or 0, s.step or 1)
    else:
        return range(s.start or 0, s.stop, s.step or 1)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.normalize_word_separators"><code class="name flex">
<span>def <span class="ident">normalize_word_separators</span></span>(<span>words, unified_separator, strip=True)</span>
</code></dt>
<dd>
<section class="desc"><p>For a sequence of words separated by whitespace, punctuation, slashes, dashes or underscores,
normalize all occurrences of one or more of these separators to one given symbol. Leading and
trailing occurrences of separators are removed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L440-L449" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize_word_separators(words: str, unified_separator: str, strip: bool = True):
    &#34;&#34;&#34;
    For a sequence of words separated by whitespace, punctuation, slashes, dashes or underscores,
    normalize all occurrences of one or more of these separators to one given symbol. Leading and
    trailing occurrences of separators are removed.
    &#34;&#34;&#34;
    normalized = re.sub(&#39;[-\\s_.,;:/\\\\]+&#39;, unified_separator, words)
    if strip:
        normalized = normalized.strip(unified_separator)
    return normalized</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.normalize_to_display"><code class="name flex">
<span>def <span class="ident">normalize_to_display</span></span>(<span>words, strip=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalizes all separators to dashes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L452-L456" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize_to_display(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to dashes.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;-&#39;, strip)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.normalize_to_identifier"><code class="name flex">
<span>def <span class="ident">normalize_to_identifier</span></span>(<span>words, strip=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalizes all separators to underscores.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L459-L463" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize_to_identifier(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to underscores.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;_&#39;, strip)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.typename"><code class="name flex">
<span>def <span class="ident">typename</span></span>(<span>thing)</span>
</code></dt>
<dd>
<section class="desc"><p>Determines the name of the type of an object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L466-L478" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def typename(thing):
    &#34;&#34;&#34;
    Determines the name of the type of an object.
    &#34;&#34;&#34;
    if not isinstance(thing, type):
        thing = type(thing)
    mro = [c for c in thing.__mro__ if c is not object]
    if mro:
        thing = mro[~0]
    try:
        return thing.__name__
    except AttributeError:
        return repr(thing)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.exception_to_string"><code class="name flex">
<span>def <span class="ident">exception_to_string</span></span>(<span>exception, default=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to convert a given exception to a good description that can be exposed to the user.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L481-L490" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def exception_to_string(exception: BaseException, default=None) -&gt; str:
    &#34;&#34;&#34;
    Attempts to convert a given exception to a good description that can be exposed to the user.
    &#34;&#34;&#34;
    if not exception.args:
        return exception.__class__.__name__
    it = (a for a in exception.args if isinstance(a, str))
    if default is None:
        default = str(exception)
    return max(it, key=len, default=default).strip()</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.nopdoc"><code class="name flex">
<span>def <span class="ident">nopdoc</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>This decorator can be applied to any object to exclude it from the automatically generated
documentation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L493-L500" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nopdoc(obj: object):
    &#34;&#34;&#34;
    This decorator can be applied to any object to exclude it from the automatically generated
    documentation.
    &#34;&#34;&#34;
    pdoc: dict = sys.modules[obj.__module__].__dict__.setdefault(&#39;__pdoc__&#39;, {})
    pdoc[obj.__qualname__] = False
    return obj</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.tools.NoLogging"><code class="flex name class">
<span>class <span class="ident">NoLogging</span></span>
<span>(</span><span>mode=Mode.LOGGING|WARNING)</span>
</code></dt>
<dd>
<section class="desc"><p>A context manager to prevent various unwanted kinds of logging messages to appear.
The class is initialized with a given mode that encodes the logging channels to be
suppressed. After the context is exited, the original logging behavior is restored.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L319-L369" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class NoLogging:
    &#34;&#34;&#34;
    A context manager to prevent various unwanted kinds of logging messages to appear.
    The class is initialized with a given mode that encodes the logging channels to be
    suppressed. After the context is exited, the original logging behavior is restored.
    &#34;&#34;&#34;

    class Mode(IntFlag):
        &#34;&#34;&#34;
        A set of flags for different logging mechanisms to be suppressed.
        &#34;&#34;&#34;
        STD_OUT = 0b0001
        &#34;&#34;&#34;Silence the standard output channel.&#34;&#34;&#34;
        STD_ERR = 0b0010
        &#34;&#34;&#34;Silence the standard error channel.&#34;&#34;&#34;
        WARNING = 0b0100
        &#34;&#34;&#34;Silence the Python warning module.&#34;&#34;&#34;
        LOGGING = 0b1000
        &#34;&#34;&#34;Silence the Python logging module.&#34;&#34;&#34;
        ALL     = 0b1111 # noqa
        &#34;&#34;&#34;Silence all known logging mechanisms.&#34;&#34;&#34;

    def __init__(self, mode: Mode = Mode.WARNING | Mode.LOGGING):
        self.mode = mode

    def __enter__(self):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.CRITICAL)
        if self.mode &amp; NoLogging.Mode.WARNING:
            self._warning_filters = list(warnings.filters)
            warnings.filterwarnings(&#39;ignore&#39;)
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            self._stderr = sys.stderr
            sys.stderr = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            self._stdout = sys.stdout
            sys.stdout = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        return self

    def __exit__(self, *_):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.NOTSET)
        if self.mode &amp; NoLogging.Mode.WARNING:
            warnings.resetwarnings()
            warnings.filters[:] = self._warning_filters
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            sys.stderr.close()
            sys.stderr = self._stderr
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            sys.stdout.close()
            sys.stdout = self._stdout</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.tools.NoLogging.Mode"><code class="name">var <span class="ident">Mode</span></code></dt>
<dd>
<section class="desc"><p>A set of flags for different logging mechanisms to be suppressed.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.tools.NotOne"><code class="flex name class">
<span>class <span class="ident">NotOne</span></span>
<span>(</span><span>empty)</span>
</code></dt>
<dd>
<section class="desc"><p>A custom exception raised by <code><a title="refinery.lib.tools.one" href="#refinery.lib.tools.one">one()</a></code> if the input iterator does not yield
exactly one element. The property <code>empty</code> indicates whether the iterator was empty; if it is
false, then the exception was raised because the iterator contained more than one element.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/tools.py#L372-L381" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class NotOne(LookupError):
    &#34;&#34;&#34;
    A custom exception raised by `refinery.lib.tools.one` if the input iterator does not yield
    exactly one element. The property `empty` indicates whether the iterator was empty; if it is
    false, then the exception was raised because the iterator contained more than one element.
    &#34;&#34;&#34;
    def __init__(self, empty: bool):
        how = &#39;none&#39; if empty else &#39;more&#39;
        super().__init__(F&#39;Expected a single item, but the iterator was {how}&#39;)
        self.empty = empty</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.LookupError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.tools.lookahead" href="#refinery.lib.tools.lookahead">lookahead</a></code></li>
<li><code><a title="refinery.lib.tools.get_terminal_size" href="#refinery.lib.tools.get_terminal_size">get_terminal_size</a></code></li>
<li><code><a title="refinery.lib.tools.terminalfit" href="#refinery.lib.tools.terminalfit">terminalfit</a></code></li>
<li><code><a title="refinery.lib.tools.documentation" href="#refinery.lib.tools.documentation">documentation</a></code></li>
<li><code><a title="refinery.lib.tools.begin" href="#refinery.lib.tools.begin">begin</a></code></li>
<li><code><a title="refinery.lib.tools.skipfirst" href="#refinery.lib.tools.skipfirst">skipfirst</a></code></li>
<li><code><a title="refinery.lib.tools.autoinvoke" href="#refinery.lib.tools.autoinvoke">autoinvoke</a></code></li>
<li><code><a title="refinery.lib.tools.entropy_fallback" href="#refinery.lib.tools.entropy_fallback">entropy_fallback</a></code></li>
<li><code><a title="refinery.lib.tools.entropy" href="#refinery.lib.tools.entropy">entropy</a></code></li>
<li><code><a title="refinery.lib.tools.index_of_coincidence" href="#refinery.lib.tools.index_of_coincidence">index_of_coincidence</a></code></li>
<li><code><a title="refinery.lib.tools.isstream" href="#refinery.lib.tools.isstream">isstream</a></code></li>
<li><code><a title="refinery.lib.tools.isbuffer" href="#refinery.lib.tools.isbuffer">isbuffer</a></code></li>
<li><code><a title="refinery.lib.tools.splitchunks" href="#refinery.lib.tools.splitchunks">splitchunks</a></code></li>
<li><code><a title="refinery.lib.tools.make_buffer_mutable" href="#refinery.lib.tools.make_buffer_mutable">make_buffer_mutable</a></code></li>
<li><code><a title="refinery.lib.tools.infinitize" href="#refinery.lib.tools.infinitize">infinitize</a></code></li>
<li><code><a title="refinery.lib.tools.one" href="#refinery.lib.tools.one">one</a></code></li>
<li><code><a title="refinery.lib.tools.isodate" href="#refinery.lib.tools.isodate">isodate</a></code></li>
<li><code><a title="refinery.lib.tools.date_from_timestamp" href="#refinery.lib.tools.date_from_timestamp">date_from_timestamp</a></code></li>
<li><code><a title="refinery.lib.tools.integers_of_slice" href="#refinery.lib.tools.integers_of_slice">integers_of_slice</a></code></li>
<li><code><a title="refinery.lib.tools.normalize_word_separators" href="#refinery.lib.tools.normalize_word_separators">normalize_word_separators</a></code></li>
<li><code><a title="refinery.lib.tools.normalize_to_display" href="#refinery.lib.tools.normalize_to_display">normalize_to_display</a></code></li>
<li><code><a title="refinery.lib.tools.normalize_to_identifier" href="#refinery.lib.tools.normalize_to_identifier">normalize_to_identifier</a></code></li>
<li><code><a title="refinery.lib.tools.typename" href="#refinery.lib.tools.typename">typename</a></code></li>
<li><code><a title="refinery.lib.tools.exception_to_string" href="#refinery.lib.tools.exception_to_string">exception_to_string</a></code></li>
<li><code><a title="refinery.lib.tools.nopdoc" href="#refinery.lib.tools.nopdoc">nopdoc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.tools.NoLogging" href="#refinery.lib.tools.NoLogging">NoLogging</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.tools.NotOne" href="#refinery.lib.tools.NotOne">NotOne</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>