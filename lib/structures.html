<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>the refinery.lib.structures documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.structures</code></h1>
</header>
<section id="section-intro">
<p>Interfaces and classes to read structured data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L1-L806" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Interfaces and classes to read structured data.
&#34;&#34;&#34;
from __future__ import annotations

import contextlib
import codecs
import itertools
import enum
import functools
import io
import re
import struct
import weakref

from typing import (
    overload,
    Any,
    ByteString,
    Dict,
    Generic,
    Iterable,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
    Union,
)


T = TypeVar(&#39;T&#39;, bound=Union[bytearray, bytes, memoryview])
C = TypeVar(&#39;C&#39;, bound=Union[bytearray, bytes, memoryview])
R = TypeVar(&#39;R&#39;, bound=io.IOBase)

UnpackType = Union[int, bool, float, bytes]


def signed(k: int, bitsize: int):
    &#34;&#34;&#34;
    If `k` is an integer of the given bit size, cast it to a signed one.
    &#34;&#34;&#34;
    M = 1 &lt;&lt; bitsize
    k = k &amp; (M - 1)
    return k - M if k &gt;&gt; (bitsize - 1) else k


class EOF(EOFError):
    &#34;&#34;&#34;
    While reading from a `refinery.lib.structures.MemoryFile`, less bytes were available than
    requested. The exception contains the data from the incomplete read.
    &#34;&#34;&#34;
    def __init__(self, rest: ByteString = B&#39;&#39;):
        super().__init__(&#39;Unexpected end of buffer.&#39;)
        self.rest = rest

    def __bytes__(self):
        return bytes(self.rest)


class StreamDetour(Generic[R]):
    &#34;&#34;&#34;
    A stream detour is used as a context manager to temporarily read from a different location
    in the stream and then return to the original offset when the context ends.
    &#34;&#34;&#34;
    def __init__(self, stream: R, offset: Optional[int] = None, whence: int = io.SEEK_SET):
        self.stream = stream
        self.offset = offset
        self.whence = whence

    def __enter__(self):
        self.cursor = self.stream.tell()
        if self.offset is not None:
            self.stream.seek(self.offset, self.whence)
        return self

    def __exit__(self, *args):
        self.stream.seek(self.cursor, io.SEEK_SET)


class MemoryFileMethods(Generic[T]):
    &#34;&#34;&#34;
    A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
    file-like object.
    &#34;&#34;&#34;
    closed: bool
    read_as_bytes: bool

    _data: T
    _cursor: int
    _closed: bool

    class SEEK(int, enum.Enum):
        CUR = io.SEEK_CUR
        END = io.SEEK_END
        SET = io.SEEK_SET

    def __init__(
        self,
        data: Optional[T] = None,
        read_as_bytes=False,
        fileno: Optional[int] = None,
        size_limit: Optional[int] = None,
    ) -&gt; None:
        if data is None:
            data = bytearray()
        elif size_limit is not None and len(data) &gt; size_limit:
            raise ValueError(&#39;Initial data exceeds size limit&#39;)
        self._data = data
        self._cursor = 0
        self._closed = False
        self._fileno = fileno
        self.read_as_bytes = read_as_bytes
        self._size_limit = size_limit

    def close(self) -&gt; None:
        self._closed = True

    @property
    def closed(self) -&gt; bool:
        return self._closed

    def __enter__(self) -&gt; MemoryFile:
        return self

    def __exit__(self, ex_type, ex_value, trace) -&gt; bool:
        return False

    def flush(self) -&gt; None:
        pass

    def isatty(self) -&gt; bool:
        return False

    def __iter__(self):
        return self

    def __len__(self):
        return len(self._data)

    def __next__(self):
        line = self.readline()
        if not line:
            raise StopIteration
        return line

    def fileno(self) -&gt; int:
        if self._fileno is None:
            raise OSError
        return self._fileno

    def readable(self) -&gt; bool:
        return not self._closed

    def seekable(self) -&gt; bool:
        return not self._closed

    @property
    def eof(self) -&gt; bool:
        return self._closed or self._cursor &gt;= len(self._data)

    @property
    def remaining_bytes(self) -&gt; int:
        return len(self._data) - self.tell()

    def detour(self, offset: Optional[int] = None, whence: int = io.SEEK_SET):
        return StreamDetour(self, offset, whence=whence)

    def writable(self) -&gt; bool:
        if self._closed:
            return False
        if isinstance(self._data, memoryview):
            return not self._data.readonly
        return isinstance(self._data, bytearray)

    def read_as(self, cast: Type[C], size: int = -1, peek: bool = False) -&gt; C:
        out = self.read(size, peek)
        if not isinstance(out, cast):
            out = cast(out)
        return out

    def read(self, size: int = -1, peek: bool = False) -&gt; T:
        beginning = self._cursor
        if size is None or size &lt; 0:
            end = len(self._data)
        else:
            end = min(self._cursor + size, len(self._data))
        result = self._data[beginning:end]
        if self.read_as_bytes and not isinstance(result, bytes):
            result = bytes(result)
        if not peek:
            self._cursor = end
        return result

    def peek(self, size: int = -1) -&gt; memoryview:
        cursor = self._cursor
        mv = memoryview(self._data)
        if size is None or size &lt; 0:
            return mv[cursor:]
        return mv[cursor:cursor + size]

    def read1(self, size: int = -1, peek: bool = False) -&gt; T:
        return self.read(size, peek)

    def _find_linebreak(self, beginning: int, end: int) -&gt; int:
        if not isinstance(self._data, memoryview):
            return self._data.find(B&#39;\n&#39;, beginning, end)
        for k in range(beginning, end):
            if self._data[k] == 0xA: return k
        return -1

    def readline(self, size: int = -1) -&gt; T:
        beginning, end = self._cursor, len(self._data)
        if size is not None and size &gt;= 0:
            end = beginning + size
        p = self._find_linebreak(beginning, end)
        self._cursor = end if p &lt; 0 else p + 1
        result = self._data[beginning:self._cursor]
        if self.read_as_bytes and not isinstance(result, bytes):
            result = bytes(result)
        return result

    def readlines(self, hint: int = -1) -&gt; Iterable[T]:
        if hint is None or hint &lt; 0:
            yield from self
        else:
            total = 0
            while total &lt; hint:
                line = next(self)
                total += len(line)
                yield line

    def readinto1(self, b) -&gt; int:
        data = self.read(len(b))
        size = len(data)
        b[:size] = data
        return size

    def readinto(self, b) -&gt; int:
        return self.readinto1(b)

    def tell(self) -&gt; int:
        return self._cursor

    def seekrel(self, offset: int) -&gt; int:
        return self.seek(offset, io.SEEK_CUR)

    def seekset(self, offset: int) -&gt; int:
        if offset &lt; 0:
            return self.seek(offset, io.SEEK_END)
        else:
            return self.seek(offset, io.SEEK_SET)

    def getbuffer(self) -&gt; T:
        return self._data

    def getvalue(self) -&gt; T:
        return self._data

    def seek(self, offset: int, whence=io.SEEK_SET) -&gt; int:
        if whence == io.SEEK_SET:
            if offset &lt; 0:
                raise ValueError(&#39;no negative offsets allowed for SEEK_SET.&#39;)
            self._cursor = offset
        elif whence == io.SEEK_CUR:
            self._cursor += offset
        elif whence == io.SEEK_END:
            self._cursor = len(self._data) + offset
        self._cursor = max(self._cursor, 0)
        self._cursor = min(self._cursor, len(self._data))
        return self._cursor

    def writelines(self, lines: Iterable[ByteString]) -&gt; None:
        for line in lines:
            self.write(line)

    def truncate(self, size=None) -&gt; None:
        if size is not None:
            if not (0 &lt;= size &lt;= len(self._data)):
                raise ValueError(&#39;invalid size value&#39;)
            self._cursor = size
        del self._data[self._cursor:]

    def write_byte(self, byte: int) -&gt; None:
        limit = self._size_limit
        cc = self._cursor
        nc = cc + 1
        if limit and nc &gt; limit:
            raise EOF(bytes((byte,)))
        try:
            if cc &lt; len(self._data):
                self._data[cc] = byte
            else:
                self._data.append(byte)
        except Exception as T:
            raise OSError(str(T)) from T
        else:
            self._cursor = nc

    def write(self, data: Iterable[int]) -&gt; int:
        out = self._data
        end = len(out)
        beginning = self._cursor
        limit = self._size_limit

        if limit is None and beginning == end:
            out[end:] = data
            self._cursor = end = len(out)
            return end - beginning
        try:
            size = len(data)
        except Exception:
            it = iter(data)
            for cursor, b in enumerate(it, beginning):
                out[cursor] = b
                if cursor &gt;= end - 1:
                    break
            else:
                cursor += 1
                self._cursor = cursor
                return cursor - beginning
            if limit is None:
                out[end:] = it
            else:
                out[end:limit] = itertools.islice(it, 0, limit - end)
                try:
                    b = next(it)
                except StopIteration:
                    self._cursor = limit
                    return limit - beginning
                else:
                    rest = bytearray((b,))
                    rest[1:] = it
                    raise EOF(rest)
        else:
            if limit and size + beginning &gt; limit:
                raise EOF(data)
            self._cursor += size
            try:
                self._data[beginning:self._cursor] = data
            except Exception as T:
                self._cursor = beginning
                raise OSError(str(T)) from T
            return size
        self._cursor = end = len(out)
        return end - beginning

    def __getitem__(self, slice):
        result = self._data[slice]
        if self.read_as_bytes and not isinstance(result, bytes):
            result = bytes(result)
        return result

    def replay(self, offset: int, length: int):
        if offset not in range(self._cursor + 1):
            raise ValueError(F&#39;The supplied delta {offset} is not in the valid range [0,{self._cursor}].&#39;)
        rep, r = divmod(length, offset)
        offset = -offset - len(self) + self._cursor
        replay = self._data[offset:offset + r]
        if rep &gt; 0:
            replay = bytes(self._data[offset:self._cursor]) * rep + replay
        self.write(replay)


class MemoryFile(MemoryFileMethods[T], io.BytesIO):
    pass


class order(str, enum.Enum):
    big = &#39;&gt;&#39;
    little = &#39;&lt;&#39;


class StructReader(MemoryFile[T]):
    &#34;&#34;&#34;
    An extension of a `refinery.lib.structures.MemoryFile` which provides methods to read
    structured data.
    &#34;&#34;&#34;

    class Unaligned(RuntimeError):
        pass

    def __init__(self, data: T, bigendian: bool = False):
        super().__init__(data)
        self._bbits = 0
        self._nbits = 0
        self.bigendian = bigendian

    def __enter__(self) -&gt; StructReader:
        return super().__enter__()

    @property
    @contextlib.contextmanager
    def be(self):
        self.bigendian = True
        try:
            yield self
        finally:
            self.bigendian = False

    @property
    def byteorder_format(self) -&gt; str:
        return &#39;&gt;&#39; if self.bigendian else &#39;&lt;&#39;

    @property
    def byteorder_name(self) -&gt; str:
        return &#39;big&#39; if self.bigendian else &#39;little&#39;

    def seek(self, offset, whence=io.SEEK_SET) -&gt; int:
        self._bbits = 0
        self._nbits = 0
        return super().seek(offset, whence)

    def read_exactly(self, size: Optional[int] = None, peek: bool = False) -&gt; T:
        &#34;&#34;&#34;
        Read bytes from the underlying stream. Raises a `RuntimeError` when the stream is not currently
        byte-aligned, i.e. when `refinery.lib.structures.StructReader.byte_aligned` is `False`. Raises
        an exception of type `refinery.lib.structures.EOF` when fewer data is available in the stream than
        requested via the `size` parameter. The remaining data can be extracted from the exception.
        Use `refinery.lib.structures.StructReader.read_bytes` to read bytes from the stream when it is
        not byte-aligned.
        &#34;&#34;&#34;
        if not self.byte_aligned:
            raise StructReader.Unaligned(&#39;buffer is not byte-aligned&#39;)
        data = self.read1(size, peek)
        if size and len(data) &lt; size:
            raise EOF(data)
        return data

    @property
    def byte_aligned(self) -&gt; bool:
        &#34;&#34;&#34;
        This property is `True` if and only if there are currently no bits still waiting in the internal
        bit buffer.
        &#34;&#34;&#34;
        return not self._nbits

    def byte_align(self, blocksize: int = 1) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
        tuple containing the size and contents of the bit buffer.
        &#34;&#34;&#34;
        nbits = self._nbits
        bbits = self._bbits
        self._nbits = 0
        self._bbits = 0
        mod = self._cursor % blocksize
        if mod:
            self.seekrel(blocksize - mod)
        return nbits, bbits

    @property
    def remaining_bits(self) -&gt; int:
        return 8 * self.remaining_bytes + self._nbits

    def read_integer(self, length: Optional[int] = None, peek: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Read `length` many bits from the underlying stream as an integer.
        &#34;&#34;&#34;
        if length is None:
            length = self.remaining_bits
        if length &lt; 0:
            raise ValueError
        if length &lt; self._nbits:
            new_count = self._nbits - length
            if self.bigendian:
                result = self._bbits &gt;&gt; new_count
                if not peek:
                    self._bbits ^= result &lt;&lt; new_count
            else:
                result = self._bbits &amp; 2 ** length - 1
                if not peek:
                    self._bbits &gt;&gt;= length
            if not peek:
                self._nbits = new_count
            return result

        nbits, bbits = self._nbits, self._bbits
        number_of_missing_bits = length - nbits
        bytecount, rest = divmod(number_of_missing_bits, 8)
        if rest:
            bytecount += 1
            rest = 8 - rest
        bb = self.read1(bytecount, True)
        if len(bb) != bytecount:
            raise EOFError
        if not peek:
            self.seekrel(bytecount)
        if bytecount == 1:
            result, = bb
        else:
            result = int.from_bytes(bb, self.byteorder_name)
        if not nbits and not rest:
            return result
        if self.bigendian:
            rbmask   = 2 ** rest - 1       # noqa
            excess   = result &amp; rbmask     # noqa
            result &gt;&gt;= rest                # noqa
            result  ^= bbits &lt;&lt; number_of_missing_bits   # noqa
        else:
            excess   = result &gt;&gt; number_of_missing_bits  # noqa
            result  ^= excess &lt;&lt; number_of_missing_bits  # noqa
            result &lt;&lt;= nbits               # noqa
            result  |= bbits               # noqa
        assert excess.bit_length() &lt;= rest
        if not peek:
            self._nbits = rest
            self._bbits = excess
        return result

    def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        The method reads `size` many bytes from the underlying stream starting at the current bit.
        &#34;&#34;&#34;
        if self.byte_aligned:
            data = self.read_exactly(size, peek)
            if not isinstance(data, bytes):
                data = bytes(data)
            return data
        else:
            return self.read_integer(size * 8, peek).to_bytes(size, self.byteorder_name)

    def read_bit(self) -&gt; int:
        &#34;&#34;&#34;
        This function is a shortcut for calling `refinery.lib.structures.StructReader.read_integer` with
        an argument of `1`, i.e. this reads the next bit from the stream. The bits of any byte in the stream
        are read from least significant to most significant.
        &#34;&#34;&#34;
        return self.read_integer(1)

    def read_bits(self, nbits: int) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        This method returns the bits of `refinery.lib.structures.StructReader.read_integer` as an iterable
        from least to most significant.
        &#34;&#34;&#34;
        chunk = self.read_integer(nbits)
        for k in range(nbits - 1, -1, -1):
            yield chunk &gt;&gt; k &amp; 1

    def read_flags(self, nbits: int, reverse=False) -&gt; Iterable[bool]:
        &#34;&#34;&#34;
        Identical to `refinery.lib.structures.StructReader.read_bits` with every bit value cast to a boolean.
        &#34;&#34;&#34;
        bits = list(self.read_bits(nbits))
        if reverse:
            bits.reverse()
        for bit in bits:
            yield bool(bit)

    def read_struct(self, spec: str, unwrap=False, peek=False) -&gt; Union[List[UnpackType], UnpackType]:
        &#34;&#34;&#34;
        Read structured data from the stream in any format supported by the `struct` module. The `format`
        argument can be used to override the current byte ordering. If the `unwrap` parameter is `True`, a
        single unpacked value will be returned as a scalar, not as a tuple with one element.
        &#34;&#34;&#34;
        if not spec:
            raise ValueError(&#39;no format specified&#39;)
        byteorder = spec[:1]
        if byteorder in &#39;&lt;!=@&gt;&#39;:
            spec = spec[1:]
        else:
            byteorder = self.byteorder_format
        data = []
        current_cursor = self.tell()

        # reserved struct characters: xcbB?hHiIlLqQnNefdspP
        for k, part in enumerate(re.split(&#39;(\\d*[auwgE])&#39;, spec)):
            if k % 2 == 1:
                count = 1 if len(part) == 1 else int(part[:~0])
                part = part[~0]
                for _ in range(count):
                    if part == &#39;a&#39;:
                        data.append(self.read_c_string())
                    elif part == &#39;g&#39;:
                        data.append(self.read_guid())
                    elif part == &#39;u&#39;:
                        data.append(self.read_w_string())
                    elif part == &#39;w&#39;:
                        data.append(codecs.decode(self.read_w_string(), &#39;utf-16le&#39;))
                    elif part == &#39;E&#39;:
                        data.append(self.read_7bit_encoded_int())
                continue
            else:
                part = F&#39;{byteorder}{part}&#39;
                data.extend(struct.unpack(part, self.read_bytes(struct.calcsize(part))))
        if unwrap and len(data) == 1:
            return data[0]
        if peek:
            self.seekset(current_cursor)
        return data

    def read_nibble(self, peek: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Calls `refinery.lib.structures.StructReader.read_integer` with an argument of `4`.
        &#34;&#34;&#34;
        return self.read_integer(4, peek)

    def u8(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)
    def i8(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)

    def u16(self, peek: bool = False) -&gt; int: return self.read_integer(16, peek)
    def u32(self, peek: bool = False) -&gt; int: return self.read_integer(32, peek)
    def u64(self, peek: bool = False) -&gt; int: return self.read_integer(64, peek)
    def i16(self, peek: bool = False) -&gt; int: return signed(self.read_integer(16, peek), 16)
    def i32(self, peek: bool = False) -&gt; int: return signed(self.read_integer(32, peek), 32)
    def i64(self, peek: bool = False) -&gt; int: return signed(self.read_integer(64, peek), 64)

    def f32(self, peek: bool = False) -&gt; float: return self.read_struct(&#39;f&#39;, unwrap=True, peek=peek)
    def f64(self, peek: bool = False) -&gt; float: return self.read_struct(&#39;d&#39;, unwrap=True, peek=peek)

    def read_byte(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)
    def read_char(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)

    def read_terminated_array(self, terminator: bytes, alignment: int = 1) -&gt; bytearray:
        pos = self.tell()
        buf = self.getbuffer()
        try:
            end = pos - 1
            while True:
                end = buf.find(terminator, end + 1)
                if end &lt; 0 or not (end - pos) % alignment:
                    break
        except AttributeError:
            result = bytearray()
            while not self.eof:
                result.extend(self.read_bytes(alignment))
                if result.endswith(terminator):
                    return result[:-len(terminator)]
            self.seek(pos)
            raise EOF
        else:
            data = self.read_exactly(end - pos)
            self.seekrel(len(terminator))
            return bytearray(data)

    def read_guid(self) -&gt; str:
        _mode = self.bigendian
        self.bigendian = False
        try:
            a = self.u32()
            b = self.u16()
            c = self.u16()
            d = self.read(2).hex().upper()
            e = self.read(6).hex().upper()
        except Exception:
            raise
        else:
            return F&#39;{a:08X}-{b:04X}-{c:04X}-{d}-{e}&#39;
        finally:
            self.bigendian = _mode

    @overload
    def read_c_string(self) -&gt; bytearray:
        ...

    @overload
    def read_c_string(self, encoding: str) -&gt; str:
        ...

    def read_c_string(self, encoding=None) -&gt; Union[str, bytearray]:
        data = self.read_terminated_array(B&#39;\0&#39;)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    @overload
    def read_w_string(self) -&gt; bytearray:
        ...

    @overload
    def read_w_string(self, encoding: str) -&gt; str:
        ...

    def read_w_string(self, encoding=None) -&gt; Union[str, bytearray]:
        data = self.read_terminated_array(B&#39;\0\0&#39;, 2)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_length_prefixed_ascii(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;latin1&#39;)

    def read_length_prefixed_utf8(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;utf8&#39;)

    def read_length_prefixed_utf16(self, prefix_size: int = 32, bytecount: bool = False):
        block_size = 1 if bytecount else 2
        return self.read_length_prefixed(prefix_size, &#39;utf-16le&#39;, block_size)

    @overload
    def read_length_prefixed(self, prefix_size: int = 32, block_size: int = 1) -&gt; T:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, encoding: str, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, *, encoding: str, prefix_size: int = 32, block_size: int = 1) -&gt; str:
        ...

    def read_length_prefixed(self, prefix_size: int = 32, encoding: Optional[str] = None, block_size: int = 1) -&gt; Union[T, str]:
        prefix = self.read_integer(prefix_size) * block_size
        data = self.read(prefix)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_7bit_encoded_int(self, max_bits: int = 0) -&gt; int:
        value = 0
        for shift in itertools.count(0, step=7):
            b = self.read_byte()
            value |= (b &amp; 0x7F) &lt;&lt; shift
            if not b &amp; 0x80:
                return value
            if shift &gt; max_bits &gt; 0:
                raise RuntimeError(&#39;Maximum bits were exceeded by encoded integer.&#39;)


class StructMeta(type):
    &#34;&#34;&#34;
    A metaclass to facilitate the behavior outlined for `refinery.lib.structures.Struct`.
    &#34;&#34;&#34;
    def __new__(mcls, name, bases, nmspc, parser=StructReader):
        return type.__new__(mcls, name, bases, nmspc)

    def __init__(cls, name, bases, nmspc, parser=StructReader):
        super(StructMeta, cls).__init__(name, bases, nmspc)
        original__init__ = cls.__init__

        @functools.wraps(original__init__)
        def wrapped__init__(self: Struct, reader, *args, **kwargs):
            if not isinstance(reader, parser):
                if issubclass(parser, reader.__class__):
                    raise ValueError(
                        F&#39;A reader of type {reader.__class__.__name__} was passed to {cls.__name__}, &#39;
                        F&#39;but a {parser.__name__} is required.&#39;)
                reader = parser(reader)
            start = reader.tell()
            view = memoryview(reader.getbuffer())
            original__init__(self, reader, *args, **kwargs)
            self._data = view[start:reader.tell()]

        cls.__init__ = wrapped__init__


class Struct(metaclass=StructMeta):
    &#34;&#34;&#34;
    A class to parse structured data. A `refinery.lib.structures.Struct` class can be instantiated
    as follows:

        foo = Struct(data, bar=29)

    The initialization routine of the structure will be called with a single argument `reader`. If
    the object `data` is already a `refinery.lib.structures.StructReader`, then it will be passed
    as `reader`. Otherwise, the argument will be wrapped in a `refinery.lib.structures.StructReader`.
    Additional arguments to the struct are passed through.
    &#34;&#34;&#34;
    _data: Union[memoryview, bytearray]

    def __len__(self):
        return len(self._data)

    def __bytes__(self):
        return bytes(self._data)

    def get_data(self, decouple=False):
        if decouple and isinstance(self._data, memoryview):
            self._data = bytearray(self._data)
        return self._data

    def __init__(self, reader: StructReader, *args, **kwargs):
        pass


AttrType = TypeVar(&#39;AttrType&#39;)


class PerInstanceAttribute(Generic[AttrType]):
    def resolve(self, parent, value: Any) -&gt; AttrType:
        return value

    def __init__(self):
        self.__set: Dict[int, Any] = {}
        self.__get: Dict[int, AttrType] = {}

    def __set__(self, parent: Any, value: Any) -&gt; None:
        pid = id(parent)
        if pid not in self.__set:
            def cleanup(self, pid):
                self.__set.pop(pid, None)
                self.__get.pop(pid, None)
            self.__set[pid] = value
            weakref.finalize(parent, cleanup, self, id(parent))

    def __get__(self, parent, tp=None) -&gt; AttrType:
        pid = id(parent)
        if pid not in self.__get:
            try:
                seed = self.__set[pid]
            except KeyError as K:
                raise AttributeError from K
            self.__get[pid] = self.resolve(parent, seed)
        return self.__get[pid]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.structures.signed"><code class="name flex">
<span>def <span class="ident">signed</span></span>(<span>k, bitsize)</span>
</code></dt>
<dd>
<section class="desc"><p>If <code>k</code> is an integer of the given bit size, cast it to a signed one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L41-L47" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def signed(k: int, bitsize: int):
    &#34;&#34;&#34;
    If `k` is an integer of the given bit size, cast it to a signed one.
    &#34;&#34;&#34;
    M = 1 &lt;&lt; bitsize
    k = k &amp; (M - 1)
    return k - M if k &gt;&gt; (bitsize - 1) else k</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.structures.EOF"><code class="flex name class">
<span>class <span class="ident">EOF</span></span>
<span>(</span><span>rest=b'')</span>
</code></dt>
<dd>
<section class="desc"><p>While reading from a <code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code>, less bytes were available than
requested. The exception contains the data from the incomplete read.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L50-L60" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EOF(EOFError):
    &#34;&#34;&#34;
    While reading from a `refinery.lib.structures.MemoryFile`, less bytes were available than
    requested. The exception contains the data from the incomplete read.
    &#34;&#34;&#34;
    def __init__(self, rest: ByteString = B&#39;&#39;):
        super().__init__(&#39;Unexpected end of buffer.&#39;)
        self.rest = rest

    def __bytes__(self):
        return bytes(self.rest)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.EOFError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.structures.StreamDetour"><code class="flex name class">
<span>class <span class="ident">StreamDetour</span></span>
<span>(</span><span>stream, offset=None, whence=0)</span>
</code></dt>
<dd>
<section class="desc"><p>A stream detour is used as a context manager to temporarily read from a different location
in the stream and then return to the original offset when the context ends.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L63-L80" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StreamDetour(Generic[R]):
    &#34;&#34;&#34;
    A stream detour is used as a context manager to temporarily read from a different location
    in the stream and then return to the original offset when the context ends.
    &#34;&#34;&#34;
    def __init__(self, stream: R, offset: Optional[int] = None, whence: int = io.SEEK_SET):
        self.stream = stream
        self.offset = offset
        self.whence = whence

    def __enter__(self):
        self.cursor = self.stream.tell()
        if self.offset is not None:
            self.stream.seek(self.offset, self.whence)
        return self

    def __exit__(self, *args):
        self.stream.seek(self.cursor, io.SEEK_SET)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods"><code class="flex name class">
<span>class <span class="ident">MemoryFileMethods</span></span>
<span>(</span><span>data=None, read_as_bytes=False, fileno=None, size_limit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
file-like object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L83-L364" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MemoryFileMethods(Generic[T]):
    &#34;&#34;&#34;
    A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
    file-like object.
    &#34;&#34;&#34;
    closed: bool
    read_as_bytes: bool

    _data: T
    _cursor: int
    _closed: bool

    class SEEK(int, enum.Enum):
        CUR = io.SEEK_CUR
        END = io.SEEK_END
        SET = io.SEEK_SET

    def __init__(
        self,
        data: Optional[T] = None,
        read_as_bytes=False,
        fileno: Optional[int] = None,
        size_limit: Optional[int] = None,
    ) -&gt; None:
        if data is None:
            data = bytearray()
        elif size_limit is not None and len(data) &gt; size_limit:
            raise ValueError(&#39;Initial data exceeds size limit&#39;)
        self._data = data
        self._cursor = 0
        self._closed = False
        self._fileno = fileno
        self.read_as_bytes = read_as_bytes
        self._size_limit = size_limit

    def close(self) -&gt; None:
        self._closed = True

    @property
    def closed(self) -&gt; bool:
        return self._closed

    def __enter__(self) -&gt; MemoryFile:
        return self

    def __exit__(self, ex_type, ex_value, trace) -&gt; bool:
        return False

    def flush(self) -&gt; None:
        pass

    def isatty(self) -&gt; bool:
        return False

    def __iter__(self):
        return self

    def __len__(self):
        return len(self._data)

    def __next__(self):
        line = self.readline()
        if not line:
            raise StopIteration
        return line

    def fileno(self) -&gt; int:
        if self._fileno is None:
            raise OSError
        return self._fileno

    def readable(self) -&gt; bool:
        return not self._closed

    def seekable(self) -&gt; bool:
        return not self._closed

    @property
    def eof(self) -&gt; bool:
        return self._closed or self._cursor &gt;= len(self._data)

    @property
    def remaining_bytes(self) -&gt; int:
        return len(self._data) - self.tell()

    def detour(self, offset: Optional[int] = None, whence: int = io.SEEK_SET):
        return StreamDetour(self, offset, whence=whence)

    def writable(self) -&gt; bool:
        if self._closed:
            return False
        if isinstance(self._data, memoryview):
            return not self._data.readonly
        return isinstance(self._data, bytearray)

    def read_as(self, cast: Type[C], size: int = -1, peek: bool = False) -&gt; C:
        out = self.read(size, peek)
        if not isinstance(out, cast):
            out = cast(out)
        return out

    def read(self, size: int = -1, peek: bool = False) -&gt; T:
        beginning = self._cursor
        if size is None or size &lt; 0:
            end = len(self._data)
        else:
            end = min(self._cursor + size, len(self._data))
        result = self._data[beginning:end]
        if self.read_as_bytes and not isinstance(result, bytes):
            result = bytes(result)
        if not peek:
            self._cursor = end
        return result

    def peek(self, size: int = -1) -&gt; memoryview:
        cursor = self._cursor
        mv = memoryview(self._data)
        if size is None or size &lt; 0:
            return mv[cursor:]
        return mv[cursor:cursor + size]

    def read1(self, size: int = -1, peek: bool = False) -&gt; T:
        return self.read(size, peek)

    def _find_linebreak(self, beginning: int, end: int) -&gt; int:
        if not isinstance(self._data, memoryview):
            return self._data.find(B&#39;\n&#39;, beginning, end)
        for k in range(beginning, end):
            if self._data[k] == 0xA: return k
        return -1

    def readline(self, size: int = -1) -&gt; T:
        beginning, end = self._cursor, len(self._data)
        if size is not None and size &gt;= 0:
            end = beginning + size
        p = self._find_linebreak(beginning, end)
        self._cursor = end if p &lt; 0 else p + 1
        result = self._data[beginning:self._cursor]
        if self.read_as_bytes and not isinstance(result, bytes):
            result = bytes(result)
        return result

    def readlines(self, hint: int = -1) -&gt; Iterable[T]:
        if hint is None or hint &lt; 0:
            yield from self
        else:
            total = 0
            while total &lt; hint:
                line = next(self)
                total += len(line)
                yield line

    def readinto1(self, b) -&gt; int:
        data = self.read(len(b))
        size = len(data)
        b[:size] = data
        return size

    def readinto(self, b) -&gt; int:
        return self.readinto1(b)

    def tell(self) -&gt; int:
        return self._cursor

    def seekrel(self, offset: int) -&gt; int:
        return self.seek(offset, io.SEEK_CUR)

    def seekset(self, offset: int) -&gt; int:
        if offset &lt; 0:
            return self.seek(offset, io.SEEK_END)
        else:
            return self.seek(offset, io.SEEK_SET)

    def getbuffer(self) -&gt; T:
        return self._data

    def getvalue(self) -&gt; T:
        return self._data

    def seek(self, offset: int, whence=io.SEEK_SET) -&gt; int:
        if whence == io.SEEK_SET:
            if offset &lt; 0:
                raise ValueError(&#39;no negative offsets allowed for SEEK_SET.&#39;)
            self._cursor = offset
        elif whence == io.SEEK_CUR:
            self._cursor += offset
        elif whence == io.SEEK_END:
            self._cursor = len(self._data) + offset
        self._cursor = max(self._cursor, 0)
        self._cursor = min(self._cursor, len(self._data))
        return self._cursor

    def writelines(self, lines: Iterable[ByteString]) -&gt; None:
        for line in lines:
            self.write(line)

    def truncate(self, size=None) -&gt; None:
        if size is not None:
            if not (0 &lt;= size &lt;= len(self._data)):
                raise ValueError(&#39;invalid size value&#39;)
            self._cursor = size
        del self._data[self._cursor:]

    def write_byte(self, byte: int) -&gt; None:
        limit = self._size_limit
        cc = self._cursor
        nc = cc + 1
        if limit and nc &gt; limit:
            raise EOF(bytes((byte,)))
        try:
            if cc &lt; len(self._data):
                self._data[cc] = byte
            else:
                self._data.append(byte)
        except Exception as T:
            raise OSError(str(T)) from T
        else:
            self._cursor = nc

    def write(self, data: Iterable[int]) -&gt; int:
        out = self._data
        end = len(out)
        beginning = self._cursor
        limit = self._size_limit

        if limit is None and beginning == end:
            out[end:] = data
            self._cursor = end = len(out)
            return end - beginning
        try:
            size = len(data)
        except Exception:
            it = iter(data)
            for cursor, b in enumerate(it, beginning):
                out[cursor] = b
                if cursor &gt;= end - 1:
                    break
            else:
                cursor += 1
                self._cursor = cursor
                return cursor - beginning
            if limit is None:
                out[end:] = it
            else:
                out[end:limit] = itertools.islice(it, 0, limit - end)
                try:
                    b = next(it)
                except StopIteration:
                    self._cursor = limit
                    return limit - beginning
                else:
                    rest = bytearray((b,))
                    rest[1:] = it
                    raise EOF(rest)
        else:
            if limit and size + beginning &gt; limit:
                raise EOF(data)
            self._cursor += size
            try:
                self._data[beginning:self._cursor] = data
            except Exception as T:
                self._cursor = beginning
                raise OSError(str(T)) from T
            return size
        self._cursor = end = len(out)
        return end - beginning

    def __getitem__(self, slice):
        result = self._data[slice]
        if self.read_as_bytes and not isinstance(result, bytes):
            result = bytes(result)
        return result

    def replay(self, offset: int, length: int):
        if offset not in range(self._cursor + 1):
            raise ValueError(F&#39;The supplied delta {offset} is not in the valid range [0,{self._cursor}].&#39;)
        rep, r = divmod(length, offset)
        offset = -offset - len(self) + self._cursor
        replay = self._data[offset:offset + r]
        if rep &gt; 0:
            replay = bytes(self._data[offset:self._cursor]) * rep + replay
        self.write(replay)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFileMethods.read_as_bytes"><code class="name">var <span class="ident">read_as_bytes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.SEEK"><code class="name">var <span class="ident">SEEK</span></code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFileMethods.closed"><code class="name">var <span class="ident">closed</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L121-L123" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def closed(self) -&gt; bool:
    return self._closed</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.eof"><code class="name">var <span class="ident">eof</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L160-L162" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eof(self) -&gt; bool:
    return self._closed or self._cursor &gt;= len(self._data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.remaining_bytes"><code class="name">var <span class="ident">remaining_bytes</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L164-L166" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def remaining_bytes(self) -&gt; int:
    return len(self._data) - self.tell()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFileMethods.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L118-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    self._closed = True</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L131-L132" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flush(self) -&gt; None:
    pass</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.isatty"><code class="name flex">
<span>def <span class="ident">isatty</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L134-L135" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isatty(self) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.fileno"><code class="name flex">
<span>def <span class="ident">fileno</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L149-L152" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fileno(self) -&gt; int:
    if self._fileno is None:
        raise OSError
    return self._fileno</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readable"><code class="name flex">
<span>def <span class="ident">readable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L154-L155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readable(self) -&gt; bool:
    return not self._closed</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seekable"><code class="name flex">
<span>def <span class="ident">seekable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L157-L158" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seekable(self) -&gt; bool:
    return not self._closed</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.detour"><code class="name flex">
<span>def <span class="ident">detour</span></span>(<span>self, offset=None, whence=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L168-L169" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detour(self, offset: Optional[int] = None, whence: int = io.SEEK_SET):
    return StreamDetour(self, offset, whence=whence)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.writable"><code class="name flex">
<span>def <span class="ident">writable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L171-L176" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writable(self) -&gt; bool:
    if self._closed:
        return False
    if isinstance(self._data, memoryview):
        return not self._data.readonly
    return isinstance(self._data, bytearray)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.read_as"><code class="name flex">
<span>def <span class="ident">read_as</span></span>(<span>self, cast, size=-1, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L178-L182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_as(self, cast: Type[C], size: int = -1, peek: bool = False) -&gt; C:
    out = self.read(size, peek)
    if not isinstance(out, cast):
        out = cast(out)
    return out</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size=-1, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L184-L195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self, size: int = -1, peek: bool = False) -&gt; T:
    beginning = self._cursor
    if size is None or size &lt; 0:
        end = len(self._data)
    else:
        end = min(self._cursor + size, len(self._data))
    result = self._data[beginning:end]
    if self.read_as_bytes and not isinstance(result, bytes):
        result = bytes(result)
    if not peek:
        self._cursor = end
    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self, size=-1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L197-L202" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def peek(self, size: int = -1) -&gt; memoryview:
    cursor = self._cursor
    mv = memoryview(self._data)
    if size is None or size &lt; 0:
        return mv[cursor:]
    return mv[cursor:cursor + size]</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.read1"><code class="name flex">
<span>def <span class="ident">read1</span></span>(<span>self, size=-1, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L204-L205" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read1(self, size: int = -1, peek: bool = False) -&gt; T:
    return self.read(size, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readline"><code class="name flex">
<span>def <span class="ident">readline</span></span>(<span>self, size=-1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L214-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readline(self, size: int = -1) -&gt; T:
    beginning, end = self._cursor, len(self._data)
    if size is not None and size &gt;= 0:
        end = beginning + size
    p = self._find_linebreak(beginning, end)
    self._cursor = end if p &lt; 0 else p + 1
    result = self._data[beginning:self._cursor]
    if self.read_as_bytes and not isinstance(result, bytes):
        result = bytes(result)
    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readlines"><code class="name flex">
<span>def <span class="ident">readlines</span></span>(<span>self, hint=-1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L225-L233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readlines(self, hint: int = -1) -&gt; Iterable[T]:
    if hint is None or hint &lt; 0:
        yield from self
    else:
        total = 0
        while total &lt; hint:
            line = next(self)
            total += len(line)
            yield line</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readinto1"><code class="name flex">
<span>def <span class="ident">readinto1</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L235-L239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readinto1(self, b) -&gt; int:
    data = self.read(len(b))
    size = len(data)
    b[:size] = data
    return size</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readinto"><code class="name flex">
<span>def <span class="ident">readinto</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L241-L242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readinto(self, b) -&gt; int:
    return self.readinto1(b)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.tell"><code class="name flex">
<span>def <span class="ident">tell</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L244-L245" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tell(self) -&gt; int:
    return self._cursor</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seekrel"><code class="name flex">
<span>def <span class="ident">seekrel</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L247-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seekrel(self, offset: int) -&gt; int:
    return self.seek(offset, io.SEEK_CUR)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seekset"><code class="name flex">
<span>def <span class="ident">seekset</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L250-L254" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seekset(self, offset: int) -&gt; int:
    if offset &lt; 0:
        return self.seek(offset, io.SEEK_END)
    else:
        return self.seek(offset, io.SEEK_SET)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.getbuffer"><code class="name flex">
<span>def <span class="ident">getbuffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L256-L257" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getbuffer(self) -&gt; T:
    return self._data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.getvalue"><code class="name flex">
<span>def <span class="ident">getvalue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L259-L260" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getvalue(self) -&gt; T:
    return self._data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seek"><code class="name flex">
<span>def <span class="ident">seek</span></span>(<span>self, offset, whence=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L262-L273" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seek(self, offset: int, whence=io.SEEK_SET) -&gt; int:
    if whence == io.SEEK_SET:
        if offset &lt; 0:
            raise ValueError(&#39;no negative offsets allowed for SEEK_SET.&#39;)
        self._cursor = offset
    elif whence == io.SEEK_CUR:
        self._cursor += offset
    elif whence == io.SEEK_END:
        self._cursor = len(self._data) + offset
    self._cursor = max(self._cursor, 0)
    self._cursor = min(self._cursor, len(self._data))
    return self._cursor</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.writelines"><code class="name flex">
<span>def <span class="ident">writelines</span></span>(<span>self, lines)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L275-L277" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writelines(self, lines: Iterable[ByteString]) -&gt; None:
    for line in lines:
        self.write(line)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L279-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def truncate(self, size=None) -&gt; None:
    if size is not None:
        if not (0 &lt;= size &lt;= len(self._data)):
            raise ValueError(&#39;invalid size value&#39;)
        self._cursor = size
    del self._data[self._cursor:]</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.write_byte"><code class="name flex">
<span>def <span class="ident">write_byte</span></span>(<span>self, byte)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L286-L300" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write_byte(self, byte: int) -&gt; None:
    limit = self._size_limit
    cc = self._cursor
    nc = cc + 1
    if limit and nc &gt; limit:
        raise EOF(bytes((byte,)))
    try:
        if cc &lt; len(self._data):
            self._data[cc] = byte
        else:
            self._data.append(byte)
    except Exception as T:
        raise OSError(str(T)) from T
    else:
        self._cursor = nc</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L302-L348" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write(self, data: Iterable[int]) -&gt; int:
    out = self._data
    end = len(out)
    beginning = self._cursor
    limit = self._size_limit

    if limit is None and beginning == end:
        out[end:] = data
        self._cursor = end = len(out)
        return end - beginning
    try:
        size = len(data)
    except Exception:
        it = iter(data)
        for cursor, b in enumerate(it, beginning):
            out[cursor] = b
            if cursor &gt;= end - 1:
                break
        else:
            cursor += 1
            self._cursor = cursor
            return cursor - beginning
        if limit is None:
            out[end:] = it
        else:
            out[end:limit] = itertools.islice(it, 0, limit - end)
            try:
                b = next(it)
            except StopIteration:
                self._cursor = limit
                return limit - beginning
            else:
                rest = bytearray((b,))
                rest[1:] = it
                raise EOF(rest)
    else:
        if limit and size + beginning &gt; limit:
            raise EOF(data)
        self._cursor += size
        try:
            self._data[beginning:self._cursor] = data
        except Exception as T:
            self._cursor = beginning
            raise OSError(str(T)) from T
        return size
    self._cursor = end = len(out)
    return end - beginning</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.replay"><code class="name flex">
<span>def <span class="ident">replay</span></span>(<span>self, offset, length)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L356-L364" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def replay(self, offset: int, length: int):
    if offset not in range(self._cursor + 1):
        raise ValueError(F&#39;The supplied delta {offset} is not in the valid range [0,{self._cursor}].&#39;)
    rep, r = divmod(length, offset)
    offset = -offset - len(self) + self._cursor
    replay = self._data[offset:offset + r]
    if rep &gt; 0:
        replay = bytes(self._data[offset:self._cursor]) * rep + replay
    self.write(replay)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.structures.MemoryFile"><code class="flex name class">
<span>class <span class="ident">MemoryFile</span></span>
<span>(</span><span>data=None, read_as_bytes=False, fileno=None, size_limit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
file-like object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L367-L368" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MemoryFile(MemoryFileMethods[T], io.BytesIO):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></li>
<li>typing.Generic</li>
<li>_io.BytesIO</li>
<li>_io._BufferedIOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></li>
<li><a title="refinery.units.formats.httpresponse.SockWrapper" href="../units/formats/httpresponse.html#refinery.units.formats.httpresponse.SockWrapper">SockWrapper</a></li>
<li><a title="refinery.units.pattern.carve_7z.MemoryFileRecorder" href="../units/pattern/carve_7z.html#refinery.units.pattern.carve_7z.MemoryFileRecorder">MemoryFileRecorder</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFile.read_as_bytes"><code class="name">var <span class="ident">read_as_bytes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFile.closed"><code class="name">var <span class="ident">closed</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L121-L123" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def closed(self) -&gt; bool:
    return self._closed</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.structures.MemoryFileMethods.SEEK" href="#refinery.lib.structures.MemoryFileMethods.SEEK">SEEK</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.structures.order"><code class="flex name class">
<span>class <span class="ident">order</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L371-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class order(str, enum.Enum):
    big = &#39;&gt;&#39;
    little = &#39;&lt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.structures.order.big"><code class="name">var <span class="ident">big</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.structures.order.little"><code class="name">var <span class="ident">little</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.structures.StructReader"><code class="flex name class">
<span>class <span class="ident">StructReader</span></span>
<span>(</span><span>data, bigendian=False)</span>
</code></dt>
<dd>
<section class="desc"><p>An extension of a <code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code> which provides methods to read
structured data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L376-L719" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StructReader(MemoryFile[T]):
    &#34;&#34;&#34;
    An extension of a `refinery.lib.structures.MemoryFile` which provides methods to read
    structured data.
    &#34;&#34;&#34;

    class Unaligned(RuntimeError):
        pass

    def __init__(self, data: T, bigendian: bool = False):
        super().__init__(data)
        self._bbits = 0
        self._nbits = 0
        self.bigendian = bigendian

    def __enter__(self) -&gt; StructReader:
        return super().__enter__()

    @property
    @contextlib.contextmanager
    def be(self):
        self.bigendian = True
        try:
            yield self
        finally:
            self.bigendian = False

    @property
    def byteorder_format(self) -&gt; str:
        return &#39;&gt;&#39; if self.bigendian else &#39;&lt;&#39;

    @property
    def byteorder_name(self) -&gt; str:
        return &#39;big&#39; if self.bigendian else &#39;little&#39;

    def seek(self, offset, whence=io.SEEK_SET) -&gt; int:
        self._bbits = 0
        self._nbits = 0
        return super().seek(offset, whence)

    def read_exactly(self, size: Optional[int] = None, peek: bool = False) -&gt; T:
        &#34;&#34;&#34;
        Read bytes from the underlying stream. Raises a `RuntimeError` when the stream is not currently
        byte-aligned, i.e. when `refinery.lib.structures.StructReader.byte_aligned` is `False`. Raises
        an exception of type `refinery.lib.structures.EOF` when fewer data is available in the stream than
        requested via the `size` parameter. The remaining data can be extracted from the exception.
        Use `refinery.lib.structures.StructReader.read_bytes` to read bytes from the stream when it is
        not byte-aligned.
        &#34;&#34;&#34;
        if not self.byte_aligned:
            raise StructReader.Unaligned(&#39;buffer is not byte-aligned&#39;)
        data = self.read1(size, peek)
        if size and len(data) &lt; size:
            raise EOF(data)
        return data

    @property
    def byte_aligned(self) -&gt; bool:
        &#34;&#34;&#34;
        This property is `True` if and only if there are currently no bits still waiting in the internal
        bit buffer.
        &#34;&#34;&#34;
        return not self._nbits

    def byte_align(self, blocksize: int = 1) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
        tuple containing the size and contents of the bit buffer.
        &#34;&#34;&#34;
        nbits = self._nbits
        bbits = self._bbits
        self._nbits = 0
        self._bbits = 0
        mod = self._cursor % blocksize
        if mod:
            self.seekrel(blocksize - mod)
        return nbits, bbits

    @property
    def remaining_bits(self) -&gt; int:
        return 8 * self.remaining_bytes + self._nbits

    def read_integer(self, length: Optional[int] = None, peek: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Read `length` many bits from the underlying stream as an integer.
        &#34;&#34;&#34;
        if length is None:
            length = self.remaining_bits
        if length &lt; 0:
            raise ValueError
        if length &lt; self._nbits:
            new_count = self._nbits - length
            if self.bigendian:
                result = self._bbits &gt;&gt; new_count
                if not peek:
                    self._bbits ^= result &lt;&lt; new_count
            else:
                result = self._bbits &amp; 2 ** length - 1
                if not peek:
                    self._bbits &gt;&gt;= length
            if not peek:
                self._nbits = new_count
            return result

        nbits, bbits = self._nbits, self._bbits
        number_of_missing_bits = length - nbits
        bytecount, rest = divmod(number_of_missing_bits, 8)
        if rest:
            bytecount += 1
            rest = 8 - rest
        bb = self.read1(bytecount, True)
        if len(bb) != bytecount:
            raise EOFError
        if not peek:
            self.seekrel(bytecount)
        if bytecount == 1:
            result, = bb
        else:
            result = int.from_bytes(bb, self.byteorder_name)
        if not nbits and not rest:
            return result
        if self.bigendian:
            rbmask   = 2 ** rest - 1       # noqa
            excess   = result &amp; rbmask     # noqa
            result &gt;&gt;= rest                # noqa
            result  ^= bbits &lt;&lt; number_of_missing_bits   # noqa
        else:
            excess   = result &gt;&gt; number_of_missing_bits  # noqa
            result  ^= excess &lt;&lt; number_of_missing_bits  # noqa
            result &lt;&lt;= nbits               # noqa
            result  |= bbits               # noqa
        assert excess.bit_length() &lt;= rest
        if not peek:
            self._nbits = rest
            self._bbits = excess
        return result

    def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        The method reads `size` many bytes from the underlying stream starting at the current bit.
        &#34;&#34;&#34;
        if self.byte_aligned:
            data = self.read_exactly(size, peek)
            if not isinstance(data, bytes):
                data = bytes(data)
            return data
        else:
            return self.read_integer(size * 8, peek).to_bytes(size, self.byteorder_name)

    def read_bit(self) -&gt; int:
        &#34;&#34;&#34;
        This function is a shortcut for calling `refinery.lib.structures.StructReader.read_integer` with
        an argument of `1`, i.e. this reads the next bit from the stream. The bits of any byte in the stream
        are read from least significant to most significant.
        &#34;&#34;&#34;
        return self.read_integer(1)

    def read_bits(self, nbits: int) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        This method returns the bits of `refinery.lib.structures.StructReader.read_integer` as an iterable
        from least to most significant.
        &#34;&#34;&#34;
        chunk = self.read_integer(nbits)
        for k in range(nbits - 1, -1, -1):
            yield chunk &gt;&gt; k &amp; 1

    def read_flags(self, nbits: int, reverse=False) -&gt; Iterable[bool]:
        &#34;&#34;&#34;
        Identical to `refinery.lib.structures.StructReader.read_bits` with every bit value cast to a boolean.
        &#34;&#34;&#34;
        bits = list(self.read_bits(nbits))
        if reverse:
            bits.reverse()
        for bit in bits:
            yield bool(bit)

    def read_struct(self, spec: str, unwrap=False, peek=False) -&gt; Union[List[UnpackType], UnpackType]:
        &#34;&#34;&#34;
        Read structured data from the stream in any format supported by the `struct` module. The `format`
        argument can be used to override the current byte ordering. If the `unwrap` parameter is `True`, a
        single unpacked value will be returned as a scalar, not as a tuple with one element.
        &#34;&#34;&#34;
        if not spec:
            raise ValueError(&#39;no format specified&#39;)
        byteorder = spec[:1]
        if byteorder in &#39;&lt;!=@&gt;&#39;:
            spec = spec[1:]
        else:
            byteorder = self.byteorder_format
        data = []
        current_cursor = self.tell()

        # reserved struct characters: xcbB?hHiIlLqQnNefdspP
        for k, part in enumerate(re.split(&#39;(\\d*[auwgE])&#39;, spec)):
            if k % 2 == 1:
                count = 1 if len(part) == 1 else int(part[:~0])
                part = part[~0]
                for _ in range(count):
                    if part == &#39;a&#39;:
                        data.append(self.read_c_string())
                    elif part == &#39;g&#39;:
                        data.append(self.read_guid())
                    elif part == &#39;u&#39;:
                        data.append(self.read_w_string())
                    elif part == &#39;w&#39;:
                        data.append(codecs.decode(self.read_w_string(), &#39;utf-16le&#39;))
                    elif part == &#39;E&#39;:
                        data.append(self.read_7bit_encoded_int())
                continue
            else:
                part = F&#39;{byteorder}{part}&#39;
                data.extend(struct.unpack(part, self.read_bytes(struct.calcsize(part))))
        if unwrap and len(data) == 1:
            return data[0]
        if peek:
            self.seekset(current_cursor)
        return data

    def read_nibble(self, peek: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Calls `refinery.lib.structures.StructReader.read_integer` with an argument of `4`.
        &#34;&#34;&#34;
        return self.read_integer(4, peek)

    def u8(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)
    def i8(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)

    def u16(self, peek: bool = False) -&gt; int: return self.read_integer(16, peek)
    def u32(self, peek: bool = False) -&gt; int: return self.read_integer(32, peek)
    def u64(self, peek: bool = False) -&gt; int: return self.read_integer(64, peek)
    def i16(self, peek: bool = False) -&gt; int: return signed(self.read_integer(16, peek), 16)
    def i32(self, peek: bool = False) -&gt; int: return signed(self.read_integer(32, peek), 32)
    def i64(self, peek: bool = False) -&gt; int: return signed(self.read_integer(64, peek), 64)

    def f32(self, peek: bool = False) -&gt; float: return self.read_struct(&#39;f&#39;, unwrap=True, peek=peek)
    def f64(self, peek: bool = False) -&gt; float: return self.read_struct(&#39;d&#39;, unwrap=True, peek=peek)

    def read_byte(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)
    def read_char(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)

    def read_terminated_array(self, terminator: bytes, alignment: int = 1) -&gt; bytearray:
        pos = self.tell()
        buf = self.getbuffer()
        try:
            end = pos - 1
            while True:
                end = buf.find(terminator, end + 1)
                if end &lt; 0 or not (end - pos) % alignment:
                    break
        except AttributeError:
            result = bytearray()
            while not self.eof:
                result.extend(self.read_bytes(alignment))
                if result.endswith(terminator):
                    return result[:-len(terminator)]
            self.seek(pos)
            raise EOF
        else:
            data = self.read_exactly(end - pos)
            self.seekrel(len(terminator))
            return bytearray(data)

    def read_guid(self) -&gt; str:
        _mode = self.bigendian
        self.bigendian = False
        try:
            a = self.u32()
            b = self.u16()
            c = self.u16()
            d = self.read(2).hex().upper()
            e = self.read(6).hex().upper()
        except Exception:
            raise
        else:
            return F&#39;{a:08X}-{b:04X}-{c:04X}-{d}-{e}&#39;
        finally:
            self.bigendian = _mode

    @overload
    def read_c_string(self) -&gt; bytearray:
        ...

    @overload
    def read_c_string(self, encoding: str) -&gt; str:
        ...

    def read_c_string(self, encoding=None) -&gt; Union[str, bytearray]:
        data = self.read_terminated_array(B&#39;\0&#39;)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    @overload
    def read_w_string(self) -&gt; bytearray:
        ...

    @overload
    def read_w_string(self, encoding: str) -&gt; str:
        ...

    def read_w_string(self, encoding=None) -&gt; Union[str, bytearray]:
        data = self.read_terminated_array(B&#39;\0\0&#39;, 2)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_length_prefixed_ascii(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;latin1&#39;)

    def read_length_prefixed_utf8(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;utf8&#39;)

    def read_length_prefixed_utf16(self, prefix_size: int = 32, bytecount: bool = False):
        block_size = 1 if bytecount else 2
        return self.read_length_prefixed(prefix_size, &#39;utf-16le&#39;, block_size)

    @overload
    def read_length_prefixed(self, prefix_size: int = 32, block_size: int = 1) -&gt; T:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, encoding: str, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, *, encoding: str, prefix_size: int = 32, block_size: int = 1) -&gt; str:
        ...

    def read_length_prefixed(self, prefix_size: int = 32, encoding: Optional[str] = None, block_size: int = 1) -&gt; Union[T, str]:
        prefix = self.read_integer(prefix_size) * block_size
        data = self.read(prefix)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_7bit_encoded_int(self, max_bits: int = 0) -&gt; int:
        value = 0
        for shift in itertools.count(0, step=7):
            b = self.read_byte()
            value |= (b &amp; 0x7F) &lt;&lt; shift
            if not b &amp; 0x80:
                return value
            if shift &gt; max_bits &gt; 0:
                raise RuntimeError(&#39;Maximum bits were exceeded by encoded integer.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></li>
<li><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></li>
<li>typing.Generic</li>
<li>_io.BytesIO</li>
<li>_io._BufferedIOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.compression.lz4.LZ4Reader" href="../units/compression/lz4.html#refinery.units.compression.lz4.LZ4Reader">LZ4Reader</a></li>
<li><a title="refinery.units.formats.a3x.A3xReader" href="../units/formats/a3x.html#refinery.units.formats.a3x.A3xReader">A3xReader</a></li>
<li><a title="refinery.units.formats.archive.xtiss.ISSReader" href="../units/formats/archive/xtiss.html#refinery.units.formats.archive.xtiss.ISSReader">ISSReader</a></li>
<li><a title="refinery.units.formats.archive.xtnode.JSONReader" href="../units/formats/archive/xtnode.html#refinery.units.formats.archive.xtnode.JSONReader">JSONReader</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.structures.StructReader.read_as_bytes"><code class="name">var <span class="ident">read_as_bytes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.structures.StructReader.Unaligned"><code class="name">var <span class="ident">Unaligned</span></code></dt>
<dd>
<section class="desc"><p>Unspecified run-time error.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.structures.StructReader.closed"><code class="name">var <span class="ident">closed</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L121-L123" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def closed(self) -&gt; bool:
    return self._closed</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.be"><code class="name">var <span class="ident">be</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L394-L401" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
@contextlib.contextmanager
def be(self):
    self.bigendian = True
    try:
        yield self
    finally:
        self.bigendian = False</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byteorder_format"><code class="name">var <span class="ident">byteorder_format</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L403-L405" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def byteorder_format(self) -&gt; str:
    return &#39;&gt;&#39; if self.bigendian else &#39;&lt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byteorder_name"><code class="name">var <span class="ident">byteorder_name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L407-L409" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def byteorder_name(self) -&gt; str:
    return &#39;big&#39; if self.bigendian else &#39;little&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byte_aligned"><code class="name">var <span class="ident">byte_aligned</span></code></dt>
<dd>
<section class="desc"><p>This property is <code>True</code> if and only if there are currently no bits still waiting in the internal
bit buffer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L432-L438" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def byte_aligned(self) -&gt; bool:
    &#34;&#34;&#34;
    This property is `True` if and only if there are currently no bits still waiting in the internal
    bit buffer.
    &#34;&#34;&#34;
    return not self._nbits</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.remaining_bits"><code class="name">var <span class="ident">remaining_bits</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L454-L456" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def remaining_bits(self) -&gt; int:
    return 8 * self.remaining_bytes + self._nbits</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.StructReader.seek"><code class="name flex">
<span>def <span class="ident">seek</span></span>(<span>self, offset, whence=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Change stream position.</p>
<p>Seek to byte offset pos relative to position indicated by whence:
0
Start of stream (the default).
pos should be &gt;= 0;
1
Current position - pos may be negative;
2
End of stream - pos usually negative.
Returns the new absolute position.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L411-L414" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seek(self, offset, whence=io.SEEK_SET) -&gt; int:
    self._bbits = 0
    self._nbits = 0
    return super().seek(offset, whence)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_exactly"><code class="name flex">
<span>def <span class="ident">read_exactly</span></span>(<span>self, size=None, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read bytes from the underlying stream. Raises a <code>RuntimeError</code> when the stream is not currently
byte-aligned, i.e. when <code><a title="refinery.lib.structures.StructReader.byte_aligned" href="#refinery.lib.structures.StructReader.byte_aligned">StructReader.byte_aligned</a></code> is <code>False</code>. Raises
an exception of type <code><a title="refinery.lib.structures.EOF" href="#refinery.lib.structures.EOF">EOF</a></code> when fewer data is available in the stream than
requested via the <code>size</code> parameter. The remaining data can be extracted from the exception.
Use <code><a title="refinery.lib.structures.StructReader.read_bytes" href="#refinery.lib.structures.StructReader.read_bytes">StructReader.read_bytes()</a></code> to read bytes from the stream when it is
not byte-aligned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L416-L430" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_exactly(self, size: Optional[int] = None, peek: bool = False) -&gt; T:
    &#34;&#34;&#34;
    Read bytes from the underlying stream. Raises a `RuntimeError` when the stream is not currently
    byte-aligned, i.e. when `refinery.lib.structures.StructReader.byte_aligned` is `False`. Raises
    an exception of type `refinery.lib.structures.EOF` when fewer data is available in the stream than
    requested via the `size` parameter. The remaining data can be extracted from the exception.
    Use `refinery.lib.structures.StructReader.read_bytes` to read bytes from the stream when it is
    not byte-aligned.
    &#34;&#34;&#34;
    if not self.byte_aligned:
        raise StructReader.Unaligned(&#39;buffer is not byte-aligned&#39;)
    data = self.read1(size, peek)
    if size and len(data) &lt; size:
        raise EOF(data)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byte_align"><code class="name flex">
<span>def <span class="ident">byte_align</span></span>(<span>self, blocksize=1)</span>
</code></dt>
<dd>
<section class="desc"><p>This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
tuple containing the size and contents of the bit buffer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L440-L452" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def byte_align(self, blocksize: int = 1) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
    tuple containing the size and contents of the bit buffer.
    &#34;&#34;&#34;
    nbits = self._nbits
    bbits = self._bbits
    self._nbits = 0
    self._bbits = 0
    mod = self._cursor % blocksize
    if mod:
        self.seekrel(blocksize - mod)
    return nbits, bbits</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_integer"><code class="name flex">
<span>def <span class="ident">read_integer</span></span>(<span>self, length=None, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read <code>length</code> many bits from the underlying stream as an integer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L458-L511" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_integer(self, length: Optional[int] = None, peek: bool = False) -&gt; int:
    &#34;&#34;&#34;
    Read `length` many bits from the underlying stream as an integer.
    &#34;&#34;&#34;
    if length is None:
        length = self.remaining_bits
    if length &lt; 0:
        raise ValueError
    if length &lt; self._nbits:
        new_count = self._nbits - length
        if self.bigendian:
            result = self._bbits &gt;&gt; new_count
            if not peek:
                self._bbits ^= result &lt;&lt; new_count
        else:
            result = self._bbits &amp; 2 ** length - 1
            if not peek:
                self._bbits &gt;&gt;= length
        if not peek:
            self._nbits = new_count
        return result

    nbits, bbits = self._nbits, self._bbits
    number_of_missing_bits = length - nbits
    bytecount, rest = divmod(number_of_missing_bits, 8)
    if rest:
        bytecount += 1
        rest = 8 - rest
    bb = self.read1(bytecount, True)
    if len(bb) != bytecount:
        raise EOFError
    if not peek:
        self.seekrel(bytecount)
    if bytecount == 1:
        result, = bb
    else:
        result = int.from_bytes(bb, self.byteorder_name)
    if not nbits and not rest:
        return result
    if self.bigendian:
        rbmask   = 2 ** rest - 1       # noqa
        excess   = result &amp; rbmask     # noqa
        result &gt;&gt;= rest                # noqa
        result  ^= bbits &lt;&lt; number_of_missing_bits   # noqa
    else:
        excess   = result &gt;&gt; number_of_missing_bits  # noqa
        result  ^= excess &lt;&lt; number_of_missing_bits  # noqa
        result &lt;&lt;= nbits               # noqa
        result  |= bbits               # noqa
    assert excess.bit_length() &lt;= rest
    if not peek:
        self._nbits = rest
        self._bbits = excess
    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_bytes"><code class="name flex">
<span>def <span class="ident">read_bytes</span></span>(<span>self, size, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>The method reads <code>size</code> many bytes from the underlying stream starting at the current bit.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L513-L523" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
    &#34;&#34;&#34;
    The method reads `size` many bytes from the underlying stream starting at the current bit.
    &#34;&#34;&#34;
    if self.byte_aligned:
        data = self.read_exactly(size, peek)
        if not isinstance(data, bytes):
            data = bytes(data)
        return data
    else:
        return self.read_integer(size * 8, peek).to_bytes(size, self.byteorder_name)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_bit"><code class="name flex">
<span>def <span class="ident">read_bit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function is a shortcut for calling <code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">StructReader.read_integer()</a></code> with
an argument of <code>1</code>, i.e. this reads the next bit from the stream. The bits of any byte in the stream
are read from least significant to most significant.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L525-L531" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bit(self) -&gt; int:
    &#34;&#34;&#34;
    This function is a shortcut for calling `refinery.lib.structures.StructReader.read_integer` with
    an argument of `1`, i.e. this reads the next bit from the stream. The bits of any byte in the stream
    are read from least significant to most significant.
    &#34;&#34;&#34;
    return self.read_integer(1)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_bits"><code class="name flex">
<span>def <span class="ident">read_bits</span></span>(<span>self, nbits)</span>
</code></dt>
<dd>
<section class="desc"><p>This method returns the bits of <code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">StructReader.read_integer()</a></code> as an iterable
from least to most significant.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L533-L540" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bits(self, nbits: int) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    This method returns the bits of `refinery.lib.structures.StructReader.read_integer` as an iterable
    from least to most significant.
    &#34;&#34;&#34;
    chunk = self.read_integer(nbits)
    for k in range(nbits - 1, -1, -1):
        yield chunk &gt;&gt; k &amp; 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_flags"><code class="name flex">
<span>def <span class="ident">read_flags</span></span>(<span>self, nbits, reverse=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Identical to <code><a title="refinery.lib.structures.StructReader.read_bits" href="#refinery.lib.structures.StructReader.read_bits">StructReader.read_bits()</a></code> with every bit value cast to a boolean.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L542-L550" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_flags(self, nbits: int, reverse=False) -&gt; Iterable[bool]:
    &#34;&#34;&#34;
    Identical to `refinery.lib.structures.StructReader.read_bits` with every bit value cast to a boolean.
    &#34;&#34;&#34;
    bits = list(self.read_bits(nbits))
    if reverse:
        bits.reverse()
    for bit in bits:
        yield bool(bit)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_struct"><code class="name flex">
<span>def <span class="ident">read_struct</span></span>(<span>self, spec, unwrap=False, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read structured data from the stream in any format supported by the <code>struct</code> module. The <code>format</code>
argument can be used to override the current byte ordering. If the <code>unwrap</code> parameter is <code>True</code>, a
single unpacked value will be returned as a scalar, not as a tuple with one element.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L552-L592" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_struct(self, spec: str, unwrap=False, peek=False) -&gt; Union[List[UnpackType], UnpackType]:
    &#34;&#34;&#34;
    Read structured data from the stream in any format supported by the `struct` module. The `format`
    argument can be used to override the current byte ordering. If the `unwrap` parameter is `True`, a
    single unpacked value will be returned as a scalar, not as a tuple with one element.
    &#34;&#34;&#34;
    if not spec:
        raise ValueError(&#39;no format specified&#39;)
    byteorder = spec[:1]
    if byteorder in &#39;&lt;!=@&gt;&#39;:
        spec = spec[1:]
    else:
        byteorder = self.byteorder_format
    data = []
    current_cursor = self.tell()

    # reserved struct characters: xcbB?hHiIlLqQnNefdspP
    for k, part in enumerate(re.split(&#39;(\\d*[auwgE])&#39;, spec)):
        if k % 2 == 1:
            count = 1 if len(part) == 1 else int(part[:~0])
            part = part[~0]
            for _ in range(count):
                if part == &#39;a&#39;:
                    data.append(self.read_c_string())
                elif part == &#39;g&#39;:
                    data.append(self.read_guid())
                elif part == &#39;u&#39;:
                    data.append(self.read_w_string())
                elif part == &#39;w&#39;:
                    data.append(codecs.decode(self.read_w_string(), &#39;utf-16le&#39;))
                elif part == &#39;E&#39;:
                    data.append(self.read_7bit_encoded_int())
            continue
        else:
            part = F&#39;{byteorder}{part}&#39;
            data.extend(struct.unpack(part, self.read_bytes(struct.calcsize(part))))
    if unwrap and len(data) == 1:
        return data[0]
    if peek:
        self.seekset(current_cursor)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_nibble"><code class="name flex">
<span>def <span class="ident">read_nibble</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Calls <code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">StructReader.read_integer()</a></code> with an argument of <code>4</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L594-L598" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_nibble(self, peek: bool = False) -&gt; int:
    &#34;&#34;&#34;
    Calls `refinery.lib.structures.StructReader.read_integer` with an argument of `4`.
    &#34;&#34;&#34;
    return self.read_integer(4, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u8"><code class="name flex">
<span>def <span class="ident">u8</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L600-L600" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u8(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i8"><code class="name flex">
<span>def <span class="ident">i8</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L601-L601" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i8(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u16"><code class="name flex">
<span>def <span class="ident">u16</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L603-L603" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u16(self, peek: bool = False) -&gt; int: return self.read_integer(16, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u32"><code class="name flex">
<span>def <span class="ident">u32</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L604-L604" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u32(self, peek: bool = False) -&gt; int: return self.read_integer(32, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u64"><code class="name flex">
<span>def <span class="ident">u64</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L605-L605" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u64(self, peek: bool = False) -&gt; int: return self.read_integer(64, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i16"><code class="name flex">
<span>def <span class="ident">i16</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L606-L606" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i16(self, peek: bool = False) -&gt; int: return signed(self.read_integer(16, peek), 16)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i32"><code class="name flex">
<span>def <span class="ident">i32</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L607-L607" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i32(self, peek: bool = False) -&gt; int: return signed(self.read_integer(32, peek), 32)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i64"><code class="name flex">
<span>def <span class="ident">i64</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L608-L608" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i64(self, peek: bool = False) -&gt; int: return signed(self.read_integer(64, peek), 64)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.f32"><code class="name flex">
<span>def <span class="ident">f32</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L610-L610" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def f32(self, peek: bool = False) -&gt; float: return self.read_struct(&#39;f&#39;, unwrap=True, peek=peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.f64"><code class="name flex">
<span>def <span class="ident">f64</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L611-L611" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def f64(self, peek: bool = False) -&gt; float: return self.read_struct(&#39;d&#39;, unwrap=True, peek=peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_byte"><code class="name flex">
<span>def <span class="ident">read_byte</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L613-L613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_byte(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_char"><code class="name flex">
<span>def <span class="ident">read_char</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L614-L614" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_char(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_terminated_array"><code class="name flex">
<span>def <span class="ident">read_terminated_array</span></span>(<span>self, terminator, alignment=1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L616-L636" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_terminated_array(self, terminator: bytes, alignment: int = 1) -&gt; bytearray:
    pos = self.tell()
    buf = self.getbuffer()
    try:
        end = pos - 1
        while True:
            end = buf.find(terminator, end + 1)
            if end &lt; 0 or not (end - pos) % alignment:
                break
    except AttributeError:
        result = bytearray()
        while not self.eof:
            result.extend(self.read_bytes(alignment))
            if result.endswith(terminator):
                return result[:-len(terminator)]
        self.seek(pos)
        raise EOF
    else:
        data = self.read_exactly(end - pos)
        self.seekrel(len(terminator))
        return bytearray(data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_guid"><code class="name flex">
<span>def <span class="ident">read_guid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L638-L652" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_guid(self) -&gt; str:
    _mode = self.bigendian
    self.bigendian = False
    try:
        a = self.u32()
        b = self.u16()
        c = self.u16()
        d = self.read(2).hex().upper()
        e = self.read(6).hex().upper()
    except Exception:
        raise
    else:
        return F&#39;{a:08X}-{b:04X}-{c:04X}-{d}-{e}&#39;
    finally:
        self.bigendian = _mode</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_c_string"><code class="name flex">
<span>def <span class="ident">read_c_string</span></span>(<span>self, encoding=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L662-L666" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_c_string(self, encoding=None) -&gt; Union[str, bytearray]:
    data = self.read_terminated_array(B&#39;\0&#39;)
    if encoding is not None:
        data = codecs.decode(data, encoding)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_w_string"><code class="name flex">
<span>def <span class="ident">read_w_string</span></span>(<span>self, encoding=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L676-L680" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_w_string(self, encoding=None) -&gt; Union[str, bytearray]:
    data = self.read_terminated_array(B&#39;\0\0&#39;, 2)
    if encoding is not None:
        data = codecs.decode(data, encoding)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed_ascii"><code class="name flex">
<span>def <span class="ident">read_length_prefixed_ascii</span></span>(<span>self, prefix_size=32)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L682-L683" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed_ascii(self, prefix_size: int = 32):
    return self.read_length_prefixed(prefix_size, &#39;latin1&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed_utf8"><code class="name flex">
<span>def <span class="ident">read_length_prefixed_utf8</span></span>(<span>self, prefix_size=32)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L685-L686" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed_utf8(self, prefix_size: int = 32):
    return self.read_length_prefixed(prefix_size, &#39;utf8&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed_utf16"><code class="name flex">
<span>def <span class="ident">read_length_prefixed_utf16</span></span>(<span>self, prefix_size=32, bytecount=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L688-L690" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed_utf16(self, prefix_size: int = 32, bytecount: bool = False):
    block_size = 1 if bytecount else 2
    return self.read_length_prefixed(prefix_size, &#39;utf-16le&#39;, block_size)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed"><code class="name flex">
<span>def <span class="ident">read_length_prefixed</span></span>(<span>self, prefix_size=32, encoding=None, block_size=1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L704-L709" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed(self, prefix_size: int = 32, encoding: Optional[str] = None, block_size: int = 1) -&gt; Union[T, str]:
    prefix = self.read_integer(prefix_size) * block_size
    data = self.read(prefix)
    if encoding is not None:
        data = codecs.decode(data, encoding)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_7bit_encoded_int"><code class="name flex">
<span>def <span class="ident">read_7bit_encoded_int</span></span>(<span>self, max_bits=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L711-L719" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_7bit_encoded_int(self, max_bits: int = 0) -&gt; int:
    value = 0
    for shift in itertools.count(0, step=7):
        b = self.read_byte()
        value |= (b &amp; 0x7F) &lt;&lt; shift
        if not b &amp; 0x80:
            return value
        if shift &gt; max_bits &gt; 0:
            raise RuntimeError(&#39;Maximum bits were exceeded by encoded integer.&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.structures.MemoryFile.SEEK" href="#refinery.lib.structures.MemoryFileMethods.SEEK">SEEK</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.structures.StructMeta"><code class="flex name class">
<span>class <span class="ident">StructMeta</span></span>
<span>(</span><span>name, bases, nmspc, parser=refinery.lib.structures.StructReader)</span>
</code></dt>
<dd>
<section class="desc"><p>A metaclass to facilitate the behavior outlined for <code><a title="refinery.lib.structures.Struct" href="#refinery.lib.structures.Struct">Struct</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L722-L746" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StructMeta(type):
    &#34;&#34;&#34;
    A metaclass to facilitate the behavior outlined for `refinery.lib.structures.Struct`.
    &#34;&#34;&#34;
    def __new__(mcls, name, bases, nmspc, parser=StructReader):
        return type.__new__(mcls, name, bases, nmspc)

    def __init__(cls, name, bases, nmspc, parser=StructReader):
        super(StructMeta, cls).__init__(name, bases, nmspc)
        original__init__ = cls.__init__

        @functools.wraps(original__init__)
        def wrapped__init__(self: Struct, reader, *args, **kwargs):
            if not isinstance(reader, parser):
                if issubclass(parser, reader.__class__):
                    raise ValueError(
                        F&#39;A reader of type {reader.__class__.__name__} was passed to {cls.__name__}, &#39;
                        F&#39;but a {parser.__name__} is required.&#39;)
                reader = parser(reader)
            start = reader.tell()
            view = memoryview(reader.getbuffer())
            original__init__(self, reader, *args, **kwargs)
            self._data = view[start:reader.tell()]

        cls.__init__ = wrapped__init__</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
</dd>
<dt id="refinery.lib.structures.Struct"><code class="flex name class">
<span>class <span class="ident">Struct</span></span>
<span>(</span><span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L749-L775" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Struct(metaclass=StructMeta):
    &#34;&#34;&#34;
    A class to parse structured data. A `refinery.lib.structures.Struct` class can be instantiated
    as follows:

        foo = Struct(data, bar=29)

    The initialization routine of the structure will be called with a single argument `reader`. If
    the object `data` is already a `refinery.lib.structures.StructReader`, then it will be passed
    as `reader`. Otherwise, the argument will be wrapped in a `refinery.lib.structures.StructReader`.
    Additional arguments to the struct are passed through.
    &#34;&#34;&#34;
    _data: Union[memoryview, bytearray]

    def __len__(self):
        return len(self._data)

    def __bytes__(self):
        return bytes(self._data)

    def get_data(self, decouple=False):
        if decouple and isinstance(self._data, memoryview):
            self._data = bytearray(self._data)
        return self._data

    def __init__(self, reader: StructReader, *args, **kwargs):
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.dex.DexFile" href="dex.html#refinery.lib.dex.DexFile">DexFile</a></li>
<li><a title="refinery.lib.java.JvAccessFlags" href="java.html#refinery.lib.java.JvAccessFlags">JvAccessFlags</a></li>
<li><a title="refinery.lib.java.JvClassFile" href="java.html#refinery.lib.java.JvClassFile">JvClassFile</a></li>
<li><a title="refinery.lib.java.JvCode" href="java.html#refinery.lib.java.JvCode">JvCode</a></li>
<li><a title="refinery.lib.java.JvException" href="java.html#refinery.lib.java.JvException">JvException</a></li>
<li><a title="refinery.lib.java.JvOpCode" href="java.html#refinery.lib.java.JvOpCode">JvOpCode</a></li>
<li>refinery.lib.java._HasPoolAndTag</li>
<li><a title="refinery.lib.mscrypto.BCRYPT_RSAKEY_BLOB" href="mscrypto.html#refinery.lib.mscrypto.BCRYPT_RSAKEY_BLOB">BCRYPT_RSAKEY_BLOB</a></li>
<li><a title="refinery.lib.mscrypto.BLOBHEADER" href="mscrypto.html#refinery.lib.mscrypto.BLOBHEADER">BLOBHEADER</a></li>
<li><a title="refinery.lib.mscrypto.CRYPTOKEY" href="mscrypto.html#refinery.lib.mscrypto.CRYPTOKEY">CRYPTOKEY</a></li>
<li><a title="refinery.lib.mscrypto.DHPUBKEY" href="mscrypto.html#refinery.lib.mscrypto.DHPUBKEY">DHPUBKEY</a></li>
<li><a title="refinery.lib.mscrypto.PLAINTEXTKEYBLOB" href="mscrypto.html#refinery.lib.mscrypto.PLAINTEXTKEYBLOB">PLAINTEXTKEYBLOB</a></li>
<li><a title="refinery.lib.mscrypto.PRIVATEKEYBLOB" href="mscrypto.html#refinery.lib.mscrypto.PRIVATEKEYBLOB">PRIVATEKEYBLOB</a></li>
<li><a title="refinery.lib.mscrypto.RSAPUBKEY" href="mscrypto.html#refinery.lib.mscrypto.RSAPUBKEY">RSAPUBKEY</a></li>
<li><a title="refinery.lib.mscrypto.SIMPLEBLOB" href="mscrypto.html#refinery.lib.mscrypto.SIMPLEBLOB">SIMPLEBLOB</a></li>
<li><a title="refinery.units.compression.lzf.LZFHeader" href="../units/compression/lzf.html#refinery.units.compression.lzf.LZFHeader">LZFHeader</a></li>
<li><a title="refinery.units.compression.lzg.LZGStream" href="../units/compression/lzg.html#refinery.units.compression.lzg.LZGStream">LZGStream</a></li>
<li><a title="refinery.units.compression.lzip.RangeDecoder" href="../units/compression/lzip.html#refinery.units.compression.lzip.RangeDecoder">RangeDecoder</a></li>
<li><a title="refinery.units.compression.lzo.LZO" href="../units/compression/lzo.html#refinery.units.compression.lzo.LZO">LZO</a></li>
<li><a title="refinery.units.compression.lzo.LZOChunk" href="../units/compression/lzo.html#refinery.units.compression.lzo.LZOChunk">LZOChunk</a></li>
<li><a title="refinery.units.formats.a3x.A3xRecord" href="../units/formats/a3x.html#refinery.units.formats.a3x.A3xRecord">A3xRecord</a></li>
<li><a title="refinery.units.formats.a3x.A3xScript" href="../units/formats/a3x.html#refinery.units.formats.a3x.A3xScript">A3xScript</a></li>
<li><a title="refinery.units.formats.archive.xtasar.AsarHeader" href="../units/formats/archive/xtasar.html#refinery.units.formats.archive.xtasar.AsarHeader">AsarHeader</a></li>
<li><a title="refinery.units.formats.archive.xtcpio.CPIOEntry" href="../units/formats/archive/xtcpio.html#refinery.units.formats.archive.xtcpio.CPIOEntry">CPIOEntry</a></li>
<li><a title="refinery.units.formats.archive.xtgz.GzipHeader" href="../units/formats/archive/xtgz.html#refinery.units.formats.archive.xtgz.GzipHeader">GzipHeader</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="../units/formats/archive/xtinno.html#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.TSetupOffsets" href="../units/formats/archive/xtinno.html#refinery.units.formats.archive.xtinno.TSetupOffsets">TSetupOffsets</a></li>
<li><a title="refinery.units.formats.archive.xtmacho.FatArch" href="../units/formats/archive/xtmacho.html#refinery.units.formats.archive.xtmacho.FatArch">FatArch</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSArchive" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSArchive">NSArchive</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSBlockHeaderOffset" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSBlockHeaderOffset">NSBlockHeaderOffset</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSHeader" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSHeader">NSHeader</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSScriptExtendedInstruction" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSScriptExtendedInstruction">NSScriptExtendedInstruction</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSScriptInstruction" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSScriptInstruction">NSScriptInstruction</a></li>
<li><a title="refinery.units.formats.archive.xtpyi.PYZ" href="../units/formats/archive/xtpyi.html#refinery.units.formats.archive.xtpyi.PYZ">PYZ</a></li>
<li><a title="refinery.units.formats.archive.xtpyi.PiTOCEntry" href="../units/formats/archive/xtpyi.html#refinery.units.formats.archive.xtpyi.PiTOCEntry">PiTOCEntry</a></li>
<li><a title="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue" href="../units/formats/archive/xtpyi.html#refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue">PyInstallerArchiveEpilogue</a></li>
<li><a title="refinery.units.formats.ifps.IFPSFile" href="../units/formats/ifps.html#refinery.units.formats.ifps.IFPSFile">IFPSFile</a></li>
<li><a title="refinery.units.formats.pe.perc.GRPICONDIR" href="../units/formats/pe/perc.html#refinery.units.formats.pe.perc.GRPICONDIR">GRPICONDIR</a></li>
<li><a title="refinery.units.formats.pe.perc.GRPICONDIRENTRY" href="../units/formats/pe/perc.html#refinery.units.formats.pe.perc.GRPICONDIRENTRY">GRPICONDIRENTRY</a></li>
<li><a title="refinery.units.pattern.carve_zip.ZipCentralDirectory" href="../units/pattern/carve_zip.html#refinery.units.pattern.carve_zip.ZipCentralDirectory">ZipCentralDirectory</a></li>
<li><a title="refinery.units.pattern.carve_zip.ZipEndOfCentralDirectory" href="../units/pattern/carve_zip.html#refinery.units.pattern.carve_zip.ZipEndOfCentralDirectory">ZipEndOfCentralDirectory</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.Struct.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self, decouple=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L769-L772" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_data(self, decouple=False):
    if decouple and isinstance(self._data, memoryview):
        self._data = bytearray(self._data)
    return self._data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.structures.PerInstanceAttribute"><code class="flex name class">
<span>class <span class="ident">PerInstanceAttribute</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from
this class parameterized with one or more type variables.
For example, a generic mapping type might be defined as::</p>
<p>class Mapping(Generic[KT, VT]):
def <strong>getitem</strong>(self, key: KT) -&gt; VT:
&hellip;
# Etc.</p>
<p>This class can then be used as follows::</p>
<p>def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
try:
return mapping[key]
except KeyError:
return default</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L781-L806" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PerInstanceAttribute(Generic[AttrType]):
    def resolve(self, parent, value: Any) -&gt; AttrType:
        return value

    def __init__(self):
        self.__set: Dict[int, Any] = {}
        self.__get: Dict[int, AttrType] = {}

    def __set__(self, parent: Any, value: Any) -&gt; None:
        pid = id(parent)
        if pid not in self.__set:
            def cleanup(self, pid):
                self.__set.pop(pid, None)
                self.__get.pop(pid, None)
            self.__set[pid] = value
            weakref.finalize(parent, cleanup, self, id(parent))

    def __get__(self, parent, tp=None) -&gt; AttrType:
        pid = id(parent)
        if pid not in self.__get:
            try:
                seed = self.__set[pid]
            except KeyError as K:
                raise AttributeError from K
            self.__get[pid] = self.resolve(parent, seed)
        return self.__get[pid]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>refinery.lib.java.Index</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.PerInstanceAttribute.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>self, parent, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/structures.py#L782-L783" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resolve(self, parent, value: Any) -&gt; AttrType:
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.structures.signed" href="#refinery.lib.structures.signed">signed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.structures.EOF" href="#refinery.lib.structures.EOF">EOF</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.StreamDetour" href="#refinery.lib.structures.StreamDetour">StreamDetour</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.structures.MemoryFileMethods.close" href="#refinery.lib.structures.MemoryFileMethods.close">close</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.flush" href="#refinery.lib.structures.MemoryFileMethods.flush">flush</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.isatty" href="#refinery.lib.structures.MemoryFileMethods.isatty">isatty</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.fileno" href="#refinery.lib.structures.MemoryFileMethods.fileno">fileno</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readable" href="#refinery.lib.structures.MemoryFileMethods.readable">readable</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seekable" href="#refinery.lib.structures.MemoryFileMethods.seekable">seekable</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.detour" href="#refinery.lib.structures.MemoryFileMethods.detour">detour</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.writable" href="#refinery.lib.structures.MemoryFileMethods.writable">writable</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.read_as" href="#refinery.lib.structures.MemoryFileMethods.read_as">read_as</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.read" href="#refinery.lib.structures.MemoryFileMethods.read">read</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.peek" href="#refinery.lib.structures.MemoryFileMethods.peek">peek</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.read1" href="#refinery.lib.structures.MemoryFileMethods.read1">read1</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readline" href="#refinery.lib.structures.MemoryFileMethods.readline">readline</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readlines" href="#refinery.lib.structures.MemoryFileMethods.readlines">readlines</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readinto1" href="#refinery.lib.structures.MemoryFileMethods.readinto1">readinto1</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readinto" href="#refinery.lib.structures.MemoryFileMethods.readinto">readinto</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.tell" href="#refinery.lib.structures.MemoryFileMethods.tell">tell</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seekrel" href="#refinery.lib.structures.MemoryFileMethods.seekrel">seekrel</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seekset" href="#refinery.lib.structures.MemoryFileMethods.seekset">seekset</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.getbuffer" href="#refinery.lib.structures.MemoryFileMethods.getbuffer">getbuffer</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.getvalue" href="#refinery.lib.structures.MemoryFileMethods.getvalue">getvalue</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seek" href="#refinery.lib.structures.MemoryFileMethods.seek">seek</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.writelines" href="#refinery.lib.structures.MemoryFileMethods.writelines">writelines</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.truncate" href="#refinery.lib.structures.MemoryFileMethods.truncate">truncate</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.write_byte" href="#refinery.lib.structures.MemoryFileMethods.write_byte">write_byte</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.write" href="#refinery.lib.structures.MemoryFileMethods.write">write</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.replay" href="#refinery.lib.structures.MemoryFileMethods.replay">replay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.order" href="#refinery.lib.structures.order">order</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.structures.StructReader.seek" href="#refinery.lib.structures.StructReader.seek">seek</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_exactly" href="#refinery.lib.structures.StructReader.read_exactly">read_exactly</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.byte_align" href="#refinery.lib.structures.StructReader.byte_align">byte_align</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">read_integer</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bytes" href="#refinery.lib.structures.StructReader.read_bytes">read_bytes</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bit" href="#refinery.lib.structures.StructReader.read_bit">read_bit</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bits" href="#refinery.lib.structures.StructReader.read_bits">read_bits</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_flags" href="#refinery.lib.structures.StructReader.read_flags">read_flags</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_struct" href="#refinery.lib.structures.StructReader.read_struct">read_struct</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_nibble" href="#refinery.lib.structures.StructReader.read_nibble">read_nibble</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u8" href="#refinery.lib.structures.StructReader.u8">u8</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i8" href="#refinery.lib.structures.StructReader.i8">i8</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u16" href="#refinery.lib.structures.StructReader.u16">u16</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u32" href="#refinery.lib.structures.StructReader.u32">u32</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u64" href="#refinery.lib.structures.StructReader.u64">u64</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i16" href="#refinery.lib.structures.StructReader.i16">i16</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i32" href="#refinery.lib.structures.StructReader.i32">i32</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i64" href="#refinery.lib.structures.StructReader.i64">i64</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.f32" href="#refinery.lib.structures.StructReader.f32">f32</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.f64" href="#refinery.lib.structures.StructReader.f64">f64</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_byte" href="#refinery.lib.structures.StructReader.read_byte">read_byte</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_char" href="#refinery.lib.structures.StructReader.read_char">read_char</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_terminated_array" href="#refinery.lib.structures.StructReader.read_terminated_array">read_terminated_array</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_guid" href="#refinery.lib.structures.StructReader.read_guid">read_guid</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_c_string" href="#refinery.lib.structures.StructReader.read_c_string">read_c_string</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_w_string" href="#refinery.lib.structures.StructReader.read_w_string">read_w_string</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed_ascii" href="#refinery.lib.structures.StructReader.read_length_prefixed_ascii">read_length_prefixed_ascii</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed_utf8" href="#refinery.lib.structures.StructReader.read_length_prefixed_utf8">read_length_prefixed_utf8</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed_utf16" href="#refinery.lib.structures.StructReader.read_length_prefixed_utf16">read_length_prefixed_utf16</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed" href="#refinery.lib.structures.StructReader.read_length_prefixed">read_length_prefixed</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_7bit_encoded_int" href="#refinery.lib.structures.StructReader.read_7bit_encoded_int">read_7bit_encoded_int</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.StructMeta" href="#refinery.lib.structures.StructMeta">StructMeta</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.Struct" href="#refinery.lib.structures.Struct">Struct</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.structures.Struct.get_data" href="#refinery.lib.structures.Struct.get_data">get_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.PerInstanceAttribute" href="#refinery.lib.structures.PerInstanceAttribute">PerInstanceAttribute</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.structures.PerInstanceAttribute.resolve" href="#refinery.lib.structures.PerInstanceAttribute.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>