<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>the refinery.lib.crypto documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.crypto</code></h1>
</header>
<section id="section-intro">
<p>Primitives used in custom cryptographic implementations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L1-L651" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Primitives used in custom cryptographic implementations.
&#34;&#34;&#34;
from __future__ import annotations

from typing import Callable, ClassVar, Container, Generator, Optional, Type, Union, Dict
from abc import ABC, abstractmethod
from enum import Enum

BufferType = Union[bytearray, bytes, memoryview]
CIPHER_MODES: Dict[str, CipherMode] = {}


def strxor(a: bytes, b: bytes):
    &#34;&#34;&#34;
    Return the XOR of the two byte strings `a` and `b`. The shorter of the two strings defines the
    length of the output.
    &#34;&#34;&#34;
    return bytes(a ^ b for a, b in zip(a, b))


def _register_cipher_mode(cls: Type[CipherMode]):
    cls._identifier = len(CIPHER_MODES)
    CIPHER_MODES[cls.__name__] = cls
    return cls


def rotl128(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 128-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x80 - c))) &amp; 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF


def rotl64(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 64-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x40 - c))) &amp; 0xFFFFFFFFFFFFFFFF


def rotl32(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 32-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x20 - c))) &amp; 0xFFFFFFFF


def rotl16(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 16-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x10 - c))) &amp; 0xFFFF


def rotl8(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the byte `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x08 - c))) &amp; 0xFF


def rotr128(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 128-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x80 - c) &amp; 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | (x &gt;&gt; c)


def rotr64(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 64-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x40 - c) &amp; 0xFFFFFFFFFFFFFFFF) | (x &gt;&gt; c)


def rotr32(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 32-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x20 - c) &amp; 0xFFFFFFFF) | (x &gt;&gt; c)


def rotr16(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 16-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x10 - c) &amp; 0xFFFF) | (x &gt;&gt; c)


def rotr8(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the byte `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x08 - c) &amp; 0xFF) | (x &gt;&gt; c)


def rotr(n: int, x: int, c: int) -&gt; int:
    &#34;&#34;&#34;
    Rotate the `n`-bit integer `x` by `c` positions to the right. If `n` is among the common bit
    sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
    used instead.
    &#34;&#34;&#34;
    mask = (1 &lt;&lt; n) - 1
    c %= n
    return (x &gt;&gt; c) | (x &lt;&lt; (n - c) &amp; mask)


def rotl(n: int, x: int, c: int) -&gt; int:
    &#34;&#34;&#34;
    Rotate the `n`-bit integer `x` by `c` positions to the left. If `n` is among the common bit
    sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
    used instead.
    &#34;&#34;&#34;
    mask = (1 &lt;&lt; n) - 1
    c %= n
    return (x &gt;&gt; (n - c)) | (x &lt;&lt; c &amp; mask)


class Operation(str, Enum):
    &#34;&#34;&#34;
    Specifies whether data is currently being encrypted or decrypted.
    &#34;&#34;&#34;
    Encrypt = &#39;encrypt&#39;
    Decrypt = &#39;decrypt&#39;


class CipherMode(ABC):
    &#34;&#34;&#34;
    Abstract base class for a cipher mode of operation.
    &#34;&#34;&#34;

    encrypt_block: Callable[[memoryview], memoryview]
    decrypt_block: Callable[[memoryview], memoryview]
    aligned: bool = True
    _identifier: ClassVar[int]

    @abstractmethod
    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        &#34;&#34;&#34;
        Implements data encryption according to the current cipher mode and underlying cipher.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        &#34;&#34;&#34;
        Implements data decryption according to the current cipher mode and underlying cipher.
        &#34;&#34;&#34;
        raise NotImplementedError

    def apply(
        self,
        operation: Operation,
        dst: memoryview,
        src: memoryview,
        encrypt_block: Callable[[memoryview], memoryview],
        decrypt_block: Callable[[memoryview], memoryview],
        blocksize: int,
    ) -&gt; memoryview:
        &#34;&#34;&#34;
        This method is used to perform a cryptographic `refinery.lib.crypto.Operation` to a given
        source `src` and write the result to the memory at `dst` according to the current cipher
        mode. To this end, it requires the block encryption and decryption primitives of the
        underlying cipher and the current block size.
        &#34;&#34;&#34;
        self.encrypt_block = encrypt_block
        self.decrypt_block = decrypt_block
        engine: Generator[memoryview, memoryview, None] = {
            Operation.Encrypt: self.encrypt,
            Operation.Decrypt: self.decrypt,
        }[operation]()
        next(engine)
        top, rest = divmod(len(src), blocksize)
        top *= blocksize
        for k in range(0, top, blocksize):
            dst[k:k + blocksize] = engine.send(src[k:k + blocksize])
        if rest:
            dst[-rest:] = engine.send(src[-rest:])[:rest]
        engine.close()
        return dst


@_register_cipher_mode
class ECB(CipherMode):
    &#34;&#34;&#34;
    The Electronic Codebook (ECB) is the most simple cipher mode of operation. The underlying
    cipher is applied block-wise with no additional safeguards.
    &#34;&#34;&#34;

    def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        M = None
        D = self.decrypt_block
        while True:
            C = yield M
            M = D(C)

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        C = None
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(M)


class DataUnaligned(ValueError):
    &#34;&#34;&#34;
    Raised when input data is unexpectedly unaligned to the current block size.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__(&#39;Data not aligned to block size.&#39;)


class StatefulCipherMode(CipherMode):
    &#34;&#34;&#34;
    A subclass of `refinery.lib.crypto.CipherMode` that holds a state while performing any of
    its cryptographic `refinery.lib.crypto.Operation`s.
    &#34;&#34;&#34;

    iv: BufferType
    &#34;&#34;&#34;
    The initial vector for the internal state of the cipher mode.
    &#34;&#34;&#34;

    def __init__(self, iv: BufferType):
        self.iv = iv


@_register_cipher_mode
class CBC(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of the popular Cipher Block Chaining mode of operation.
    &#34;&#34;&#34;

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        C = self.iv
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(strxor(M, C))

    def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        S = self.iv
        M = None
        D = self.decrypt_block
        while True:
            C = yield M
            M = strxor(D(C), S)
            S = bytes(C)


@_register_cipher_mode
class PCBC(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of Propagating Cipher Block Chaining.
    &#34;&#34;&#34;

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        S = self.iv
        C = None
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(strxor(M, S))
            S = strxor(C, M)

    def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        S = self.iv
        M = None
        D = self.decrypt_block
        while True:
            C = yield M
            M = strxor(S, D(C))
            S = strxor(M, C)


@_register_cipher_mode
class CFB(CipherMode):
    &#34;&#34;&#34;
    Cipher Feedback Mode: https://csrc.nist.gov/publications/detail/sp/800-38a/final
    &#34;&#34;&#34;

    iv: BufferType
    segment_size: int
    aligned = False

    def __init__(self, iv: BufferType, segment_size: Optional[int] = None):
        if segment_size is None:
            segment_size = 8
        if segment_size % 8 != 0:
            raise NotImplementedError(&#39;segment sizes may only be multiples of 8&#39;)
        segment_size = segment_size // 8
        if len(iv) % segment_size != 0:
            raise NotImplementedError(
                F&#39;the block size {len(iv) * 8} is not an even multiple of the segment &#39;
                F&#39;size {segment_size * 8}; this is currently not supported.&#39;)
        self.segment_size = segment_size
        self.iv = iv

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        s = self.segment_size
        S = bytearray(self.iv)
        E = self.encrypt_block
        C = bytearray(len(self.iv))
        if s == 1:
            while True:
                M = yield C
                for k, m in enumerate(M):
                    C[k] = c = m ^ E(S)[0]
                    S[:-1], S[-1] = memoryview(S)[1:], c
        else:
            segments = [slice(i, i + s) for i in range(0, len(S), s)]
            while True:
                M = yield C
                for k in segments:
                    m = M[k]
                    C[k] = c = strxor(m, E(S)[:s])
                    S[:-s], S[-s:] = memoryview(S)[s:], c

    def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        s = self.segment_size
        S = bytearray(self.iv)
        E = self.encrypt_block
        M = bytearray(len(self.iv))
        if s == 1:
            while True:
                C = yield M
                for k, c in enumerate(C):
                    M[k] = c ^ E(S)[0]
                    S[:-1], S[-1] = memoryview(S)[1:], c
        else:
            segments = [slice(i, i + s) for i in range(0, len(S), s)]
            while True:
                C = yield M
                for k in segments:
                    c = C[k]
                    M[k] = strxor(c, E(S)[:s])
                    S[:-s], S[-s:] = memoryview(S)[s:], c


@_register_cipher_mode
class OFB(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of Output Feedback Mode.
    &#34;&#34;&#34;

    aligned = False

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        S = self.iv
        C = None
        E = self.encrypt_block
        while True:
            M = yield C
            S = E(S)
            C = strxor(M, S)

    decrypt = encrypt


@_register_cipher_mode
class CTR(CipherMode):
    &#34;&#34;&#34;
    An implementation of Counter mode.
    &#34;&#34;&#34;

    counter_len: int
    prefix: BufferType
    suffix: BufferType
    initial_value: int
    little_endian: bool
    block_size: int

    aligned = False

    @property
    def byte_order(self):
        return &#39;little&#39; if self.little_endian else &#39;big&#39;

    def __init__(
        self,
        block_size: Optional[int] = None,
        counter: Optional[Dict] = None,
        nonce: Optional[BufferType] = None,
        initial_value: Optional[int] = 0,
        little_endian: bool = False
    ):
        if counter is not None:
            self.initial_value = counter.get(&#39;initial_value&#39;, initial_value)
            self.little_endian = counter.get(&#39;little_endian&#39;, little_endian)
            self.prefix = counter[&#39;prefix&#39;]
            self.suffix = counter[&#39;suffix&#39;]
            self.counter_len = counter[&#39;counter_len&#39;]
            self.block_size = self.counter_len + len(self.prefix) + len(self.suffix)
            if block_size not in {None, self.block_size}:
                raise ValueError(&#39;Information in counter object does not align with block size.&#39;)
            return
        if block_size is None:
            raise ValueError(&#39;Unable to construct CTR mode object without block_size or counter argument.&#39;)

        self.initial_value = initial_value
        self.little_endian = little_endian
        self.suffix = B&#39;&#39;
        self.block_size = block_size

        if nonce is not None:
            if len(nonce) &gt; block_size:
                raise ValueError(&#39;Nonce length exceeds block length.&#39;)
            self.counter_len = block_size - len(nonce)
            self.prefix = nonce
        else:
            self.counter_len = block_size // 2
            self.prefix = B&#39;\0&#39; * (block_size - self.counter_len)

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        S = bytearray(self.block_size)
        J = slice(len(self.prefix), self.block_size - len(self.suffix))
        K = self.initial_value
        if self.prefix:
            S[:+len(self.prefix)] = self.prefix
        if self.suffix:
            S[-len(self.suffix):] = self.suffix
        C = None
        E = self.encrypt_block
        order = self.byte_order
        csize = self.counter_len
        mask = (1 &lt;&lt; (csize * 8)) - 1
        while True:
            M = yield C
            S[J] = K.to_bytes(csize, order)
            K = K + 1 &amp; mask
            C = strxor(E(S), M)

    decrypt = encrypt


class CipherInterface(ABC):
    &#34;&#34;&#34;
    Abstract base class for refinery&#39;s block cipher interface.
    &#34;&#34;&#34;

    key_size: Container[int]
    &#34;&#34;&#34;
    A container containing all valid key sizes for this cipher.
    &#34;&#34;&#34;

    block_size: int
    &#34;&#34;&#34;
    The block size of this cipher.
    &#34;&#34;&#34;

    @abstractmethod
    def encrypt(self, M: BufferType) -&gt; BufferType: ...
    &#34;&#34;&#34;
    Data encryption according to this cipher interface.
    &#34;&#34;&#34;

    @abstractmethod
    def decrypt(self, C: BufferType) -&gt; BufferType: ...
    &#34;&#34;&#34;
    Data decryption according to this cipher interface.
    &#34;&#34;&#34;


class CipherObjectFactory(ABC):
    &#34;&#34;&#34;
    An abstract class to build `refinery.lib.crypto.CipherInterface`s from an asortment of
    cryptographic secrets and parameters.
    &#34;&#34;&#34;

    name: str
    key_size: Optional[Container[int]] = None
    block_size: Optional[int] = None

    @abstractmethod
    def new(
        self,
        key: BufferType,
        iv: Optional[BufferType] = None,
        counter: Optional[int] = None,
        initial_value: Optional[int] = 0,
        nonce: Optional[BufferType] = None,
        mode: Optional[str] = None,
        segment_size: Optional[int] = None,
        block_size: Optional[int] = None,
        **cipher_args
    ) -&gt; CipherInterface:
        &#34;&#34;&#34;
        Build the actual `refinery.lib.crypto.CipherInterface` from the given input parameters.
        This mimics the PyCrypto interface for new ciphers in order to make the refinery factory
        cross-compatible with that library.
        &#34;&#34;&#34;
        ...


class PyCryptoFactoryWrapper(CipherObjectFactory):
    &#34;&#34;&#34;
    Wraps a PyCrypto module as a `refinery.lib.crypto.CipherObjectFactory`.
    &#34;&#34;&#34;

    def __init__(self, module):
        self.module = module

    def new(self, *a, **k) -&gt; CipherInterface:
        return self.module.new(*a, **k)

    @property
    def key_size(self):
        try:
            value = self.module.key_size
        except AttributeError:
            return None
        if isinstance(value, int):
            return {value}
        return value

    @property
    def block_size(self):
        try:
            value = self.module.block_size
        except AttributeError:
            return None
        return value

    def __repr__(self):
        return repr(self.module)

    def __dir__(self):
        return dir(self.module)

    def __getattr__(self, key):
        return getattr(self.module, key)


class BlockCipherFactory(CipherObjectFactory):
    &#34;&#34;&#34;
    A `refinery.lib.crypto.CipherObjectFactory` for custom block ciphers.
    &#34;&#34;&#34;

    cipher: Type[BlockCipher]

    def __init__(self, cipher: Type[BlockCipher]):
        self.cipher = cipher
        self._modes = []
        for name, mode in CIPHER_MODES.items():
            setattr(self, F&#39;MODE_{name}&#39;, mode._identifier)
            self._modes.append(mode)

    def new(self, key, mode=None, **args) -&gt; CipherInterface:
        if mode is not None:
            mode = self._modes[mode]
        mode_arguments = {}
        cipher = self.cipher
        for arg in (&#39;iv&#39;, &#39;counter&#39;, &#39;initial_value&#39;, &#39;nonce&#39;, &#39;mode&#39;, &#39;segment_size&#39;):
            try:
                mode_arguments[arg] = args.pop(arg)
            except KeyError:
                pass
        if mode is CTR:
            block_size = self.block_size
            if block_size is None:
                # This happens for ciphers that do not have a fixed block size, i.e. the
                # block size is truly an instance attribute and not a class property.
                # In this case, we create a temporary cipher object and use it to obtain
                # the true block size.
                block_size = cipher(key, ECB, **args).block_size
            mode_arguments.update(block_size=block_size)
        mode = mode(**mode_arguments)
        return cipher(key, mode, **args)

    @property
    def name(self):
        return self.cipher.__name__

    @property
    def key_size(self):
        try:
            value = self.cipher.key_size
        except AttributeError:
            return None
        if isinstance(value, property):
            return None
        return value

    @property
    def block_size(self):
        try:
            value = self.cipher.block_size
        except AttributeError:
            return None
        if not isinstance(value, int):
            return None
        return value


class BlockCipher(CipherInterface, ABC):
    block_size: int
    key: BufferType
    mode: CipherMode
    key_size: Container[int]

    def __init__(self, key: BufferType, mode: Optional[CipherMode]):
        if len(key) not in self.key_size:
            raise ValueError(F&#39;The key size {len(key)} is not supported by {self.__class__.__name__.lower()}.&#39;)
        self.key = key
        self.mode = mode or ECB()

    @abstractmethod
    def block_encrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Encryption of a single block of data.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def block_decrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Decryption of a single block of data.
        &#34;&#34;&#34;
        raise NotImplementedError

    def _apply_blockwise(self, operation: Operation, data: BufferType) -&gt; BufferType:
        block_size = self.block_size
        mode = self.mode
        if len(data) % block_size != 0 and mode.aligned:
            raise DataUnaligned
        dst = src = memoryview(data)
        if dst.readonly:
            dst = bytearray(src)
        return mode.apply(
            operation,
            dst,
            src,
            self.block_encrypt,
            self.block_decrypt,
            block_size
        )

    def encrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Encrypt the input data.
        &#34;&#34;&#34;
        return self._apply_blockwise(Operation.Encrypt, data)

    def decrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Decrypt the input data.
        &#34;&#34;&#34;
        return self._apply_blockwise(Operation.Decrypt, data)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.crypto.strxor"><code class="name flex">
<span>def <span class="ident">strxor</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the XOR of the two byte strings <code>a</code> and <code>b</code>. The shorter of the two strings defines the
length of the output.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L16-L21" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def strxor(a: bytes, b: bytes):
    &#34;&#34;&#34;
    Return the XOR of the two byte strings `a` and `b`. The shorter of the two strings defines the
    length of the output.
    &#34;&#34;&#34;
    return bytes(a ^ b for a, b in zip(a, b))</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl128"><code class="name flex">
<span>def <span class="ident">rotl128</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 128-bit integer <code>x</code> by <code>c</code> positions to the left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L30-L34" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl128(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 128-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x80 - c))) &amp; 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl64"><code class="name flex">
<span>def <span class="ident">rotl64</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 64-bit integer <code>x</code> by <code>c</code> positions to the left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L37-L41" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl64(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 64-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x40 - c))) &amp; 0xFFFFFFFFFFFFFFFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl32"><code class="name flex">
<span>def <span class="ident">rotl32</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 32-bit integer <code>x</code> by <code>c</code> positions to the left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L44-L48" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl32(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 32-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x20 - c))) &amp; 0xFFFFFFFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl16"><code class="name flex">
<span>def <span class="ident">rotl16</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 16-bit integer <code>x</code> by <code>c</code> positions to the left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L51-L55" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl16(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 16-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x10 - c))) &amp; 0xFFFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl8"><code class="name flex">
<span>def <span class="ident">rotl8</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the byte <code>x</code> by <code>c</code> positions to the left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L58-L62" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl8(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the byte `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x08 - c))) &amp; 0xFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr128"><code class="name flex">
<span>def <span class="ident">rotr128</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 128-bit integer <code>x</code> by <code>c</code> positions to the right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L65-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr128(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 128-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x80 - c) &amp; 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | (x &gt;&gt; c)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr64"><code class="name flex">
<span>def <span class="ident">rotr64</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 64-bit integer <code>x</code> by <code>c</code> positions to the right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L72-L76" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr64(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 64-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x40 - c) &amp; 0xFFFFFFFFFFFFFFFF) | (x &gt;&gt; c)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr32"><code class="name flex">
<span>def <span class="ident">rotr32</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 32-bit integer <code>x</code> by <code>c</code> positions to the right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L79-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr32(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 32-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x20 - c) &amp; 0xFFFFFFFF) | (x &gt;&gt; c)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr16"><code class="name flex">
<span>def <span class="ident">rotr16</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 16-bit integer <code>x</code> by <code>c</code> positions to the right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L86-L90" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr16(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 16-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x10 - c) &amp; 0xFFFF) | (x &gt;&gt; c)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr8"><code class="name flex">
<span>def <span class="ident">rotr8</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the byte <code>x</code> by <code>c</code> positions to the right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L93-L97" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr8(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the byte `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x08 - c) &amp; 0xFF) | (x &gt;&gt; c)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr"><code class="name flex">
<span>def <span class="ident">rotr</span></span>(<span>n, x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the <code>n</code>-bit integer <code>x</code> by <code>c</code> positions to the right. If <code>n</code> is among the common bit
sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
used instead.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L100-L108" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr(n: int, x: int, c: int) -&gt; int:
    &#34;&#34;&#34;
    Rotate the `n`-bit integer `x` by `c` positions to the right. If `n` is among the common bit
    sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
    used instead.
    &#34;&#34;&#34;
    mask = (1 &lt;&lt; n) - 1
    c %= n
    return (x &gt;&gt; c) | (x &lt;&lt; (n - c) &amp; mask)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl"><code class="name flex">
<span>def <span class="ident">rotl</span></span>(<span>n, x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the <code>n</code>-bit integer <code>x</code> by <code>c</code> positions to the left. If <code>n</code> is among the common bit
sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
used instead.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L111-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl(n: int, x: int, c: int) -&gt; int:
    &#34;&#34;&#34;
    Rotate the `n`-bit integer `x` by `c` positions to the left. If `n` is among the common bit
    sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
    used instead.
    &#34;&#34;&#34;
    mask = (1 &lt;&lt; n) - 1
    c %= n
    return (x &gt;&gt; (n - c)) | (x &lt;&lt; c &amp; mask)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.crypto.Operation"><code class="flex name class">
<span>class <span class="ident">Operation</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Specifies whether data is currently being encrypted or decrypted.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L122-L127" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Operation(str, Enum):
    &#34;&#34;&#34;
    Specifies whether data is currently being encrypted or decrypted.
    &#34;&#34;&#34;
    Encrypt = &#39;encrypt&#39;
    Decrypt = &#39;decrypt&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.Operation.Encrypt"><code class="name">var <span class="ident">Encrypt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.Operation.Decrypt"><code class="name">var <span class="ident">Decrypt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.crypto.CipherMode"><code class="flex name class">
<span>class <span class="ident">CipherMode</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for a cipher mode of operation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L130-L183" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CipherMode(ABC):
    &#34;&#34;&#34;
    Abstract base class for a cipher mode of operation.
    &#34;&#34;&#34;

    encrypt_block: Callable[[memoryview], memoryview]
    decrypt_block: Callable[[memoryview], memoryview]
    aligned: bool = True
    _identifier: ClassVar[int]

    @abstractmethod
    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        &#34;&#34;&#34;
        Implements data encryption according to the current cipher mode and underlying cipher.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        &#34;&#34;&#34;
        Implements data decryption according to the current cipher mode and underlying cipher.
        &#34;&#34;&#34;
        raise NotImplementedError

    def apply(
        self,
        operation: Operation,
        dst: memoryview,
        src: memoryview,
        encrypt_block: Callable[[memoryview], memoryview],
        decrypt_block: Callable[[memoryview], memoryview],
        blocksize: int,
    ) -&gt; memoryview:
        &#34;&#34;&#34;
        This method is used to perform a cryptographic `refinery.lib.crypto.Operation` to a given
        source `src` and write the result to the memory at `dst` according to the current cipher
        mode. To this end, it requires the block encryption and decryption primitives of the
        underlying cipher and the current block size.
        &#34;&#34;&#34;
        self.encrypt_block = encrypt_block
        self.decrypt_block = decrypt_block
        engine: Generator[memoryview, memoryview, None] = {
            Operation.Encrypt: self.encrypt,
            Operation.Decrypt: self.decrypt,
        }[operation]()
        next(engine)
        top, rest = divmod(len(src), blocksize)
        top *= blocksize
        for k in range(0, top, blocksize):
            dst[k:k + blocksize] = engine.send(src[k:k + blocksize])
        if rest:
            dst[-rest:] = engine.send(src[-rest:])[:rest]
        engine.close()
        return dst</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CFB" href="#refinery.lib.crypto.CFB">CFB</a></li>
<li><a title="refinery.lib.crypto.CTR" href="#refinery.lib.crypto.CTR">CTR</a></li>
<li><a title="refinery.lib.crypto.ECB" href="#refinery.lib.crypto.ECB">ECB</a></li>
<li><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.CipherMode.encrypt_block"><code class="name">var <span class="ident">encrypt_block</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CipherMode.decrypt_block"><code class="name">var <span class="ident">decrypt_block</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CipherMode.aligned"><code class="name">var <span class="ident">aligned</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.CipherMode.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements data encryption according to the current cipher mode and underlying cipher.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L140-L145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
    &#34;&#34;&#34;
    Implements data encryption according to the current cipher mode and underlying cipher.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.CipherMode.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements data decryption according to the current cipher mode and underlying cipher.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L147-L152" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
    &#34;&#34;&#34;
    Implements data decryption according to the current cipher mode and underlying cipher.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.CipherMode.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, operation, dst, src, encrypt_block, decrypt_block, blocksize)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is used to perform a cryptographic <code><a title="refinery.lib.crypto.Operation" href="#refinery.lib.crypto.Operation">Operation</a></code> to a given
source <code>src</code> and write the result to the memory at <code>dst</code> according to the current cipher
mode. To this end, it requires the block encryption and decryption primitives of the
underlying cipher and the current block size.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L154-L183" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply(
    self,
    operation: Operation,
    dst: memoryview,
    src: memoryview,
    encrypt_block: Callable[[memoryview], memoryview],
    decrypt_block: Callable[[memoryview], memoryview],
    blocksize: int,
) -&gt; memoryview:
    &#34;&#34;&#34;
    This method is used to perform a cryptographic `refinery.lib.crypto.Operation` to a given
    source `src` and write the result to the memory at `dst` according to the current cipher
    mode. To this end, it requires the block encryption and decryption primitives of the
    underlying cipher and the current block size.
    &#34;&#34;&#34;
    self.encrypt_block = encrypt_block
    self.decrypt_block = decrypt_block
    engine: Generator[memoryview, memoryview, None] = {
        Operation.Encrypt: self.encrypt,
        Operation.Decrypt: self.decrypt,
    }[operation]()
    next(engine)
    top, rest = divmod(len(src), blocksize)
    top *= blocksize
    for k in range(0, top, blocksize):
        dst[k:k + blocksize] = engine.send(src[k:k + blocksize])
    if rest:
        dst[-rest:] = engine.send(src[-rest:])[:rest]
    engine.close()
    return dst</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.crypto.ECB"><code class="flex name class">
<span>class <span class="ident">ECB</span></span>
</code></dt>
<dd>
<section class="desc"><p>The Electronic Codebook (ECB) is the most simple cipher mode of operation. The underlying
cipher is applied block-wise with no additional safeguards.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L187-L205" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ECB(CipherMode):
    &#34;&#34;&#34;
    The Electronic Codebook (ECB) is the most simple cipher mode of operation. The underlying
    cipher is applied block-wise with no additional safeguards.
    &#34;&#34;&#34;

    def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        M = None
        D = self.decrypt_block
        while True:
            C = yield M
            M = D(C)

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        C = None
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(M)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.ECB.encrypt_block"><code class="name">var <span class="ident">encrypt_block</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.ECB.decrypt_block"><code class="name">var <span class="ident">decrypt_block</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.ECB.aligned"><code class="name">var <span class="ident">aligned</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.DataUnaligned"><code class="flex name class">
<span>class <span class="ident">DataUnaligned</span></span>
</code></dt>
<dd>
<section class="desc"><p>Raised when input data is unexpectedly unaligned to the current block size.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L208-L213" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DataUnaligned(ValueError):
    &#34;&#34;&#34;
    Raised when input data is unexpectedly unaligned to the current block size.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__(&#39;Data not aligned to block size.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.StatefulCipherMode"><code class="flex name class">
<span>class <span class="ident">StatefulCipherMode</span></span>
<span>(</span><span>iv)</span>
</code></dt>
<dd>
<section class="desc"><p>A subclass of <code><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></code> that holds a state while performing any of
its cryptographic <code><a title="refinery.lib.crypto.Operation" href="#refinery.lib.crypto.Operation">Operation</a></code>s.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L216-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StatefulCipherMode(CipherMode):
    &#34;&#34;&#34;
    A subclass of `refinery.lib.crypto.CipherMode` that holds a state while performing any of
    its cryptographic `refinery.lib.crypto.Operation`s.
    &#34;&#34;&#34;

    iv: BufferType
    &#34;&#34;&#34;
    The initial vector for the internal state of the cipher mode.
    &#34;&#34;&#34;

    def __init__(self, iv: BufferType):
        self.iv = iv</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CBC" href="#refinery.lib.crypto.CBC">CBC</a></li>
<li><a title="refinery.lib.crypto.OFB" href="#refinery.lib.crypto.OFB">OFB</a></li>
<li><a title="refinery.lib.crypto.PCBC" href="#refinery.lib.crypto.PCBC">PCBC</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.StatefulCipherMode.iv"><code class="name">var <span class="ident">iv</span></code></dt>
<dd>
<section class="desc"><p>The initial vector for the internal state of the cipher mode.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.CBC"><code class="flex name class">
<span>class <span class="ident">CBC</span></span>
<span>(</span><span>iv)</span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of the popular Cipher Block Chaining mode of operation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L232-L251" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CBC(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of the popular Cipher Block Chaining mode of operation.
    &#34;&#34;&#34;

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        C = self.iv
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(strxor(M, C))

    def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        S = self.iv
        M = None
        D = self.decrypt_block
        while True:
            C = yield M
            M = strxor(D(C), S)
            S = bytes(C)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></li>
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.iv" href="#refinery.lib.crypto.StatefulCipherMode.iv">iv</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.PCBC"><code class="flex name class">
<span>class <span class="ident">PCBC</span></span>
<span>(</span><span>iv)</span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of Propagating Cipher Block Chaining.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L255-L276" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PCBC(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of Propagating Cipher Block Chaining.
    &#34;&#34;&#34;

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        S = self.iv
        C = None
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(strxor(M, S))
            S = strxor(C, M)

    def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        S = self.iv
        M = None
        D = self.decrypt_block
        while True:
            C = yield M
            M = strxor(S, D(C))
            S = strxor(M, C)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></li>
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.iv" href="#refinery.lib.crypto.StatefulCipherMode.iv">iv</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.CFB"><code class="flex name class">
<span>class <span class="ident">CFB</span></span>
<span>(</span><span>iv, segment_size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Cipher Feedback Mode: <a href="https://csrc.nist.gov/publications/detail/sp/800-38a/final">https://csrc.nist.gov/publications/detail/sp/800-38a/final</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L280-L340" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CFB(CipherMode):
    &#34;&#34;&#34;
    Cipher Feedback Mode: https://csrc.nist.gov/publications/detail/sp/800-38a/final
    &#34;&#34;&#34;

    iv: BufferType
    segment_size: int
    aligned = False

    def __init__(self, iv: BufferType, segment_size: Optional[int] = None):
        if segment_size is None:
            segment_size = 8
        if segment_size % 8 != 0:
            raise NotImplementedError(&#39;segment sizes may only be multiples of 8&#39;)
        segment_size = segment_size // 8
        if len(iv) % segment_size != 0:
            raise NotImplementedError(
                F&#39;the block size {len(iv) * 8} is not an even multiple of the segment &#39;
                F&#39;size {segment_size * 8}; this is currently not supported.&#39;)
        self.segment_size = segment_size
        self.iv = iv

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        s = self.segment_size
        S = bytearray(self.iv)
        E = self.encrypt_block
        C = bytearray(len(self.iv))
        if s == 1:
            while True:
                M = yield C
                for k, m in enumerate(M):
                    C[k] = c = m ^ E(S)[0]
                    S[:-1], S[-1] = memoryview(S)[1:], c
        else:
            segments = [slice(i, i + s) for i in range(0, len(S), s)]
            while True:
                M = yield C
                for k in segments:
                    m = M[k]
                    C[k] = c = strxor(m, E(S)[:s])
                    S[:-s], S[-s:] = memoryview(S)[s:], c

    def decrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        s = self.segment_size
        S = bytearray(self.iv)
        E = self.encrypt_block
        M = bytearray(len(self.iv))
        if s == 1:
            while True:
                C = yield M
                for k, c in enumerate(C):
                    M[k] = c ^ E(S)[0]
                    S[:-1], S[-1] = memoryview(S)[1:], c
        else:
            segments = [slice(i, i + s) for i in range(0, len(S), s)]
            while True:
                C = yield M
                for k in segments:
                    c = C[k]
                    M[k] = strxor(c, E(S)[:s])
                    S[:-s], S[-s:] = memoryview(S)[s:], c</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.CFB.iv"><code class="name">var <span class="ident">iv</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CFB.segment_size"><code class="name">var <span class="ident">segment_size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CFB.aligned"><code class="name">var <span class="ident">aligned</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.OFB"><code class="flex name class">
<span>class <span class="ident">OFB</span></span>
<span>(</span><span>iv)</span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of Output Feedback Mode.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L344-L360" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class OFB(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of Output Feedback Mode.
    &#34;&#34;&#34;

    aligned = False

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        S = self.iv
        C = None
        E = self.encrypt_block
        while True:
            M = yield C
            S = E(S)
            C = strxor(M, S)

    decrypt = encrypt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></li>
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.OFB.aligned"><code class="name">var <span class="ident">aligned</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.OFB.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements data encryption according to the current cipher mode and underlying cipher.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L351-L358" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
    S = self.iv
    C = None
    E = self.encrypt_block
    while True:
        M = yield C
        S = E(S)
        C = strxor(M, S)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.iv" href="#refinery.lib.crypto.StatefulCipherMode.iv">iv</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.CTR"><code class="flex name class">
<span>class <span class="ident">CTR</span></span>
<span>(</span><span>block_size=None, counter=None, nonce=None, initial_value=0, little_endian=False)</span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of Counter mode.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L364-L436" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CTR(CipherMode):
    &#34;&#34;&#34;
    An implementation of Counter mode.
    &#34;&#34;&#34;

    counter_len: int
    prefix: BufferType
    suffix: BufferType
    initial_value: int
    little_endian: bool
    block_size: int

    aligned = False

    @property
    def byte_order(self):
        return &#39;little&#39; if self.little_endian else &#39;big&#39;

    def __init__(
        self,
        block_size: Optional[int] = None,
        counter: Optional[Dict] = None,
        nonce: Optional[BufferType] = None,
        initial_value: Optional[int] = 0,
        little_endian: bool = False
    ):
        if counter is not None:
            self.initial_value = counter.get(&#39;initial_value&#39;, initial_value)
            self.little_endian = counter.get(&#39;little_endian&#39;, little_endian)
            self.prefix = counter[&#39;prefix&#39;]
            self.suffix = counter[&#39;suffix&#39;]
            self.counter_len = counter[&#39;counter_len&#39;]
            self.block_size = self.counter_len + len(self.prefix) + len(self.suffix)
            if block_size not in {None, self.block_size}:
                raise ValueError(&#39;Information in counter object does not align with block size.&#39;)
            return
        if block_size is None:
            raise ValueError(&#39;Unable to construct CTR mode object without block_size or counter argument.&#39;)

        self.initial_value = initial_value
        self.little_endian = little_endian
        self.suffix = B&#39;&#39;
        self.block_size = block_size

        if nonce is not None:
            if len(nonce) &gt; block_size:
                raise ValueError(&#39;Nonce length exceeds block length.&#39;)
            self.counter_len = block_size - len(nonce)
            self.prefix = nonce
        else:
            self.counter_len = block_size // 2
            self.prefix = B&#39;\0&#39; * (block_size - self.counter_len)

    def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
        S = bytearray(self.block_size)
        J = slice(len(self.prefix), self.block_size - len(self.suffix))
        K = self.initial_value
        if self.prefix:
            S[:+len(self.prefix)] = self.prefix
        if self.suffix:
            S[-len(self.suffix):] = self.suffix
        C = None
        E = self.encrypt_block
        order = self.byte_order
        csize = self.counter_len
        mask = (1 &lt;&lt; (csize * 8)) - 1
        while True:
            M = yield C
            S[J] = K.to_bytes(csize, order)
            K = K + 1 &amp; mask
            C = strxor(E(S), M)

    decrypt = encrypt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.CTR.counter_len"><code class="name">var <span class="ident">counter_len</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.prefix"><code class="name">var <span class="ident">prefix</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.suffix"><code class="name">var <span class="ident">suffix</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.initial_value"><code class="name">var <span class="ident">initial_value</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.little_endian"><code class="name">var <span class="ident">little_endian</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.aligned"><code class="name">var <span class="ident">aligned</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.crypto.CTR.byte_order"><code class="name">var <span class="ident">byte_order</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L378-L380" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def byte_order(self):
    return &#39;little&#39; if self.little_endian else &#39;big&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.CTR.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements data encryption according to the current cipher mode and underlying cipher.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L417-L434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt(self) -&gt; Generator[memoryview, memoryview, None]:
    S = bytearray(self.block_size)
    J = slice(len(self.prefix), self.block_size - len(self.suffix))
    K = self.initial_value
    if self.prefix:
        S[:+len(self.prefix)] = self.prefix
    if self.suffix:
        S[-len(self.suffix):] = self.suffix
    C = None
    E = self.encrypt_block
    order = self.byte_order
    csize = self.counter_len
    mask = (1 &lt;&lt; (csize * 8)) - 1
    while True:
        M = yield C
        S[J] = K.to_bytes(csize, order)
        K = K + 1 &amp; mask
        C = strxor(E(S), M)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.CipherInterface"><code class="flex name class">
<span>class <span class="ident">CipherInterface</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for refinery's block cipher interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L439-L464" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CipherInterface(ABC):
    &#34;&#34;&#34;
    Abstract base class for refinery&#39;s block cipher interface.
    &#34;&#34;&#34;

    key_size: Container[int]
    &#34;&#34;&#34;
    A container containing all valid key sizes for this cipher.
    &#34;&#34;&#34;

    block_size: int
    &#34;&#34;&#34;
    The block size of this cipher.
    &#34;&#34;&#34;

    @abstractmethod
    def encrypt(self, M: BufferType) -&gt; BufferType: ...
    &#34;&#34;&#34;
    Data encryption according to this cipher interface.
    &#34;&#34;&#34;

    @abstractmethod
    def decrypt(self, C: BufferType) -&gt; BufferType: ...
    &#34;&#34;&#34;
    Data decryption according to this cipher interface.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.BlockCipher" href="#refinery.lib.crypto.BlockCipher">BlockCipher</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.CipherInterface.key_size"><code class="name">var <span class="ident">key_size</span></code></dt>
<dd>
<section class="desc"><p>A container containing all valid key sizes for this cipher.</p></section>
</dd>
<dt id="refinery.lib.crypto.CipherInterface.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"><p>The block size of this cipher.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.CipherInterface.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self, M)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L454-L455" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def encrypt(self, M: BufferType) -&gt; BufferType: ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.CipherInterface.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self, C)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L460-L461" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def decrypt(self, C: BufferType) -&gt; BufferType: ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.crypto.CipherObjectFactory"><code class="flex name class">
<span>class <span class="ident">CipherObjectFactory</span></span>
</code></dt>
<dd>
<section class="desc"><p>An abstract class to build <code><a title="refinery.lib.crypto.CipherInterface" href="#refinery.lib.crypto.CipherInterface">CipherInterface</a></code>s from an asortment of
cryptographic secrets and parameters.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L467-L495" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CipherObjectFactory(ABC):
    &#34;&#34;&#34;
    An abstract class to build `refinery.lib.crypto.CipherInterface`s from an asortment of
    cryptographic secrets and parameters.
    &#34;&#34;&#34;

    name: str
    key_size: Optional[Container[int]] = None
    block_size: Optional[int] = None

    @abstractmethod
    def new(
        self,
        key: BufferType,
        iv: Optional[BufferType] = None,
        counter: Optional[int] = None,
        initial_value: Optional[int] = 0,
        nonce: Optional[BufferType] = None,
        mode: Optional[str] = None,
        segment_size: Optional[int] = None,
        block_size: Optional[int] = None,
        **cipher_args
    ) -&gt; CipherInterface:
        &#34;&#34;&#34;
        Build the actual `refinery.lib.crypto.CipherInterface` from the given input parameters.
        This mimics the PyCrypto interface for new ciphers in order to make the refinery factory
        cross-compatible with that library.
        &#34;&#34;&#34;
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.BlockCipherFactory" href="#refinery.lib.crypto.BlockCipherFactory">BlockCipherFactory</a></li>
<li><a title="refinery.lib.crypto.PyCryptoFactoryWrapper" href="#refinery.lib.crypto.PyCryptoFactoryWrapper">PyCryptoFactoryWrapper</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.CipherObjectFactory.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CipherObjectFactory.key_size"><code class="name">var <span class="ident">key_size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CipherObjectFactory.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.CipherObjectFactory.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self, key, iv=None, counter=None, initial_value=0, nonce=None, mode=None, segment_size=None, block_size=None, **cipher_args)</span>
</code></dt>
<dd>
<section class="desc"><p>Build the actual <code><a title="refinery.lib.crypto.CipherInterface" href="#refinery.lib.crypto.CipherInterface">CipherInterface</a></code> from the given input parameters.
This mimics the PyCrypto interface for new ciphers in order to make the refinery factory
cross-compatible with that library.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L477-L495" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def new(
    self,
    key: BufferType,
    iv: Optional[BufferType] = None,
    counter: Optional[int] = None,
    initial_value: Optional[int] = 0,
    nonce: Optional[BufferType] = None,
    mode: Optional[str] = None,
    segment_size: Optional[int] = None,
    block_size: Optional[int] = None,
    **cipher_args
) -&gt; CipherInterface:
    &#34;&#34;&#34;
    Build the actual `refinery.lib.crypto.CipherInterface` from the given input parameters.
    This mimics the PyCrypto interface for new ciphers in order to make the refinery factory
    cross-compatible with that library.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.crypto.PyCryptoFactoryWrapper"><code class="flex name class">
<span>class <span class="ident">PyCryptoFactoryWrapper</span></span>
<span>(</span><span>module)</span>
</code></dt>
<dd>
<section class="desc"><p>Wraps a PyCrypto module as a <code><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L498-L534" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PyCryptoFactoryWrapper(CipherObjectFactory):
    &#34;&#34;&#34;
    Wraps a PyCrypto module as a `refinery.lib.crypto.CipherObjectFactory`.
    &#34;&#34;&#34;

    def __init__(self, module):
        self.module = module

    def new(self, *a, **k) -&gt; CipherInterface:
        return self.module.new(*a, **k)

    @property
    def key_size(self):
        try:
            value = self.module.key_size
        except AttributeError:
            return None
        if isinstance(value, int):
            return {value}
        return value

    @property
    def block_size(self):
        try:
            value = self.module.block_size
        except AttributeError:
            return None
        return value

    def __repr__(self):
        return repr(self.module)

    def __dir__(self):
        return dir(self.module)

    def __getattr__(self, key):
        return getattr(self.module, key)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.PyCryptoFactoryWrapper.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.crypto.PyCryptoFactoryWrapper.key_size"><code class="name">var <span class="ident">key_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L509-L517" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def key_size(self):
    try:
        value = self.module.key_size
    except AttributeError:
        return None
    if isinstance(value, int):
        return {value}
    return value</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.PyCryptoFactoryWrapper.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L519-L525" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def block_size(self):
    try:
        value = self.module.block_size
    except AttributeError:
        return None
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherObjectFactory.new" href="#refinery.lib.crypto.CipherObjectFactory.new">new</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.BlockCipherFactory"><code class="flex name class">
<span>class <span class="ident">BlockCipherFactory</span></span>
<span>(</span><span>cipher)</span>
</code></dt>
<dd>
<section class="desc"><p>A <code><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></code> for custom block ciphers.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L537-L595" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BlockCipherFactory(CipherObjectFactory):
    &#34;&#34;&#34;
    A `refinery.lib.crypto.CipherObjectFactory` for custom block ciphers.
    &#34;&#34;&#34;

    cipher: Type[BlockCipher]

    def __init__(self, cipher: Type[BlockCipher]):
        self.cipher = cipher
        self._modes = []
        for name, mode in CIPHER_MODES.items():
            setattr(self, F&#39;MODE_{name}&#39;, mode._identifier)
            self._modes.append(mode)

    def new(self, key, mode=None, **args) -&gt; CipherInterface:
        if mode is not None:
            mode = self._modes[mode]
        mode_arguments = {}
        cipher = self.cipher
        for arg in (&#39;iv&#39;, &#39;counter&#39;, &#39;initial_value&#39;, &#39;nonce&#39;, &#39;mode&#39;, &#39;segment_size&#39;):
            try:
                mode_arguments[arg] = args.pop(arg)
            except KeyError:
                pass
        if mode is CTR:
            block_size = self.block_size
            if block_size is None:
                # This happens for ciphers that do not have a fixed block size, i.e. the
                # block size is truly an instance attribute and not a class property.
                # In this case, we create a temporary cipher object and use it to obtain
                # the true block size.
                block_size = cipher(key, ECB, **args).block_size
            mode_arguments.update(block_size=block_size)
        mode = mode(**mode_arguments)
        return cipher(key, mode, **args)

    @property
    def name(self):
        return self.cipher.__name__

    @property
    def key_size(self):
        try:
            value = self.cipher.key_size
        except AttributeError:
            return None
        if isinstance(value, property):
            return None
        return value

    @property
    def block_size(self):
        try:
            value = self.cipher.block_size
        except AttributeError:
            return None
        if not isinstance(value, int):
            return None
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.BlockCipherFactory.cipher"><code class="name">var <span class="ident">cipher</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.crypto.BlockCipherFactory.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L573-L575" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def name(self):
    return self.cipher.__name__</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.BlockCipherFactory.key_size"><code class="name">var <span class="ident">key_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L577-L585" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def key_size(self):
    try:
        value = self.cipher.key_size
    except AttributeError:
        return None
    if isinstance(value, property):
        return None
    return value</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.BlockCipherFactory.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L587-L595" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def block_size(self):
    try:
        value = self.cipher.block_size
    except AttributeError:
        return None
    if not isinstance(value, int):
        return None
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherObjectFactory.new" href="#refinery.lib.crypto.CipherObjectFactory.new">new</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.BlockCipher"><code class="flex name class">
<span>class <span class="ident">BlockCipher</span></span>
<span>(</span><span>key, mode)</span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for refinery's block cipher interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L598-L651" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BlockCipher(CipherInterface, ABC):
    block_size: int
    key: BufferType
    mode: CipherMode
    key_size: Container[int]

    def __init__(self, key: BufferType, mode: Optional[CipherMode]):
        if len(key) not in self.key_size:
            raise ValueError(F&#39;The key size {len(key)} is not supported by {self.__class__.__name__.lower()}.&#39;)
        self.key = key
        self.mode = mode or ECB()

    @abstractmethod
    def block_encrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Encryption of a single block of data.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def block_decrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Decryption of a single block of data.
        &#34;&#34;&#34;
        raise NotImplementedError

    def _apply_blockwise(self, operation: Operation, data: BufferType) -&gt; BufferType:
        block_size = self.block_size
        mode = self.mode
        if len(data) % block_size != 0 and mode.aligned:
            raise DataUnaligned
        dst = src = memoryview(data)
        if dst.readonly:
            dst = bytearray(src)
        return mode.apply(
            operation,
            dst,
            src,
            self.block_encrypt,
            self.block_decrypt,
            block_size
        )

    def encrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Encrypt the input data.
        &#34;&#34;&#34;
        return self._apply_blockwise(Operation.Encrypt, data)

    def decrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Decrypt the input data.
        &#34;&#34;&#34;
        return self._apply_blockwise(Operation.Decrypt, data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherInterface" href="#refinery.lib.crypto.CipherInterface">CipherInterface</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.crypto.cipher.camellia.Camellia" href="../units/crypto/cipher/camellia.html#refinery.units.crypto.cipher.camellia.Camellia">Camellia</a></li>
<li><a title="refinery.units.crypto.cipher.chaskey.Chaskey" href="../units/crypto/cipher/chaskey.html#refinery.units.crypto.cipher.chaskey.Chaskey">Chaskey</a></li>
<li><a title="refinery.units.crypto.cipher.gost.GOST" href="../units/crypto/cipher/gost.html#refinery.units.crypto.cipher.gost.GOST">GOST</a></li>
<li><a title="refinery.units.crypto.cipher.rc5.RC5" href="../units/crypto/cipher/rc5.html#refinery.units.crypto.cipher.rc5.RC5">RC5</a></li>
<li><a title="refinery.units.crypto.cipher.rc6.RC6" href="../units/crypto/cipher/rc6.html#refinery.units.crypto.cipher.rc6.RC6">RC6</a></li>
<li><a title="refinery.units.crypto.cipher.rijndael.Rijndael" href="../units/crypto/cipher/rijndael.html#refinery.units.crypto.cipher.rijndael.Rijndael">Rijndael</a></li>
<li><a title="refinery.units.crypto.cipher.serpent.Serpent" href="../units/crypto/cipher/serpent.html#refinery.units.crypto.cipher.serpent.Serpent">Serpent</a></li>
<li><a title="refinery.units.crypto.cipher.sm4.SM4" href="../units/crypto/cipher/sm4.html#refinery.units.crypto.cipher.sm4.SM4">SM4</a></li>
<li><a title="refinery.units.crypto.cipher.speck.Speck" href="../units/crypto/cipher/speck.html#refinery.units.crypto.cipher.speck.Speck">Speck</a></li>
<li><a title="refinery.units.crypto.cipher.tea.TEABase" href="../units/crypto/cipher/tea.html#refinery.units.crypto.cipher.tea.TEABase">TEABase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.BlockCipher.key"><code class="name">var <span class="ident">key</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.BlockCipher.mode"><code class="name">var <span class="ident">mode</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.BlockCipher.block_encrypt"><code class="name flex">
<span>def <span class="ident">block_encrypt</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Encryption of a single block of data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L610-L615" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def block_encrypt(self, data: BufferType) -&gt; BufferType:
    &#34;&#34;&#34;
    Encryption of a single block of data.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.BlockCipher.block_decrypt"><code class="name flex">
<span>def <span class="ident">block_decrypt</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Decryption of a single block of data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L617-L622" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def block_decrypt(self, data: BufferType) -&gt; BufferType:
    &#34;&#34;&#34;
    Decryption of a single block of data.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.BlockCipher.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Encrypt the input data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L641-L645" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt(self, data: BufferType) -&gt; BufferType:
    &#34;&#34;&#34;
    Encrypt the input data.
    &#34;&#34;&#34;
    return self._apply_blockwise(Operation.Encrypt, data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.BlockCipher.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Decrypt the input data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/crypto.py#L647-L651" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decrypt(self, data: BufferType) -&gt; BufferType:
    &#34;&#34;&#34;
    Decrypt the input data.
    &#34;&#34;&#34;
    return self._apply_blockwise(Operation.Decrypt, data)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherInterface" href="#refinery.lib.crypto.CipherInterface">CipherInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherInterface.block_size" href="#refinery.lib.crypto.CipherInterface.block_size">block_size</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherInterface.key_size" href="#refinery.lib.crypto.CipherInterface.key_size">key_size</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="refinery.lib.crypto.strxor" href="#refinery.lib.crypto.strxor">strxor</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl128" href="#refinery.lib.crypto.rotl128">rotl128</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl64" href="#refinery.lib.crypto.rotl64">rotl64</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl32" href="#refinery.lib.crypto.rotl32">rotl32</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl16" href="#refinery.lib.crypto.rotl16">rotl16</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl8" href="#refinery.lib.crypto.rotl8">rotl8</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr128" href="#refinery.lib.crypto.rotr128">rotr128</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr64" href="#refinery.lib.crypto.rotr64">rotr64</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr32" href="#refinery.lib.crypto.rotr32">rotr32</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr16" href="#refinery.lib.crypto.rotr16">rotr16</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr8" href="#refinery.lib.crypto.rotr8">rotr8</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr" href="#refinery.lib.crypto.rotr">rotr</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl" href="#refinery.lib.crypto.rotl">rotl</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.crypto.Operation" href="#refinery.lib.crypto.Operation">Operation</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.CipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.ECB" href="#refinery.lib.crypto.ECB">ECB</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.DataUnaligned" href="#refinery.lib.crypto.DataUnaligned">DataUnaligned</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CBC" href="#refinery.lib.crypto.CBC">CBC</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.PCBC" href="#refinery.lib.crypto.PCBC">PCBC</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CFB" href="#refinery.lib.crypto.CFB">CFB</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.OFB" href="#refinery.lib.crypto.OFB">OFB</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.OFB.decrypt" href="#refinery.lib.crypto.OFB.decrypt">decrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CTR" href="#refinery.lib.crypto.CTR">CTR</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.CTR.decrypt" href="#refinery.lib.crypto.CTR.decrypt">decrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CipherInterface" href="#refinery.lib.crypto.CipherInterface">CipherInterface</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.CipherInterface.encrypt" href="#refinery.lib.crypto.CipherInterface.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherInterface.decrypt" href="#refinery.lib.crypto.CipherInterface.decrypt">decrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.CipherObjectFactory.new" href="#refinery.lib.crypto.CipherObjectFactory.new">new</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.PyCryptoFactoryWrapper" href="#refinery.lib.crypto.PyCryptoFactoryWrapper">PyCryptoFactoryWrapper</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.BlockCipherFactory" href="#refinery.lib.crypto.BlockCipherFactory">BlockCipherFactory</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.BlockCipher" href="#refinery.lib.crypto.BlockCipher">BlockCipher</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.BlockCipher.block_encrypt" href="#refinery.lib.crypto.BlockCipher.block_encrypt">block_encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.BlockCipher.block_decrypt" href="#refinery.lib.crypto.BlockCipher.block_decrypt">block_decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.BlockCipher.encrypt" href="#refinery.lib.crypto.BlockCipher.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.BlockCipher.decrypt" href="#refinery.lib.crypto.BlockCipher.decrypt">decrypt</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>