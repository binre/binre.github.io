<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>the refinery.lib.executable documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.executable</code></h1>
</header>
<section id="section-intro">
<p>This module implements an abstraction layer executable loader for PE, ELF, and MachO files.
The provided interface is the same for all executables. It powers the following units:</p>
<ul>
<li><code><a title="refinery.vsnip" href="../index.html#refinery.vsnip">vsnip</a></code></li>
<li><code><a title="refinery.vsect" href="../index.html#refinery.vsect">vsect</a></code></li>
<li><code><a title="refinery.vaddr" href="../index.html#refinery.vaddr">vaddr</a></code></li>
<li><code><a title="refinery.vmemref" href="../index.html#refinery.vmemref">vmemref</a></code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L1-L978" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
This module implements an abstraction layer executable loader for PE, ELF, and MachO files.
The provided interface is the same for all executables. It powers the following units:

- `refinery.vsnip`
- `refinery.vsect`
- `refinery.vaddr`
- `refinery.vmemref`
&#34;&#34;&#34;
from __future__ import annotations

import sys
import re
import itertools

from typing import TYPE_CHECKING, ClassVar, NamedTuple
from os import devnull as DEVNULL
from abc import ABC, abstractmethod
from enum import Enum
from functools import lru_cache
from uuid import uuid4

from macholib.MachO import load_command, MachO, MachOHeader
from pefile import PE as PEFile, SectionStructure, MACHINE_TYPE, DIRECTORY_ENTRY
from elftools.elf.elffile import ELFFile, SymbolTableSection

from refinery.lib.structures import MemoryFile
from refinery.lib.types import INF, ByteStr

if TYPE_CHECKING:
    from typing import Type, Callable, ParamSpec, TypeVar, Generator, Optional, Union, Iterable, List
    _T = TypeVar(&#39;_T&#39;)
    _P = ParamSpec(&#39;_P&#39;)


class ParsingFailure(ValueError):
    &#34;&#34;&#34;
    Exception generated for parsing errors of an input `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    def __init__(self, kind):
        super().__init__(F&#39;unable to parse input as {kind} file&#39;)


_MACHO_ARCHS = {
    1        : &#39;VAX&#39;,
    6        : &#39;MC680x0&#39;,
    7        : &#39;X86&#39;,
    16777223 : &#39;X86_64&#39;,
    10       : &#39;MC98000&#39;,
    11       : &#39;HPPA&#39;,
    12       : &#39;ARM&#39;,
    13       : &#39;MC88000&#39;,
    14       : &#39;SPARC&#39;,
    15       : &#39;I860&#39;,
    18       : &#39;POWERPC&#39;,
    16777234 : &#39;POWERPC64&#39;,
}


def align(alignment: int, value: int, down=False) -&gt; int:
    &#34;&#34;&#34;
    Given an alignment size and an integer value, compute the byte boundary to where this value
    would be aligned. By default, the next higher address that satisfies the alignment is computed;
    The optional parameter `down` can be set to `True` to instead return the next lower one.
    &#34;&#34;&#34;
    if alignment &gt;= 2:
        incomplete_chunk_count = value % alignment
        if incomplete_chunk_count &gt; 0:
            if not down:
                value += alignment - incomplete_chunk_count
            else:
                value -= incomplete_chunk_count
    return value


def exeroute(
    data           : bytearray,
    handler_elf    : Callable[_P, _T],
    handler_macho  : Callable[_P, _T],
    handler_pe     : Callable[_P, _T],
    *args,
    **kwargs
) -&gt; _T:
    &#34;&#34;&#34;
    Given some input `data` representing the raw bytes of an `refinery.lib.executable.Executable`,
    route this data to one of three handlers for the ELF, MachO, or PE format. All additional
    (keyword) arguments are forwarded to the handler. The function checks for well-known signature
    bytes and magic numbers to route the data.
    &#34;&#34;&#34;
    if data[:2] == B&#39;MZ&#39;:
        try:
            parsed = PEFile(data=data, fast_load=True)
        except Exception as E:
            raise ParsingFailure(&#39;PE&#39;) from E
        else:
            return handler_pe(parsed, *args, **kwargs)
    if data[:4] == B&#39;\x7FELF&#39;:
        try:
            parsed = ELFFile(MemoryFile(data))
        except Exception as E:
            raise ParsingFailure(&#39;ELF&#39;) from E
        else:
            return handler_elf(parsed, *args, **kwargs)
    if set(data[:4]) &lt;= {0xFE, 0xED, 0xFA, 0xCE, 0xCF}:
        class InMemoryMachO(MachO):
            def __init__(self): super().__init__(DEVNULL)
            def load(self, _): return super().load(MemoryFile(data))
        try:
            parsed = InMemoryMachO()
            assert parsed.headers
        except Exception as E:
            raise ParsingFailure(&#39;MachO&#39;) from E
        else:
            return handler_macho(parsed, *args, **kwargs)
    raise ValueError(&#39;Unknown executable format&#39;)


class Range(NamedTuple):
    &#34;&#34;&#34;
    A range of bytes specified by a lower and an upper bound. A `refinery.lib.executable.Range`
    can be subtracted from another one to return a list of ranges that are the result of
    removing the former from the latter. This operation is the only reason for using a custom
    class over the builtin `range` object, which does not support this.
    &#34;&#34;&#34;
    lower: int
    upper: int

    def range(self):
        &#34;&#34;&#34;
        Convertsion to a `range` object.
        &#34;&#34;&#34;
        return range(self.lower, self.upper)

    def slice(self):
        &#34;&#34;&#34;
        Conversion to a `slice` object.
        &#34;&#34;&#34;
        return slice(self.lower, self.upper)

    def __len__(self):
        return self.upper - self.lower

    def __contains__(self, addr: int):
        return self.lower &lt;= addr &lt; self.upper

    def __str__(self):
        return F&#39;0x{self.lower:X}:0x{self.upper:X}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;

    def __sub__(self, them: Range) -&gt; List[Range]:
        pieces = []
        if self.lower &lt; them.lower:
            pieces.append(Range(self.lower, min(them.lower, self.upper)))
        if them.upper &lt; self.upper:
            pieces.append(Range(max(self.lower, them.upper), self.upper))
        return pieces


class BoxedOffset(NamedTuple):
    &#34;&#34;&#34;
    An offset together with a range of available bytes at that location.
    &#34;&#34;&#34;
    box: Range
    position: int

    def __str__(self):
        return F&#39;0x{self.position:X} in {self.box!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;


class Location(NamedTuple):
    &#34;&#34;&#34;
    A location in an `refinery.lib.executable.Executable`. Contains `refinery.lib.executable.BoxedOffset`
    for both its physical and virtual range of bytes.
    &#34;&#34;&#34;
    physical: BoxedOffset
    virtual: BoxedOffset

    def __str__(self):
        return F&#39;V={self.virtual!s}; P={self.physical!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;


class ArchItem(NamedTuple):
    &#34;&#34;&#34;
    An item of the `refinery.lib.executable.Arch` enumeration. It is used to store the register
    size in bits for a given architecture.
    &#34;&#34;&#34;
    id: int
    pointer_size: int

    @classmethod
    def New(cls, pointer_size: int):
        return cls(uuid4(), pointer_size)


class Arch(ArchItem, Enum):
    &#34;&#34;&#34;
    An enumeration of supported architectures and their register sizes.
    &#34;&#34;&#34;
    X32 = ArchItem.New(32)
    X64 = ArchItem.New(64)
    ARM32 = ArchItem.New(32)
    ARM64 = ArchItem.New(64)
    MIPS16 = ArchItem.New(16)
    MIPS32 = ArchItem.New(32)
    MIPS64 = ArchItem.New(64)
    PPC32 = ArchItem.New(32)
    PPC64 = ArchItem.New(64)
    SPARC32 = ArchItem.New(32)
    SPARC64 = ArchItem.New(64)


class LT(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish between physical and virtual address types.
    &#34;&#34;&#34;
    PHYSICAL = &#39;offset&#39;
    VIRTUAL = &#39;address&#39;


class ET(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish various executable types.
    &#34;&#34;&#34;
    ELF = &#39;ELF&#39;
    MachO = &#39;MachO&#39;
    PE = &#39;PE&#39;
    BLOB = &#39;BLOB&#39;


class BO(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish big and little endian.
    &#34;&#34;&#34;
    BE = &#39;big&#39;
    LE = &#39;little&#39;


class Section(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a section inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    name: str
    physical: Range
    virtual: Range
    synthetic: bool

    def as_segment(self, populate_sections=False) -&gt; Segment:
        sections = [self] if populate_sections else None
        return Segment(self.physical, self.virtual, sections, self.name)

    def __str__(self):
        return str(self.as_segment())

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;


class Symbol(NamedTuple):
    address: int
    name: Optional[str] = None
    code: bool = True
    exported: bool = True
    is_entry: bool = False
    size: Optional[int] = None
    tls_index: Optional[int] = None
    type_name: Optional[str] = None
    bind_name: Optional[str] = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.code:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;


class Segment(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a segment inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    physical: Range
    virtual: Range
    sections: Optional[List[Section]]
    name: Optional[str] = None

    def as_section(self) -&gt; Section:
        if self.name is None:
            raise ValueError(&#39;Unable to convert nameless segment to section.&#39;)
        return Section(self.name, self.physical, self.virtual, False)

    def __str__(self):
        msg = F&#39;P=[{self.physical!s}];V=[{self.virtual!s}]&#39;
        if self.name is not None:
            msg = F&#39;{self.name}:{msg}&#39;
        return msg

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;


class CompartmentNotFound(LookupError):
    &#34;&#34;&#34;
    This exception is raised when `refinery.lib.executable.Executable.lookup_location` fails to
    find a `refinery.lib.executable.Segment` that contains the given location.
    &#34;&#34;&#34;
    def __init__(self, lt: LT, location: int):
        super().__init__(F&#39;Unable to find a segment that contains the {lt.value} 0x{location:X}.&#39;)
        self.location_type = lt
        self.location = location


class Executable(ABC):
    &#34;&#34;&#34;
    An abstract representation of a parsed executable in memory.
    &#34;&#34;&#34;

    _data: ByteStr
    _head: Union[PEFile, ELFFile, MachO]
    _base: Optional[int]
    _type: ET

    blob: ClassVar[bool] = False

    @classmethod
    def Load(cls: Type[_T], data: ByteStr, base: Optional[int] = None) -&gt; _T:
        &#34;&#34;&#34;
        Uses the `refinery.lib.executable.exeroute` function to parse the input data with one of
        the following specializations of this class:

        - `refinery.lib.executable.ExecutableELF`
        - `refinery.lib.executable.ExecutableMachO`
        - `refinery.lib.executable.ExecutablePE`
        &#34;&#34;&#34;
        return exeroute(
            data,
            ExecutableELF,
            ExecutableMachO,
            ExecutablePE,
            data,
            base,
        )

    def __init__(self, head: Union[PEFile, ELFFile, MachO], data: ByteStr, base: Optional[int] = None):
        self._data = data
        self._head = head
        self._base = base

    @property
    def head(self):
        &#34;&#34;&#34;
        Return the internal object representing the parsed file format header.
        &#34;&#34;&#34;
        return self._head

    @property
    def type(self):
        &#34;&#34;&#34;
        Returns the `refinery.lib.executable.ET` instance that identifies the executable type.
        &#34;&#34;&#34;
        return self._type

    def __getitem__(self, key: Union[int, slice, Range]):
        return self.read(key)

    def __contains__(self, key: Union[int, slice, Range]):
        try:
            self.read(key)
        except LookupError:
            return False
        else:
            return True

    def read(self, key: Union[int, slice, Range]) -&gt; memoryview:
        &#34;&#34;&#34;
        Read data from the binary based on a given address. If the input `key` is a single integer,
        the function reads a single byte from the given address.
        &#34;&#34;&#34;
        if isinstance(key, Range):
            key = slice(key.lower, key.upper)
        elif isinstance(key, int):
            key = slice(key, key + 1, 1)
        if key.start is None:
            raise LookupError(R&#39;Slice indices with unspecified start are not supported.&#39;)
        if key.stop is not None and key.stop &lt; key.start:
            raise LookupError(R&#39;The slice end must lie after the slice start.&#39;)

        box = self.location_from_address(key.start)

        if key.stop is None:
            end = box.physical.box.upper
        elif key.stop &lt;= box.virtual.box.upper:
            end = box.physical.position + (key.stop - key.start)
        else:
            raise LookupError(F&#39;The end address 0x{key.stop:X} is beyond the section end 0x{box.virtual.box.upper:X}.&#39;)

        return self.data[box.physical.position:end]

    @staticmethod
    def ascii(string: Union[str, ByteStr]) -&gt; str:
        &#34;&#34;&#34;
        If the input `string` is a `str` instance, the function returns the input value. Byte
        strings are truncated to the first occurrence of a null byte and then decoded using
        the `latin-1` codec.
        &#34;&#34;&#34;
        if isinstance(string, str):
            return string
        for k, b in enumerate(string):
            if b == 0:
                string = string[:k]
                break
        return string.decode(&#39;latin-1&#39;)

    def rebase_usr_to_img(self, addr: int) -&gt; int:
        return addr - self.base + self.image_defined_base()

    def rebase_img_to_usr(self, addr: int) -&gt; int:
        return addr - self.image_defined_base() + self.base

    @property
    def base(self) -&gt; int:
        &#34;&#34;&#34;
        Return the base address when mapped to memory. This is either the value passed to the
        constructor, or `refinery.lib.exectuable.Executable.image_defined_base`.
        &#34;&#34;&#34;
        if self._base is None:
            return self.image_defined_base()
        return self._base

    @base.setter
    def base(self, value: int):
        self._base = value

    @property
    def data(self) -&gt; memoryview:
        &#34;&#34;&#34;
        Return a (readonly) view to the raw bytes of the executable image.
        &#34;&#34;&#34;
        view = memoryview(self._data)
        if sys.version_info &gt;= (3, 8):
            view = view.toreadonly()
        return view

    @property
    def pointer_size(self) -&gt; int:
        &#34;&#34;&#34;
        Return the size of a pointer in bits. Depends on `refinery.lib.executable.Executable.arch`.
        &#34;&#34;&#34;
        return self.arch().pointer_size

    def location_from_address(self, address: int) -&gt; Location:
        &#34;&#34;&#34;
        Return a `refinery.lib.executable.Location` from the given address.
        &#34;&#34;&#34;
        return self.lookup_location(address, LT.VIRTUAL)

    def location_from_offset(self, offset: int) -&gt; Location:
        &#34;&#34;&#34;
        Return a `refinery.lib.executable.Location` from the given file offset.
        &#34;&#34;&#34;
        return self.lookup_location(offset, LT.PHYSICAL)

    def image_defined_size(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the size of the executable on disk.
        &#34;&#34;&#34;
        size = 0
        for segment in self.segments():
            size = max(size, segment.physical.upper)
        for section in self.sections():
            size = max(size, section.physical.upper)
        return size

    def image_defined_address_space(self) -&gt; Range:
        &#34;&#34;&#34;
        Returns the size of the executalbe in memory.
        &#34;&#34;&#34;
        upper = 0
        lower = INF
        for segment in self.segments():
            upper = max(upper, segment.virtual.upper)
            lower = min(lower, segment.virtual.lower)
        for section in self.sections():
            upper = max(upper, section.virtual.upper)
            lower = min(lower, section.virtual.lower)
        if upper &lt; lower:
            raise RuntimeError(F&#39;The computed address space upper bound 0x{upper:X} is less than the computed lower bound 0x{lower:X}.&#39;)
        return Range(lower, upper)

    def lookup_location(self, location: int, lt: LT) -&gt; Location:
        &#34;&#34;&#34;
        For a address or file offset, compute the corresponding `refinery.lib.executable.Location`.
        &#34;&#34;&#34;
        for part in itertools.chain(self.sections(), self.segments()):
            phys = part.physical
            virt = part.virtual
            if lt is LT.PHYSICAL and location in phys:
                return Location(
                    BoxedOffset(phys, location),
                    BoxedOffset(virt, virt.lower + location - phys.lower)
                )
            if lt is LT.VIRTUAL and location in virt:
                return Location(
                    BoxedOffset(phys, phys.lower + location - virt.lower),
                    BoxedOffset(virt, location)
                )
        else:
            raise CompartmentNotFound(lt, location)

    @abstractmethod
    def _symbols(self) -&gt; Generator[Symbol, None, None]:
        ...

    def symbols(self) -&gt; Generator[Symbol, None, None]:
        &#34;&#34;&#34;
        Generates a list of symbols in the executable.
        &#34;&#34;&#34;
        for symbol in self._symbols():
            if symbol.address in self:
                yield symbol

    @abstractmethod
    def byte_order(self) -&gt; BO:
        &#34;&#34;&#34;
        The byte order used by the architecture of this executable.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def image_defined_base(self) -&gt; int:
        &#34;&#34;&#34;
        The image defined base address when mapped to memory.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def arch(self) -&gt; Arch:
        &#34;&#34;&#34;
        The architecture for which this executable was built.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def _sections(self) -&gt; Generator[Section, None, None]:
        ...

    @abstractmethod
    def _segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        ...

    def segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        &#34;&#34;&#34;
        An iterable of all `refinery.lib.executable.Segment`s in this executable.
        &#34;&#34;&#34;
        yield from self._segments(populate_sections=populate_sections)

    def sections(self) -&gt; Generator[Section, None, None]:
        &#34;&#34;&#34;
        An iterable of all `refinery.lib.executable.Section`s in this executable.
        &#34;&#34;&#34;
        ib = self.image_defined_base()
        missing = [Range(0, len(self._data))]
        offsets = {}
        for section in self._sections():
            missing = [piece for patch in missing for piece in patch - section.physical]
            offsets[section.physical.lower] = section.virtual.lower
            yield section
        if not missing:
            return
        offsets.setdefault(0, ib)
        for gap in missing:
            p_floor = min((k for k in offsets if k &lt;= gap.lower), key=lambda p: p - gap.lower)
            v_floor = offsets[p_floor]
            v_lower = v_floor + (gap.lower - p_floor)
            v_upper = v_lower + len(gap)
            if gap.lower == 0:
                name = R&#39;synthesized/.header&#39;
            elif gap.upper == len(self._data):
                name = R&#39;synthesized/.overlay&#39;
            elif any(self._data[gap.slice()]):
                name = F&#39;synthesized/.gap-{gap.lower:08X}-{gap.upper:08X}&#39;
            else:
                name = F&#39;synthesized/.zeros-{gap.lower:08X}&#39;
            yield Section(name, gap, Range(v_lower, v_upper), True)


class ExecutableCodeBlob(Executable):
    &#34;&#34;&#34;
    A dummy specialization of `refinery.lib.executable.Executable` that represents an unstructured
    blob of (shell)code. All information that would usually be obtained from a file header must be
    provided in the constructor for this object.
    &#34;&#34;&#34;

    _head: Type[None] = None
    _type = ET.BLOB
    _byte_order: BO
    _arch: Arch

    blob = True

    def __init__(self, data, base=None, arch: Arch = Arch.X32, byte_order: BO = BO.LE):
        super().__init__(None, data, base)
        self._byte_order = byte_order
        self._arch = arch

    def image_defined_base(self) -&gt; int:
        return 0

    def byte_order(self) -&gt; BO:
        return self._byte_order

    def arch(self) -&gt; Arch:
        return self._arch

    def _symbols(self) -&gt; Generator[Symbol, None, None]:
        yield Symbol(0, is_entry=True)

    def _sections(self) -&gt; Generator[Section, None, None]:
        v = Range(self.base, self.base + len(self.data))
        p = Range(0, len(self.data))
        yield Section(&#39;blob&#39;, p, v, False)

    def _segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        for s in self.sections():
            yield s.as_segment(populate_sections=populate_sections)


class ExecutablePE(Executable):
    &#34;&#34;&#34;
    A Windows Portable Executable (PE) file.
    &#34;&#34;&#34;

    _head: PEFile
    _type = ET.PE

    def image_defined_base(self) -&gt; int:
        return self._head.OPTIONAL_HEADER.ImageBase

    def image_defined_size(self, overlay=True, sections=True, directories=True, certificate=True, memdump=False) -&gt; int:
        &#34;&#34;&#34;
        This fuction determines the size of a PE file, optionally taking into account the
        pefile module overlay computation, section information, data directory information,
        and certificate entries.
        &#34;&#34;&#34;
        pe = self._head

        overlay_value = overlay and pe.get_overlay_data_start_offset() or 0
        sections_value = sections and super().image_defined_size() or 0
        memdump_value = memdump and self.image_defined_address_space().upper or 0
        cert_entry = pe.OPTIONAL_HEADER.DATA_DIRECTORY[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_SECURITY&#39;]]

        if directories:
            directories_value = max((
                pe.get_offset_from_rva(d.VirtualAddress) + d.Size
                for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY
                if d.name != &#39;IMAGE_DIRECTORY_ENTRY_SECURITY&#39;
            ), default=0)
            if certificate:
                # The certificate overlay is given as a file offset
                # rather than a virtual address.
                cert_value = cert_entry.VirtualAddress + cert_entry.Size
            else:
                cert_value = 0
            directories_value = max(directories_value, cert_value)
        else:
            directories_value = 0

        return max(
            overlay_value,
            sections_value,
            directories_value,
            memdump_value
        )

    def _sections(self) -&gt; Generator[Section, None, None]:
        sections: Iterable[SectionStructure] = iter(self._head.sections)
        ib = self.image_defined_base()
        for section in sections:
            p_lower = section.PointerToRawData
            p_upper = p_lower + section.SizeOfRawData
            v_lower = section.VirtualAddress + ib
            v_lower = self.rebase_img_to_usr(v_lower)
            v_upper = v_lower + section.Misc_VirtualSize
            p = Range(p_lower, p_upper)
            v = Range(v_lower, v_upper)
            yield Section(self.ascii(section.Name), p, v, False)

    def _segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        for section in self.sections():
            yield section.as_segment(populate_sections)

    def arch(self) -&gt; Arch:
        arch = self._head.FILE_HEADER.Machine
        arch = MACHINE_TYPE[arch]
        try:
            return {
                &#39;IMAGE_FILE_MACHINE_I386&#39;   : Arch.X32,
                &#39;IMAGE_FILE_MACHINE_AMD64&#39;  : Arch.X64,
                &#39;IMAGE_FILE_MACHINE_ARM&#39;    : Arch.ARM32,
                &#39;IMAGE_FILE_MACHINE_THUMB&#39;  : Arch.ARM32,
                &#39;IMAGE_FILE_MACHINE_ARMNT&#39;  : Arch.ARM64,
                &#39;IMAGE_FILE_MACHINE_MIPS16&#39; : Arch.MIPS16,
            }[arch]
        except KeyError:
            raise LookupError(F&#39;Unsupported architecture: {arch}&#39;)

    def byte_order(self) -&gt; BO:
        return BO.LE

    def _symbols(self) -&gt; Generator[Symbol, None, None]:
        base = self.image_defined_base()
        head = self._head

        yield Symbol(head.OPTIONAL_HEADER.AddressOfEntryPoint + base, is_entry=True)

        head.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_TLS&#39;],
        ])

        try:
            tls = head.DIRECTORY_ENTRY_TLS
        except AttributeError:
            pass
        else:
            callback_array_rva = tls.struct.AddressOfCallBacks - base
            ps = self.pointer_size // 8
            for k in itertools.count():
                if 0 == (cb := int.from_bytes(head.get_data(callback_array_rva + ps * k, ps), self.byte_order())):
                    break
                yield Symbol(cb, F&#39;TlsCallback{k}&#39;, tls_index=k)

        try:
            exports = head.DIRECTORY_ENTRY_EXPORT.symbols
        except AttributeError:
            return
        for exp in exports:
            name = exp.name
            if not name:
                continue
            yield Symbol(exp.address + base, name.decode(&#39;ascii&#39;))

        for itype in [&#39;IMPORT&#39;, &#39;DELAY_IMPORT&#39;]:
            try:
                imports = getattr(head, F&#39;DIRECTORY_ENTRY_{itype}&#39;).imports
            except AttributeError:
                continue
            for idd in imports:
                dll: str = idd.dll.decode(&#39;ascii&#39;)
                if dll.lower().endswith(&#39;.dll&#39;):
                    dll = dll[:-4]
                for imp in idd.imports:
                    if name := imp.name:
                        name = name.decode(&#39;ascii&#39;)
                        yield Symbol(imp.address, name, exported=False)


class ExecutableELF(Executable):
    &#34;&#34;&#34;
    A file in Executable and Linkable Format (ELF).
    &#34;&#34;&#34;

    _head: ELFFile
    _type = ET.ELF

    @lru_cache(maxsize=1)
    def image_defined_base(self) -&gt; int:
        return min(self._pt_load(), default=0)

    @lru_cache(maxsize=1)
    def _pt_load(self):
        PT_LOAD = {}
        if not self._head.num_segments():
            raise LookupError(&#39;The elftools parser did not find any segments in this file.&#39;)
        for segment in self._head.iter_segments():
            if segment.header.p_type == &#39;PT_LOAD&#39;:
                PT_LOAD[segment.header.p_vaddr] = segment
        if not PT_LOAD:
            raise LookupError(&#39;Could not find any PT_LOAD segment.&#39;)
        return PT_LOAD

    def _convert_section(self, section) -&gt; Section:
        p_lower = section[&#39;sh_offset&#39;]
        v_lower = section[&#39;sh_addr&#39;]
        v_lower = self.rebase_img_to_usr(v_lower)
        v_upper = v_lower + align(section[&#39;sh_addralign&#39;], section.data_size)
        p_upper = p_lower + section.data_size
        return Section(self.ascii(section.name), Range(p_lower, p_upper), Range(v_lower, v_upper), False)

    def _sections(self) -&gt; Generator[Section, None, None]:
        for section in self._head.iter_sections():
            if section.is_null():
                continue
            yield self._convert_section(section)

    def _segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        for segment in self._head.iter_segments():
            header = segment.header
            p_lower = header.p_offset
            v_lower = header.p_vaddr
            v_lower = self.rebase_img_to_usr(v_lower)
            p_upper = p_lower + header.p_filesz
            v_upper = v_lower + header.p_memsz
            if not populate_sections:
                sections = None
            else:
                sections = [
                    self._convert_section(section)
                    for section in self._head.iter_sections()
                    if segment.section_in_segment(section)
                ]
            yield Segment(Range(p_lower, p_upper), Range(v_lower, v_upper), sections)

    def arch(self) -&gt; Arch:
        arch = self._head.header[&#39;e_machine&#39;]
        try:
            return {
                &#39;EM_SPARC&#39;   : Arch.SPARC32,
                &#39;EM_SPARCV9&#39; : Arch.SPARC64,
                &#39;EM_386&#39;     : Arch.X32,
                &#39;EM_X86_64&#39;  : Arch.X64,
                &#39;EM_MIPS&#39;    : Arch.MIPS32,
                &#39;EM_PPC&#39;     : Arch.PPC32,
                &#39;EM_PPC64&#39;   : Arch.PPC64,
                &#39;EM_ARM&#39;     : Arch.ARM32,
            }[arch]
        except KeyError:
            raise LookupError(F&#39;Unsupported architecture: {arch}&#39;)

    def byte_order(self) -&gt; BO:
        return BO.LE if self.head.little_endian else BO.BE

    def _symbols(self) -&gt; Generator[Symbol, None, None]:
        ee = self._head.header[&#39;e_entry&#39;]
        symbols = {ee: Symbol(ee, is_entry=True)}
        try:
            sections = list(self._head.iter_sections())
        except Exception:
            return
        for section in sections:
            if not isinstance(section, SymbolTableSection):
                continue
            if section[&#39;sh_entsize&#39;] == 0:
                continue
            for sym in section.iter_symbols():
                st_name = sym.name
                if sym[&#39;st_info&#39;][&#39;type&#39;] == &#39;STT_SECTION&#39; and sym[&#39;st_shndx&#39;] &lt; len(sections) and sym[&#39;st_name&#39;] == 0:
                    try:
                        st_name = self._head.get_section(sym[&#39;st_shndx&#39;]).name
                    except Exception:
                        pass
                st_addr = sym[&#39;st_value&#39;]
                st_name = re.sub(&#39;[\x01-\x1f]+&#39;, &#39;&#39;, st_name)
                st_type = sym[&#39;st_info&#39;][&#39;type&#39;]
                st_bind = sym[&#39;st_info&#39;][&#39;bind&#39;]
                st_size = sym[&#39;st_size&#39;]
                insert = False
                try:
                    prev = symbols[st_addr]
                except KeyError:
                    insert = True
                else:
                    insert = prev.name is None or len(prev.name) &lt; len(st_name)
                if insert:
                    symbols[st_addr] = Symbol(
                        st_addr,
                        st_name,
                        st_type == &#39;STT_FUNC&#39;,
                        st_bind == &#39;STB_GLOBAL&#39;,
                        size=st_size,
                        type_name=st_type,
                        bind_name=st_bind,
                    )
        for addr in sorted(symbols):
            yield symbols[addr]


class ExecutableMachO(Executable):
    &#34;&#34;&#34;
    A MachO-executable.
    &#34;&#34;&#34;

    _head: MachO
    _type = ET.MachO

    def _symbols(self) -&gt; Generator[Symbol, None, None]:
        raise NotImplementedError

    @lru_cache(maxsize=1)
    def image_defined_base(self) -&gt; int:
        return min(seg.vmaddr for seg, _ in self._macho_segments() if seg.vmaddr &gt; 0)

    def _macho_segments(self):
        headers: List[MachOHeader] = self._head.headers
        for header in headers:
            for cmd, segment, sections in header.commands:
                cmd: load_command
                if not cmd.get_cmd_name().startswith(&#39;LC_SEGMENT&#39;):
                    continue
                if segment.filesize &lt;= 0:
                    continue
                yield segment, sections

    def _segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        for segment, sections in self._macho_segments():
            v_lower = segment.vmaddr
            v_lower = self.rebase_img_to_usr(v_lower)
            p_lower = segment.fileoff
            v_upper = v_lower + segment.vmsize
            p_upper = p_lower + segment.filesize
            segment_name = self.ascii(segment.segname)
            if not populate_sections:
                sections = None
            else:
                sections = [
                    self._convert_section(section, segment_name)
                    for section in sections
                ]
            yield Segment(
                Range(p_lower, p_upper),
                Range(v_lower, v_upper),
                sections,
                segment_name
            )

    def _sections(self) -&gt; Generator[Section, None, None]:
        for segment in self.segments(populate_sections=True):
            yield segment.as_section()
            yield from segment.sections

    def _convert_section(self, section, segment: str) -&gt; Section:
        name = self.ascii(section.sectname)
        p_lower = section.offset
        v_lower = section.addr
        v_lower = self.rebase_img_to_usr(v_lower)
        p_upper = p_lower + section.size
        v_upper = v_lower + align(section.align, section.size)
        return Section(F&#39;{segment}/{name}&#39;, Range(p_lower, p_upper), Range(v_lower, v_upper), False)

    def arch(self) -&gt; Arch:
        cputype = self._head.headers[0].header.cputype
        try:
            arch = _MACHO_ARCHS[cputype]
        except KeyError:
            arch = F&#39;UNKNOWN(0x{cputype:X})&#39;
        try:
            return {
                &#39;X86&#39;       : Arch.X32,
                &#39;X86_64&#39;    : Arch.X64,
                &#39;ARM&#39;       : Arch.ARM32,
                &#39;SPARC&#39;     : Arch.SPARC32,
                &#39;POWERPC&#39;   : Arch.PPC32,
                &#39;POWERPC64&#39; : Arch.PPC64,
            }[arch]
        except KeyError:
            raise LookupError(F&#39;Unsupported architecture: {arch}&#39;)

    def byte_order(self) -&gt; BO:
        headers: List[MachOHeader] = self._head.headers
        return {
            &#39;&lt;&#39;: BO.LE,
            &#39;&gt;&#39;: BO.BE,
        }[headers[0].endian]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.executable.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>alignment, value, down=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Given an alignment size and an integer value, compute the byte boundary to where this value
would be aligned. By default, the next higher address that satisfies the alignment is computed;
The optional parameter <code>down</code> can be set to <code>True</code> to instead return the next lower one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L62-L75" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def align(alignment: int, value: int, down=False) -&gt; int:
    &#34;&#34;&#34;
    Given an alignment size and an integer value, compute the byte boundary to where this value
    would be aligned. By default, the next higher address that satisfies the alignment is computed;
    The optional parameter `down` can be set to `True` to instead return the next lower one.
    &#34;&#34;&#34;
    if alignment &gt;= 2:
        incomplete_chunk_count = value % alignment
        if incomplete_chunk_count &gt; 0:
            if not down:
                value += alignment - incomplete_chunk_count
            else:
                value -= incomplete_chunk_count
    return value</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.exeroute"><code class="name flex">
<span>def <span class="ident">exeroute</span></span>(<span>data, handler_elf, handler_macho, handler_pe, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Given some input <code>data</code> representing the raw bytes of an <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code>,
route this data to one of three handlers for the ELF, MachO, or PE format. All additional
(keyword) arguments are forwarded to the handler. The function checks for well-known signature
bytes and magic numbers to route the data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L78-L117" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def exeroute(
    data           : bytearray,
    handler_elf    : Callable[_P, _T],
    handler_macho  : Callable[_P, _T],
    handler_pe     : Callable[_P, _T],
    *args,
    **kwargs
) -&gt; _T:
    &#34;&#34;&#34;
    Given some input `data` representing the raw bytes of an `refinery.lib.executable.Executable`,
    route this data to one of three handlers for the ELF, MachO, or PE format. All additional
    (keyword) arguments are forwarded to the handler. The function checks for well-known signature
    bytes and magic numbers to route the data.
    &#34;&#34;&#34;
    if data[:2] == B&#39;MZ&#39;:
        try:
            parsed = PEFile(data=data, fast_load=True)
        except Exception as E:
            raise ParsingFailure(&#39;PE&#39;) from E
        else:
            return handler_pe(parsed, *args, **kwargs)
    if data[:4] == B&#39;\x7FELF&#39;:
        try:
            parsed = ELFFile(MemoryFile(data))
        except Exception as E:
            raise ParsingFailure(&#39;ELF&#39;) from E
        else:
            return handler_elf(parsed, *args, **kwargs)
    if set(data[:4]) &lt;= {0xFE, 0xED, 0xFA, 0xCE, 0xCF}:
        class InMemoryMachO(MachO):
            def __init__(self): super().__init__(DEVNULL)
            def load(self, _): return super().load(MemoryFile(data))
        try:
            parsed = InMemoryMachO()
            assert parsed.headers
        except Exception as E:
            raise ParsingFailure(&#39;MachO&#39;) from E
        else:
            return handler_macho(parsed, *args, **kwargs)
    raise ValueError(&#39;Unknown executable format&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.executable.ParsingFailure"><code class="flex name class">
<span>class <span class="ident">ParsingFailure</span></span>
<span>(</span><span>kind)</span>
</code></dt>
<dd>
<section class="desc"><p>Exception generated for parsing errors of an input <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L38-L43" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ParsingFailure(ValueError):
    &#34;&#34;&#34;
    Exception generated for parsing errors of an input `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    def __init__(self, kind):
        super().__init__(F&#39;unable to parse input as {kind} file&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.executable.Range"><code class="flex name class">
<span>class <span class="ident">Range</span></span>
<span>(</span><span>lower, upper)</span>
</code></dt>
<dd>
<section class="desc"><p>A range of bytes specified by a lower and an upper bound. A <code><a title="refinery.lib.executable.Range" href="#refinery.lib.executable.Range">Range</a></code>
can be subtracted from another one to return a list of ranges that are the result of
removing the former from the latter. This operation is the only reason for using a custom
class over the builtin <code>range</code> object, which does not support this.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L120-L160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Range(NamedTuple):
    &#34;&#34;&#34;
    A range of bytes specified by a lower and an upper bound. A `refinery.lib.executable.Range`
    can be subtracted from another one to return a list of ranges that are the result of
    removing the former from the latter. This operation is the only reason for using a custom
    class over the builtin `range` object, which does not support this.
    &#34;&#34;&#34;
    lower: int
    upper: int

    def range(self):
        &#34;&#34;&#34;
        Convertsion to a `range` object.
        &#34;&#34;&#34;
        return range(self.lower, self.upper)

    def slice(self):
        &#34;&#34;&#34;
        Conversion to a `slice` object.
        &#34;&#34;&#34;
        return slice(self.lower, self.upper)

    def __len__(self):
        return self.upper - self.lower

    def __contains__(self, addr: int):
        return self.lower &lt;= addr &lt; self.upper

    def __str__(self):
        return F&#39;0x{self.lower:X}:0x{self.upper:X}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;

    def __sub__(self, them: Range) -&gt; List[Range]:
        pieces = []
        if self.lower &lt; them.lower:
            pieces.append(Range(self.lower, min(them.lower, self.upper)))
        if them.upper &lt; self.upper:
            pieces.append(Range(max(self.lower, them.upper), self.upper))
        return pieces</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Range.lower"><code class="name">var <span class="ident">lower</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.lib.executable.Range.upper"><code class="name">var <span class="ident">upper</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.Range.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Convertsion to a <code>range</code> object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L130-L134" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def range(self):
    &#34;&#34;&#34;
    Convertsion to a `range` object.
    &#34;&#34;&#34;
    return range(self.lower, self.upper)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Range.slice"><code class="name flex">
<span>def <span class="ident">slice</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Conversion to a <code>slice</code> object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L136-L140" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def slice(self):
    &#34;&#34;&#34;
    Conversion to a `slice` object.
    &#34;&#34;&#34;
    return slice(self.lower, self.upper)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.BoxedOffset"><code class="flex name class">
<span>class <span class="ident">BoxedOffset</span></span>
<span>(</span><span>box, position)</span>
</code></dt>
<dd>
<section class="desc"><p>An offset together with a range of available bytes at that location.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L163-L174" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BoxedOffset(NamedTuple):
    &#34;&#34;&#34;
    An offset together with a range of available bytes at that location.
    &#34;&#34;&#34;
    box: Range
    position: int

    def __str__(self):
        return F&#39;0x{self.position:X} in {self.box!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.BoxedOffset.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.lib.executable.BoxedOffset.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
<span>(</span><span>physical, virtual)</span>
</code></dt>
<dd>
<section class="desc"><p>A location in an <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code>. Contains <code><a title="refinery.lib.executable.BoxedOffset" href="#refinery.lib.executable.BoxedOffset">BoxedOffset</a></code>
for both its physical and virtual range of bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L177-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Location(NamedTuple):
    &#34;&#34;&#34;
    A location in an `refinery.lib.executable.Executable`. Contains `refinery.lib.executable.BoxedOffset`
    for both its physical and virtual range of bytes.
    &#34;&#34;&#34;
    physical: BoxedOffset
    virtual: BoxedOffset

    def __str__(self):
        return F&#39;V={self.virtual!s}; P={self.physical!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Location.physical"><code class="name">var <span class="ident">physical</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.lib.executable.Location.virtual"><code class="name">var <span class="ident">virtual</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.ArchItem"><code class="flex name class">
<span>class <span class="ident">ArchItem</span></span>
<span>(</span><span>id, pointer_size)</span>
</code></dt>
<dd>
<section class="desc"><p>An item of the <code><a title="refinery.lib.executable.Arch" href="#refinery.lib.executable.Arch">Arch</a></code> enumeration. It is used to store the register
size in bits for a given architecture.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L192-L202" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ArchItem(NamedTuple):
    &#34;&#34;&#34;
    An item of the `refinery.lib.executable.Arch` enumeration. It is used to store the register
    size in bits for a given architecture.
    &#34;&#34;&#34;
    id: int
    pointer_size: int

    @classmethod
    def New(cls, pointer_size: int):
        return cls(uuid4(), pointer_size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.Arch" href="#refinery.lib.executable.Arch">Arch</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.executable.ArchItem.New"><code class="name flex">
<span>def <span class="ident">New</span></span>(<span>pointer_size)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L200-L202" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def New(cls, pointer_size: int):
    return cls(uuid4(), pointer_size)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.ArchItem.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.lib.executable.ArchItem.pointer_size"><code class="name">var <span class="ident">pointer_size</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Arch"><code class="flex name class">
<span>class <span class="ident">Arch</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration of supported architectures and their register sizes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L205-L219" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Arch(ArchItem, Enum):
    &#34;&#34;&#34;
    An enumeration of supported architectures and their register sizes.
    &#34;&#34;&#34;
    X32 = ArchItem.New(32)
    X64 = ArchItem.New(64)
    ARM32 = ArchItem.New(32)
    ARM64 = ArchItem.New(64)
    MIPS16 = ArchItem.New(16)
    MIPS32 = ArchItem.New(32)
    MIPS64 = ArchItem.New(64)
    PPC32 = ArchItem.New(32)
    PPC64 = ArchItem.New(64)
    SPARC32 = ArchItem.New(32)
    SPARC64 = ArchItem.New(64)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.ArchItem" href="#refinery.lib.executable.ArchItem">ArchItem</a></li>
<li>builtins.tuple</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.Arch.X32"><code class="name">var <span class="ident">X32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.X64"><code class="name">var <span class="ident">X64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.ARM32"><code class="name">var <span class="ident">ARM32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.ARM64"><code class="name">var <span class="ident">ARM64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.MIPS16"><code class="name">var <span class="ident">MIPS16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.MIPS32"><code class="name">var <span class="ident">MIPS32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.MIPS64"><code class="name">var <span class="ident">MIPS64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.PPC32"><code class="name">var <span class="ident">PPC32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.PPC64"><code class="name">var <span class="ident">PPC64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.SPARC32"><code class="name">var <span class="ident">SPARC32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.SPARC64"><code class="name">var <span class="ident">SPARC64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.executable.ArchItem" href="#refinery.lib.executable.ArchItem">ArchItem</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.executable.ArchItem.id" href="#refinery.lib.executable.ArchItem.id">id</a></code></li>
<li><code><a title="refinery.lib.executable.ArchItem.pointer_size" href="#refinery.lib.executable.ArchItem.pointer_size">pointer_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.executable.LT"><code class="flex name class">
<span>class <span class="ident">LT</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration to distinguish between physical and virtual address types.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L222-L227" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LT(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish between physical and virtual address types.
    &#34;&#34;&#34;
    PHYSICAL = &#39;offset&#39;
    VIRTUAL = &#39;address&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.LT.PHYSICAL"><code class="name">var <span class="ident">PHYSICAL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.LT.VIRTUAL"><code class="name">var <span class="ident">VIRTUAL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.ET"><code class="flex name class">
<span>class <span class="ident">ET</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration to distinguish various executable types.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L230-L237" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ET(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish various executable types.
    &#34;&#34;&#34;
    ELF = &#39;ELF&#39;
    MachO = &#39;MachO&#39;
    PE = &#39;PE&#39;
    BLOB = &#39;BLOB&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.ET.ELF"><code class="name">var <span class="ident">ELF</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.ET.MachO"><code class="name">var <span class="ident">MachO</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.ET.PE"><code class="name">var <span class="ident">PE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.ET.BLOB"><code class="name">var <span class="ident">BLOB</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.BO"><code class="flex name class">
<span>class <span class="ident">BO</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration to distinguish big and little endian.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L240-L245" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BO(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish big and little endian.
    &#34;&#34;&#34;
    BE = &#39;big&#39;
    LE = &#39;little&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.BO.BE"><code class="name">var <span class="ident">BE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.BO.LE"><code class="name">var <span class="ident">LE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Section"><code class="flex name class">
<span>class <span class="ident">Section</span></span>
<span>(</span><span>name, physical, virtual, synthetic)</span>
</code></dt>
<dd>
<section class="desc"><p>An abstract representation of a section inside an <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L248-L265" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Section(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a section inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    name: str
    physical: Range
    virtual: Range
    synthetic: bool

    def as_segment(self, populate_sections=False) -&gt; Segment:
        sections = [self] if populate_sections else None
        return Segment(self.physical, self.virtual, sections, self.name)

    def __str__(self):
        return str(self.as_segment())

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Section.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.lib.executable.Section.physical"><code class="name">var <span class="ident">physical</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="refinery.lib.executable.Section.virtual"><code class="name">var <span class="ident">virtual</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="refinery.lib.executable.Section.synthetic"><code class="name">var <span class="ident">synthetic</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.Section.as_segment"><code class="name flex">
<span>def <span class="ident">as_segment</span></span>(<span>self, populate_sections=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L257-L259" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def as_segment(self, populate_sections=False) -&gt; Segment:
    sections = [self] if populate_sections else None
    return Segment(self.physical, self.virtual, sections, self.name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Symbol"><code class="flex name class">
<span>class <span class="ident">Symbol</span></span>
<span>(</span><span>address, name=None, code=True, exported=True, is_entry=False, size=None, tls_index=None, type_name=None, bind_name=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Symbol(address, name, code, exported, is_entry, size, tls_index, type_name, bind_name)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L268-L288" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Symbol(NamedTuple):
    address: int
    name: Optional[str] = None
    code: bool = True
    exported: bool = True
    is_entry: bool = False
    size: Optional[int] = None
    tls_index: Optional[int] = None
    type_name: Optional[str] = None
    bind_name: Optional[str] = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.code:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Symbol.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.lib.executable.Symbol.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="refinery.lib.executable.Symbol.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="refinery.lib.executable.Symbol.exported"><code class="name">var <span class="ident">exported</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
<dt id="refinery.lib.executable.Symbol.is_entry"><code class="name">var <span class="ident">is_entry</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 4</p></section>
</dd>
<dt id="refinery.lib.executable.Symbol.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 5</p></section>
</dd>
<dt id="refinery.lib.executable.Symbol.tls_index"><code class="name">var <span class="ident">tls_index</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 6</p></section>
</dd>
<dt id="refinery.lib.executable.Symbol.type_name"><code class="name">var <span class="ident">type_name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 7</p></section>
</dd>
<dt id="refinery.lib.executable.Symbol.bind_name"><code class="name">var <span class="ident">bind_name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 8</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.Symbol.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L279-L288" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_name(self):
    name = self.name
    if name is not None:
        return name
    if self.is_entry:
        return &#39;entry&#39;
    if self.code:
        return F&#39;sub_{self.address:08X}&#39;
    else:
        return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Segment"><code class="flex name class">
<span>class <span class="ident">Segment</span></span>
<span>(</span><span>physical, virtual, sections, name=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An abstract representation of a segment inside an <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L291-L312" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Segment(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a segment inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    physical: Range
    virtual: Range
    sections: Optional[List[Section]]
    name: Optional[str] = None

    def as_section(self) -&gt; Section:
        if self.name is None:
            raise ValueError(&#39;Unable to convert nameless segment to section.&#39;)
        return Section(self.name, self.physical, self.virtual, False)

    def __str__(self):
        msg = F&#39;P=[{self.physical!s}];V=[{self.virtual!s}]&#39;
        if self.name is not None:
            msg = F&#39;{self.name}:{msg}&#39;
        return msg

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Segment.physical"><code class="name">var <span class="ident">physical</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.lib.executable.Segment.virtual"><code class="name">var <span class="ident">virtual</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="refinery.lib.executable.Segment.sections"><code class="name">var <span class="ident">sections</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="refinery.lib.executable.Segment.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.Segment.as_section"><code class="name flex">
<span>def <span class="ident">as_section</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L300-L303" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def as_section(self) -&gt; Section:
    if self.name is None:
        raise ValueError(&#39;Unable to convert nameless segment to section.&#39;)
    return Section(self.name, self.physical, self.virtual, False)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.CompartmentNotFound"><code class="flex name class">
<span>class <span class="ident">CompartmentNotFound</span></span>
<span>(</span><span>lt, location)</span>
</code></dt>
<dd>
<section class="desc"><p>This exception is raised when <code><a title="refinery.lib.executable.Executable.lookup_location" href="#refinery.lib.executable.Executable.lookup_location">Executable.lookup_location()</a></code> fails to
find a <code><a title="refinery.lib.executable.Segment" href="#refinery.lib.executable.Segment">Segment</a></code> that contains the given location.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L315-L323" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CompartmentNotFound(LookupError):
    &#34;&#34;&#34;
    This exception is raised when `refinery.lib.executable.Executable.lookup_location` fails to
    find a `refinery.lib.executable.Segment` that contains the given location.
    &#34;&#34;&#34;
    def __init__(self, lt: LT, location: int):
        super().__init__(F&#39;Unable to find a segment that contains the {lt.value} 0x{location:X}.&#39;)
        self.location_type = lt
        self.location = location</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.LookupError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.executable.Executable"><code class="flex name class">
<span>class <span class="ident">Executable</span></span>
<span>(</span><span>head, data, base=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An abstract representation of a parsed executable in memory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L326-L597" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Executable(ABC):
    &#34;&#34;&#34;
    An abstract representation of a parsed executable in memory.
    &#34;&#34;&#34;

    _data: ByteStr
    _head: Union[PEFile, ELFFile, MachO]
    _base: Optional[int]
    _type: ET

    blob: ClassVar[bool] = False

    @classmethod
    def Load(cls: Type[_T], data: ByteStr, base: Optional[int] = None) -&gt; _T:
        &#34;&#34;&#34;
        Uses the `refinery.lib.executable.exeroute` function to parse the input data with one of
        the following specializations of this class:

        - `refinery.lib.executable.ExecutableELF`
        - `refinery.lib.executable.ExecutableMachO`
        - `refinery.lib.executable.ExecutablePE`
        &#34;&#34;&#34;
        return exeroute(
            data,
            ExecutableELF,
            ExecutableMachO,
            ExecutablePE,
            data,
            base,
        )

    def __init__(self, head: Union[PEFile, ELFFile, MachO], data: ByteStr, base: Optional[int] = None):
        self._data = data
        self._head = head
        self._base = base

    @property
    def head(self):
        &#34;&#34;&#34;
        Return the internal object representing the parsed file format header.
        &#34;&#34;&#34;
        return self._head

    @property
    def type(self):
        &#34;&#34;&#34;
        Returns the `refinery.lib.executable.ET` instance that identifies the executable type.
        &#34;&#34;&#34;
        return self._type

    def __getitem__(self, key: Union[int, slice, Range]):
        return self.read(key)

    def __contains__(self, key: Union[int, slice, Range]):
        try:
            self.read(key)
        except LookupError:
            return False
        else:
            return True

    def read(self, key: Union[int, slice, Range]) -&gt; memoryview:
        &#34;&#34;&#34;
        Read data from the binary based on a given address. If the input `key` is a single integer,
        the function reads a single byte from the given address.
        &#34;&#34;&#34;
        if isinstance(key, Range):
            key = slice(key.lower, key.upper)
        elif isinstance(key, int):
            key = slice(key, key + 1, 1)
        if key.start is None:
            raise LookupError(R&#39;Slice indices with unspecified start are not supported.&#39;)
        if key.stop is not None and key.stop &lt; key.start:
            raise LookupError(R&#39;The slice end must lie after the slice start.&#39;)

        box = self.location_from_address(key.start)

        if key.stop is None:
            end = box.physical.box.upper
        elif key.stop &lt;= box.virtual.box.upper:
            end = box.physical.position + (key.stop - key.start)
        else:
            raise LookupError(F&#39;The end address 0x{key.stop:X} is beyond the section end 0x{box.virtual.box.upper:X}.&#39;)

        return self.data[box.physical.position:end]

    @staticmethod
    def ascii(string: Union[str, ByteStr]) -&gt; str:
        &#34;&#34;&#34;
        If the input `string` is a `str` instance, the function returns the input value. Byte
        strings are truncated to the first occurrence of a null byte and then decoded using
        the `latin-1` codec.
        &#34;&#34;&#34;
        if isinstance(string, str):
            return string
        for k, b in enumerate(string):
            if b == 0:
                string = string[:k]
                break
        return string.decode(&#39;latin-1&#39;)

    def rebase_usr_to_img(self, addr: int) -&gt; int:
        return addr - self.base + self.image_defined_base()

    def rebase_img_to_usr(self, addr: int) -&gt; int:
        return addr - self.image_defined_base() + self.base

    @property
    def base(self) -&gt; int:
        &#34;&#34;&#34;
        Return the base address when mapped to memory. This is either the value passed to the
        constructor, or `refinery.lib.exectuable.Executable.image_defined_base`.
        &#34;&#34;&#34;
        if self._base is None:
            return self.image_defined_base()
        return self._base

    @base.setter
    def base(self, value: int):
        self._base = value

    @property
    def data(self) -&gt; memoryview:
        &#34;&#34;&#34;
        Return a (readonly) view to the raw bytes of the executable image.
        &#34;&#34;&#34;
        view = memoryview(self._data)
        if sys.version_info &gt;= (3, 8):
            view = view.toreadonly()
        return view

    @property
    def pointer_size(self) -&gt; int:
        &#34;&#34;&#34;
        Return the size of a pointer in bits. Depends on `refinery.lib.executable.Executable.arch`.
        &#34;&#34;&#34;
        return self.arch().pointer_size

    def location_from_address(self, address: int) -&gt; Location:
        &#34;&#34;&#34;
        Return a `refinery.lib.executable.Location` from the given address.
        &#34;&#34;&#34;
        return self.lookup_location(address, LT.VIRTUAL)

    def location_from_offset(self, offset: int) -&gt; Location:
        &#34;&#34;&#34;
        Return a `refinery.lib.executable.Location` from the given file offset.
        &#34;&#34;&#34;
        return self.lookup_location(offset, LT.PHYSICAL)

    def image_defined_size(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the size of the executable on disk.
        &#34;&#34;&#34;
        size = 0
        for segment in self.segments():
            size = max(size, segment.physical.upper)
        for section in self.sections():
            size = max(size, section.physical.upper)
        return size

    def image_defined_address_space(self) -&gt; Range:
        &#34;&#34;&#34;
        Returns the size of the executalbe in memory.
        &#34;&#34;&#34;
        upper = 0
        lower = INF
        for segment in self.segments():
            upper = max(upper, segment.virtual.upper)
            lower = min(lower, segment.virtual.lower)
        for section in self.sections():
            upper = max(upper, section.virtual.upper)
            lower = min(lower, section.virtual.lower)
        if upper &lt; lower:
            raise RuntimeError(F&#39;The computed address space upper bound 0x{upper:X} is less than the computed lower bound 0x{lower:X}.&#39;)
        return Range(lower, upper)

    def lookup_location(self, location: int, lt: LT) -&gt; Location:
        &#34;&#34;&#34;
        For a address or file offset, compute the corresponding `refinery.lib.executable.Location`.
        &#34;&#34;&#34;
        for part in itertools.chain(self.sections(), self.segments()):
            phys = part.physical
            virt = part.virtual
            if lt is LT.PHYSICAL and location in phys:
                return Location(
                    BoxedOffset(phys, location),
                    BoxedOffset(virt, virt.lower + location - phys.lower)
                )
            if lt is LT.VIRTUAL and location in virt:
                return Location(
                    BoxedOffset(phys, phys.lower + location - virt.lower),
                    BoxedOffset(virt, location)
                )
        else:
            raise CompartmentNotFound(lt, location)

    @abstractmethod
    def _symbols(self) -&gt; Generator[Symbol, None, None]:
        ...

    def symbols(self) -&gt; Generator[Symbol, None, None]:
        &#34;&#34;&#34;
        Generates a list of symbols in the executable.
        &#34;&#34;&#34;
        for symbol in self._symbols():
            if symbol.address in self:
                yield symbol

    @abstractmethod
    def byte_order(self) -&gt; BO:
        &#34;&#34;&#34;
        The byte order used by the architecture of this executable.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def image_defined_base(self) -&gt; int:
        &#34;&#34;&#34;
        The image defined base address when mapped to memory.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def arch(self) -&gt; Arch:
        &#34;&#34;&#34;
        The architecture for which this executable was built.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def _sections(self) -&gt; Generator[Section, None, None]:
        ...

    @abstractmethod
    def _segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        ...

    def segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        &#34;&#34;&#34;
        An iterable of all `refinery.lib.executable.Segment`s in this executable.
        &#34;&#34;&#34;
        yield from self._segments(populate_sections=populate_sections)

    def sections(self) -&gt; Generator[Section, None, None]:
        &#34;&#34;&#34;
        An iterable of all `refinery.lib.executable.Section`s in this executable.
        &#34;&#34;&#34;
        ib = self.image_defined_base()
        missing = [Range(0, len(self._data))]
        offsets = {}
        for section in self._sections():
            missing = [piece for patch in missing for piece in patch - section.physical]
            offsets[section.physical.lower] = section.virtual.lower
            yield section
        if not missing:
            return
        offsets.setdefault(0, ib)
        for gap in missing:
            p_floor = min((k for k in offsets if k &lt;= gap.lower), key=lambda p: p - gap.lower)
            v_floor = offsets[p_floor]
            v_lower = v_floor + (gap.lower - p_floor)
            v_upper = v_lower + len(gap)
            if gap.lower == 0:
                name = R&#39;synthesized/.header&#39;
            elif gap.upper == len(self._data):
                name = R&#39;synthesized/.overlay&#39;
            elif any(self._data[gap.slice()]):
                name = F&#39;synthesized/.gap-{gap.lower:08X}-{gap.upper:08X}&#39;
            else:
                name = F&#39;synthesized/.zeros-{gap.lower:08X}&#39;
            yield Section(name, gap, Range(v_lower, v_upper), True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.ExecutableCodeBlob" href="#refinery.lib.executable.ExecutableCodeBlob">ExecutableCodeBlob</a></li>
<li><a title="refinery.lib.executable.ExecutableELF" href="#refinery.lib.executable.ExecutableELF">ExecutableELF</a></li>
<li><a title="refinery.lib.executable.ExecutableMachO" href="#refinery.lib.executable.ExecutableMachO">ExecutableMachO</a></li>
<li><a title="refinery.lib.executable.ExecutablePE" href="#refinery.lib.executable.ExecutablePE">ExecutablePE</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.Executable.blob"><code class="name">var <span class="ident">blob</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.executable.Executable.Load"><code class="name flex">
<span>def <span class="ident">Load</span></span>(<span>data, base=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Uses the <code><a title="refinery.lib.executable.exeroute" href="#refinery.lib.executable.exeroute">exeroute()</a></code> function to parse the input data with one of
the following specializations of this class:</p>
<ul>
<li><code><a title="refinery.lib.executable.ExecutableELF" href="#refinery.lib.executable.ExecutableELF">ExecutableELF</a></code></li>
<li><code><a title="refinery.lib.executable.ExecutableMachO" href="#refinery.lib.executable.ExecutableMachO">ExecutableMachO</a></code></li>
<li><code><a title="refinery.lib.executable.ExecutablePE" href="#refinery.lib.executable.ExecutablePE">ExecutablePE</a></code></li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L338-L355" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def Load(cls: Type[_T], data: ByteStr, base: Optional[int] = None) -&gt; _T:
    &#34;&#34;&#34;
    Uses the `refinery.lib.executable.exeroute` function to parse the input data with one of
    the following specializations of this class:

    - `refinery.lib.executable.ExecutableELF`
    - `refinery.lib.executable.ExecutableMachO`
    - `refinery.lib.executable.ExecutablePE`
    &#34;&#34;&#34;
    return exeroute(
        data,
        ExecutableELF,
        ExecutableMachO,
        ExecutablePE,
        data,
        base,
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.ascii"><code class="name flex">
<span>def <span class="ident">ascii</span></span>(<span>string)</span>
</code></dt>
<dd>
<section class="desc"><p>If the input <code>string</code> is a <code>str</code> instance, the function returns the input value. Byte
strings are truncated to the first occurrence of a null byte and then decoded using
the <code>latin-1</code> codec.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L412-L425" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def ascii(string: Union[str, ByteStr]) -&gt; str:
    &#34;&#34;&#34;
    If the input `string` is a `str` instance, the function returns the input value. Byte
    strings are truncated to the first occurrence of a null byte and then decoded using
    the `latin-1` codec.
    &#34;&#34;&#34;
    if isinstance(string, str):
        return string
    for k, b in enumerate(string):
        if b == 0:
            string = string[:k]
            break
    return string.decode(&#39;latin-1&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Executable.head"><code class="name">var <span class="ident">head</span></code></dt>
<dd>
<section class="desc"><p>Return the internal object representing the parsed file format header.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L362-L367" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def head(self):
    &#34;&#34;&#34;
    Return the internal object representing the parsed file format header.
    &#34;&#34;&#34;
    return self._head</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>Returns the <code><a title="refinery.lib.executable.ET" href="#refinery.lib.executable.ET">ET</a></code> instance that identifies the executable type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L369-L374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def type(self):
    &#34;&#34;&#34;
    Returns the `refinery.lib.executable.ET` instance that identifies the executable type.
    &#34;&#34;&#34;
    return self._type</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.base"><code class="name">var <span class="ident">base</span></code></dt>
<dd>
<section class="desc"><p>Return the base address when mapped to memory. This is either the value passed to the
constructor, or <code>refinery.lib.exectuable.Executable.image_defined_base</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L433-L441" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def base(self) -&gt; int:
    &#34;&#34;&#34;
    Return the base address when mapped to memory. This is either the value passed to the
    constructor, or `refinery.lib.exectuable.Executable.image_defined_base`.
    &#34;&#34;&#34;
    if self._base is None:
        return self.image_defined_base()
    return self._base</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<section class="desc"><p>Return a (readonly) view to the raw bytes of the executable image.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L447-L455" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def data(self) -&gt; memoryview:
    &#34;&#34;&#34;
    Return a (readonly) view to the raw bytes of the executable image.
    &#34;&#34;&#34;
    view = memoryview(self._data)
    if sys.version_info &gt;= (3, 8):
        view = view.toreadonly()
    return view</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.pointer_size"><code class="name">var <span class="ident">pointer_size</span></code></dt>
<dd>
<section class="desc"><p>Return the size of a pointer in bits. Depends on <code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">Executable.arch()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L457-L462" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def pointer_size(self) -&gt; int:
    &#34;&#34;&#34;
    Return the size of a pointer in bits. Depends on `refinery.lib.executable.Executable.arch`.
    &#34;&#34;&#34;
    return self.arch().pointer_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.Executable.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<section class="desc"><p>Read data from the binary based on a given address. If the input <code>key</code> is a single integer,
the function reads a single byte from the given address.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L387-L410" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self, key: Union[int, slice, Range]) -&gt; memoryview:
    &#34;&#34;&#34;
    Read data from the binary based on a given address. If the input `key` is a single integer,
    the function reads a single byte from the given address.
    &#34;&#34;&#34;
    if isinstance(key, Range):
        key = slice(key.lower, key.upper)
    elif isinstance(key, int):
        key = slice(key, key + 1, 1)
    if key.start is None:
        raise LookupError(R&#39;Slice indices with unspecified start are not supported.&#39;)
    if key.stop is not None and key.stop &lt; key.start:
        raise LookupError(R&#39;The slice end must lie after the slice start.&#39;)

    box = self.location_from_address(key.start)

    if key.stop is None:
        end = box.physical.box.upper
    elif key.stop &lt;= box.virtual.box.upper:
        end = box.physical.position + (key.stop - key.start)
    else:
        raise LookupError(F&#39;The end address 0x{key.stop:X} is beyond the section end 0x{box.virtual.box.upper:X}.&#39;)

    return self.data[box.physical.position:end]</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.rebase_usr_to_img"><code class="name flex">
<span>def <span class="ident">rebase_usr_to_img</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L427-L428" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rebase_usr_to_img(self, addr: int) -&gt; int:
    return addr - self.base + self.image_defined_base()</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.rebase_img_to_usr"><code class="name flex">
<span>def <span class="ident">rebase_img_to_usr</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L430-L431" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rebase_img_to_usr(self, addr: int) -&gt; int:
    return addr - self.image_defined_base() + self.base</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.location_from_address"><code class="name flex">
<span>def <span class="ident">location_from_address</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a <code><a title="refinery.lib.executable.Location" href="#refinery.lib.executable.Location">Location</a></code> from the given address.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L464-L468" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def location_from_address(self, address: int) -&gt; Location:
    &#34;&#34;&#34;
    Return a `refinery.lib.executable.Location` from the given address.
    &#34;&#34;&#34;
    return self.lookup_location(address, LT.VIRTUAL)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.location_from_offset"><code class="name flex">
<span>def <span class="ident">location_from_offset</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a <code><a title="refinery.lib.executable.Location" href="#refinery.lib.executable.Location">Location</a></code> from the given file offset.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L470-L474" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def location_from_offset(self, offset: int) -&gt; Location:
    &#34;&#34;&#34;
    Return a `refinery.lib.executable.Location` from the given file offset.
    &#34;&#34;&#34;
    return self.lookup_location(offset, LT.PHYSICAL)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.image_defined_size"><code class="name flex">
<span>def <span class="ident">image_defined_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the size of the executable on disk.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L476-L485" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def image_defined_size(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the size of the executable on disk.
    &#34;&#34;&#34;
    size = 0
    for segment in self.segments():
        size = max(size, segment.physical.upper)
    for section in self.sections():
        size = max(size, section.physical.upper)
    return size</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.image_defined_address_space"><code class="name flex">
<span>def <span class="ident">image_defined_address_space</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the size of the executalbe in memory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L487-L501" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def image_defined_address_space(self) -&gt; Range:
    &#34;&#34;&#34;
    Returns the size of the executalbe in memory.
    &#34;&#34;&#34;
    upper = 0
    lower = INF
    for segment in self.segments():
        upper = max(upper, segment.virtual.upper)
        lower = min(lower, segment.virtual.lower)
    for section in self.sections():
        upper = max(upper, section.virtual.upper)
        lower = min(lower, section.virtual.lower)
    if upper &lt; lower:
        raise RuntimeError(F&#39;The computed address space upper bound 0x{upper:X} is less than the computed lower bound 0x{lower:X}.&#39;)
    return Range(lower, upper)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.lookup_location"><code class="name flex">
<span>def <span class="ident">lookup_location</span></span>(<span>self, location, lt)</span>
</code></dt>
<dd>
<section class="desc"><p>For a address or file offset, compute the corresponding <code><a title="refinery.lib.executable.Location" href="#refinery.lib.executable.Location">Location</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L503-L521" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lookup_location(self, location: int, lt: LT) -&gt; Location:
    &#34;&#34;&#34;
    For a address or file offset, compute the corresponding `refinery.lib.executable.Location`.
    &#34;&#34;&#34;
    for part in itertools.chain(self.sections(), self.segments()):
        phys = part.physical
        virt = part.virtual
        if lt is LT.PHYSICAL and location in phys:
            return Location(
                BoxedOffset(phys, location),
                BoxedOffset(virt, virt.lower + location - phys.lower)
            )
        if lt is LT.VIRTUAL and location in virt:
            return Location(
                BoxedOffset(phys, phys.lower + location - virt.lower),
                BoxedOffset(virt, location)
            )
    else:
        raise CompartmentNotFound(lt, location)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.symbols"><code class="name flex">
<span>def <span class="ident">symbols</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a list of symbols in the executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L527-L533" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def symbols(self) -&gt; Generator[Symbol, None, None]:
    &#34;&#34;&#34;
    Generates a list of symbols in the executable.
    &#34;&#34;&#34;
    for symbol in self._symbols():
        if symbol.address in self:
            yield symbol</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.byte_order"><code class="name flex">
<span>def <span class="ident">byte_order</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The byte order used by the architecture of this executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L535-L540" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def byte_order(self) -&gt; BO:
    &#34;&#34;&#34;
    The byte order used by the architecture of this executable.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.image_defined_base"><code class="name flex">
<span>def <span class="ident">image_defined_base</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The image defined base address when mapped to memory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L542-L547" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def image_defined_base(self) -&gt; int:
    &#34;&#34;&#34;
    The image defined base address when mapped to memory.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.arch"><code class="name flex">
<span>def <span class="ident">arch</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The architecture for which this executable was built.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L549-L554" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def arch(self) -&gt; Arch:
    &#34;&#34;&#34;
    The architecture for which this executable was built.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.segments"><code class="name flex">
<span>def <span class="ident">segments</span></span>(<span>self, populate_sections=False)</span>
</code></dt>
<dd>
<section class="desc"><p>An iterable of all <code><a title="refinery.lib.executable.Segment" href="#refinery.lib.executable.Segment">Segment</a></code>s in this executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L564-L568" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
    &#34;&#34;&#34;
    An iterable of all `refinery.lib.executable.Segment`s in this executable.
    &#34;&#34;&#34;
    yield from self._segments(populate_sections=populate_sections)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.sections"><code class="name flex">
<span>def <span class="ident">sections</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>An iterable of all <code><a title="refinery.lib.executable.Section" href="#refinery.lib.executable.Section">Section</a></code>s in this executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L570-L597" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sections(self) -&gt; Generator[Section, None, None]:
    &#34;&#34;&#34;
    An iterable of all `refinery.lib.executable.Section`s in this executable.
    &#34;&#34;&#34;
    ib = self.image_defined_base()
    missing = [Range(0, len(self._data))]
    offsets = {}
    for section in self._sections():
        missing = [piece for patch in missing for piece in patch - section.physical]
        offsets[section.physical.lower] = section.virtual.lower
        yield section
    if not missing:
        return
    offsets.setdefault(0, ib)
    for gap in missing:
        p_floor = min((k for k in offsets if k &lt;= gap.lower), key=lambda p: p - gap.lower)
        v_floor = offsets[p_floor]
        v_lower = v_floor + (gap.lower - p_floor)
        v_upper = v_lower + len(gap)
        if gap.lower == 0:
            name = R&#39;synthesized/.header&#39;
        elif gap.upper == len(self._data):
            name = R&#39;synthesized/.overlay&#39;
        elif any(self._data[gap.slice()]):
            name = F&#39;synthesized/.gap-{gap.lower:08X}-{gap.upper:08X}&#39;
        else:
            name = F&#39;synthesized/.zeros-{gap.lower:08X}&#39;
        yield Section(name, gap, Range(v_lower, v_upper), True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.ExecutableCodeBlob"><code class="flex name class">
<span>class <span class="ident">ExecutableCodeBlob</span></span>
<span>(</span><span>data, base=None, arch=Arch.X32, byte_order=BO.LE)</span>
</code></dt>
<dd>
<section class="desc"><p>A dummy specialization of <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code> that represents an unstructured
blob of (shell)code. All information that would usually be obtained from a file header must be
provided in the constructor for this object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L600-L638" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ExecutableCodeBlob(Executable):
    &#34;&#34;&#34;
    A dummy specialization of `refinery.lib.executable.Executable` that represents an unstructured
    blob of (shell)code. All information that would usually be obtained from a file header must be
    provided in the constructor for this object.
    &#34;&#34;&#34;

    _head: Type[None] = None
    _type = ET.BLOB
    _byte_order: BO
    _arch: Arch

    blob = True

    def __init__(self, data, base=None, arch: Arch = Arch.X32, byte_order: BO = BO.LE):
        super().__init__(None, data, base)
        self._byte_order = byte_order
        self._arch = arch

    def image_defined_base(self) -&gt; int:
        return 0

    def byte_order(self) -&gt; BO:
        return self._byte_order

    def arch(self) -&gt; Arch:
        return self._arch

    def _symbols(self) -&gt; Generator[Symbol, None, None]:
        yield Symbol(0, is_entry=True)

    def _sections(self) -&gt; Generator[Section, None, None]:
        v = Range(self.base, self.base + len(self.data))
        p = Range(0, len(self.data))
        yield Section(&#39;blob&#39;, p, v, False)

    def _segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        for s in self.sections():
            yield s.as_segment(populate_sections=populate_sections)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.ExecutableCodeBlob.blob"><code class="name">var <span class="ident">blob</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.executable.Executable.Load" href="#refinery.lib.executable.Executable.Load">Load</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">arch</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.ascii" href="#refinery.lib.executable.Executable.ascii">ascii</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.base" href="#refinery.lib.executable.Executable.base">base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.byte_order" href="#refinery.lib.executable.Executable.byte_order">byte_order</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.data" href="#refinery.lib.executable.Executable.data">data</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.head" href="#refinery.lib.executable.Executable.head">head</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_address_space" href="#refinery.lib.executable.Executable.image_defined_address_space">image_defined_address_space</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_base" href="#refinery.lib.executable.Executable.image_defined_base">image_defined_base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_size" href="#refinery.lib.executable.Executable.image_defined_size">image_defined_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_address" href="#refinery.lib.executable.Executable.location_from_address">location_from_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_offset" href="#refinery.lib.executable.Executable.location_from_offset">location_from_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.lookup_location" href="#refinery.lib.executable.Executable.lookup_location">lookup_location</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.pointer_size" href="#refinery.lib.executable.Executable.pointer_size">pointer_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read" href="#refinery.lib.executable.Executable.read">read</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.sections" href="#refinery.lib.executable.Executable.sections">sections</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.segments" href="#refinery.lib.executable.Executable.segments">segments</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.symbols" href="#refinery.lib.executable.Executable.symbols">symbols</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.type" href="#refinery.lib.executable.Executable.type">type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.executable.ExecutablePE"><code class="flex name class">
<span>class <span class="ident">ExecutablePE</span></span>
<span>(</span><span>head, data, base=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A Windows Portable Executable (PE) file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L641-L770" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ExecutablePE(Executable):
    &#34;&#34;&#34;
    A Windows Portable Executable (PE) file.
    &#34;&#34;&#34;

    _head: PEFile
    _type = ET.PE

    def image_defined_base(self) -&gt; int:
        return self._head.OPTIONAL_HEADER.ImageBase

    def image_defined_size(self, overlay=True, sections=True, directories=True, certificate=True, memdump=False) -&gt; int:
        &#34;&#34;&#34;
        This fuction determines the size of a PE file, optionally taking into account the
        pefile module overlay computation, section information, data directory information,
        and certificate entries.
        &#34;&#34;&#34;
        pe = self._head

        overlay_value = overlay and pe.get_overlay_data_start_offset() or 0
        sections_value = sections and super().image_defined_size() or 0
        memdump_value = memdump and self.image_defined_address_space().upper or 0
        cert_entry = pe.OPTIONAL_HEADER.DATA_DIRECTORY[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_SECURITY&#39;]]

        if directories:
            directories_value = max((
                pe.get_offset_from_rva(d.VirtualAddress) + d.Size
                for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY
                if d.name != &#39;IMAGE_DIRECTORY_ENTRY_SECURITY&#39;
            ), default=0)
            if certificate:
                # The certificate overlay is given as a file offset
                # rather than a virtual address.
                cert_value = cert_entry.VirtualAddress + cert_entry.Size
            else:
                cert_value = 0
            directories_value = max(directories_value, cert_value)
        else:
            directories_value = 0

        return max(
            overlay_value,
            sections_value,
            directories_value,
            memdump_value
        )

    def _sections(self) -&gt; Generator[Section, None, None]:
        sections: Iterable[SectionStructure] = iter(self._head.sections)
        ib = self.image_defined_base()
        for section in sections:
            p_lower = section.PointerToRawData
            p_upper = p_lower + section.SizeOfRawData
            v_lower = section.VirtualAddress + ib
            v_lower = self.rebase_img_to_usr(v_lower)
            v_upper = v_lower + section.Misc_VirtualSize
            p = Range(p_lower, p_upper)
            v = Range(v_lower, v_upper)
            yield Section(self.ascii(section.Name), p, v, False)

    def _segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        for section in self.sections():
            yield section.as_segment(populate_sections)

    def arch(self) -&gt; Arch:
        arch = self._head.FILE_HEADER.Machine
        arch = MACHINE_TYPE[arch]
        try:
            return {
                &#39;IMAGE_FILE_MACHINE_I386&#39;   : Arch.X32,
                &#39;IMAGE_FILE_MACHINE_AMD64&#39;  : Arch.X64,
                &#39;IMAGE_FILE_MACHINE_ARM&#39;    : Arch.ARM32,
                &#39;IMAGE_FILE_MACHINE_THUMB&#39;  : Arch.ARM32,
                &#39;IMAGE_FILE_MACHINE_ARMNT&#39;  : Arch.ARM64,
                &#39;IMAGE_FILE_MACHINE_MIPS16&#39; : Arch.MIPS16,
            }[arch]
        except KeyError:
            raise LookupError(F&#39;Unsupported architecture: {arch}&#39;)

    def byte_order(self) -&gt; BO:
        return BO.LE

    def _symbols(self) -&gt; Generator[Symbol, None, None]:
        base = self.image_defined_base()
        head = self._head

        yield Symbol(head.OPTIONAL_HEADER.AddressOfEntryPoint + base, is_entry=True)

        head.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_TLS&#39;],
        ])

        try:
            tls = head.DIRECTORY_ENTRY_TLS
        except AttributeError:
            pass
        else:
            callback_array_rva = tls.struct.AddressOfCallBacks - base
            ps = self.pointer_size // 8
            for k in itertools.count():
                if 0 == (cb := int.from_bytes(head.get_data(callback_array_rva + ps * k, ps), self.byte_order())):
                    break
                yield Symbol(cb, F&#39;TlsCallback{k}&#39;, tls_index=k)

        try:
            exports = head.DIRECTORY_ENTRY_EXPORT.symbols
        except AttributeError:
            return
        for exp in exports:
            name = exp.name
            if not name:
                continue
            yield Symbol(exp.address + base, name.decode(&#39;ascii&#39;))

        for itype in [&#39;IMPORT&#39;, &#39;DELAY_IMPORT&#39;]:
            try:
                imports = getattr(head, F&#39;DIRECTORY_ENTRY_{itype}&#39;).imports
            except AttributeError:
                continue
            for idd in imports:
                dll: str = idd.dll.decode(&#39;ascii&#39;)
                if dll.lower().endswith(&#39;.dll&#39;):
                    dll = dll[:-4]
                for imp in idd.imports:
                    if name := imp.name:
                        name = name.decode(&#39;ascii&#39;)
                        yield Symbol(imp.address, name, exported=False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.ExecutablePE.image_defined_size"><code class="name flex">
<span>def <span class="ident">image_defined_size</span></span>(<span>self, overlay=True, sections=True, directories=True, certificate=True, memdump=False)</span>
</code></dt>
<dd>
<section class="desc"><p>This fuction determines the size of a PE file, optionally taking into account the
pefile module overlay computation, section information, data directory information,
and certificate entries.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L652-L686" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def image_defined_size(self, overlay=True, sections=True, directories=True, certificate=True, memdump=False) -&gt; int:
    &#34;&#34;&#34;
    This fuction determines the size of a PE file, optionally taking into account the
    pefile module overlay computation, section information, data directory information,
    and certificate entries.
    &#34;&#34;&#34;
    pe = self._head

    overlay_value = overlay and pe.get_overlay_data_start_offset() or 0
    sections_value = sections and super().image_defined_size() or 0
    memdump_value = memdump and self.image_defined_address_space().upper or 0
    cert_entry = pe.OPTIONAL_HEADER.DATA_DIRECTORY[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_SECURITY&#39;]]

    if directories:
        directories_value = max((
            pe.get_offset_from_rva(d.VirtualAddress) + d.Size
            for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY
            if d.name != &#39;IMAGE_DIRECTORY_ENTRY_SECURITY&#39;
        ), default=0)
        if certificate:
            # The certificate overlay is given as a file offset
            # rather than a virtual address.
            cert_value = cert_entry.VirtualAddress + cert_entry.Size
        else:
            cert_value = 0
        directories_value = max(directories_value, cert_value)
    else:
        directories_value = 0

    return max(
        overlay_value,
        sections_value,
        directories_value,
        memdump_value
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.executable.Executable.Load" href="#refinery.lib.executable.Executable.Load">Load</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">arch</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.ascii" href="#refinery.lib.executable.Executable.ascii">ascii</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.base" href="#refinery.lib.executable.Executable.base">base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.byte_order" href="#refinery.lib.executable.Executable.byte_order">byte_order</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.data" href="#refinery.lib.executable.Executable.data">data</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.head" href="#refinery.lib.executable.Executable.head">head</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_address_space" href="#refinery.lib.executable.Executable.image_defined_address_space">image_defined_address_space</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_base" href="#refinery.lib.executable.Executable.image_defined_base">image_defined_base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_address" href="#refinery.lib.executable.Executable.location_from_address">location_from_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_offset" href="#refinery.lib.executable.Executable.location_from_offset">location_from_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.lookup_location" href="#refinery.lib.executable.Executable.lookup_location">lookup_location</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.pointer_size" href="#refinery.lib.executable.Executable.pointer_size">pointer_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read" href="#refinery.lib.executable.Executable.read">read</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.sections" href="#refinery.lib.executable.Executable.sections">sections</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.segments" href="#refinery.lib.executable.Executable.segments">segments</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.symbols" href="#refinery.lib.executable.Executable.symbols">symbols</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.type" href="#refinery.lib.executable.Executable.type">type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.executable.ExecutableELF"><code class="flex name class">
<span>class <span class="ident">ExecutableELF</span></span>
<span>(</span><span>head, data, base=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A file in Executable and Linkable Format (ELF).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L773-L890" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ExecutableELF(Executable):
    &#34;&#34;&#34;
    A file in Executable and Linkable Format (ELF).
    &#34;&#34;&#34;

    _head: ELFFile
    _type = ET.ELF

    @lru_cache(maxsize=1)
    def image_defined_base(self) -&gt; int:
        return min(self._pt_load(), default=0)

    @lru_cache(maxsize=1)
    def _pt_load(self):
        PT_LOAD = {}
        if not self._head.num_segments():
            raise LookupError(&#39;The elftools parser did not find any segments in this file.&#39;)
        for segment in self._head.iter_segments():
            if segment.header.p_type == &#39;PT_LOAD&#39;:
                PT_LOAD[segment.header.p_vaddr] = segment
        if not PT_LOAD:
            raise LookupError(&#39;Could not find any PT_LOAD segment.&#39;)
        return PT_LOAD

    def _convert_section(self, section) -&gt; Section:
        p_lower = section[&#39;sh_offset&#39;]
        v_lower = section[&#39;sh_addr&#39;]
        v_lower = self.rebase_img_to_usr(v_lower)
        v_upper = v_lower + align(section[&#39;sh_addralign&#39;], section.data_size)
        p_upper = p_lower + section.data_size
        return Section(self.ascii(section.name), Range(p_lower, p_upper), Range(v_lower, v_upper), False)

    def _sections(self) -&gt; Generator[Section, None, None]:
        for section in self._head.iter_sections():
            if section.is_null():
                continue
            yield self._convert_section(section)

    def _segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        for segment in self._head.iter_segments():
            header = segment.header
            p_lower = header.p_offset
            v_lower = header.p_vaddr
            v_lower = self.rebase_img_to_usr(v_lower)
            p_upper = p_lower + header.p_filesz
            v_upper = v_lower + header.p_memsz
            if not populate_sections:
                sections = None
            else:
                sections = [
                    self._convert_section(section)
                    for section in self._head.iter_sections()
                    if segment.section_in_segment(section)
                ]
            yield Segment(Range(p_lower, p_upper), Range(v_lower, v_upper), sections)

    def arch(self) -&gt; Arch:
        arch = self._head.header[&#39;e_machine&#39;]
        try:
            return {
                &#39;EM_SPARC&#39;   : Arch.SPARC32,
                &#39;EM_SPARCV9&#39; : Arch.SPARC64,
                &#39;EM_386&#39;     : Arch.X32,
                &#39;EM_X86_64&#39;  : Arch.X64,
                &#39;EM_MIPS&#39;    : Arch.MIPS32,
                &#39;EM_PPC&#39;     : Arch.PPC32,
                &#39;EM_PPC64&#39;   : Arch.PPC64,
                &#39;EM_ARM&#39;     : Arch.ARM32,
            }[arch]
        except KeyError:
            raise LookupError(F&#39;Unsupported architecture: {arch}&#39;)

    def byte_order(self) -&gt; BO:
        return BO.LE if self.head.little_endian else BO.BE

    def _symbols(self) -&gt; Generator[Symbol, None, None]:
        ee = self._head.header[&#39;e_entry&#39;]
        symbols = {ee: Symbol(ee, is_entry=True)}
        try:
            sections = list(self._head.iter_sections())
        except Exception:
            return
        for section in sections:
            if not isinstance(section, SymbolTableSection):
                continue
            if section[&#39;sh_entsize&#39;] == 0:
                continue
            for sym in section.iter_symbols():
                st_name = sym.name
                if sym[&#39;st_info&#39;][&#39;type&#39;] == &#39;STT_SECTION&#39; and sym[&#39;st_shndx&#39;] &lt; len(sections) and sym[&#39;st_name&#39;] == 0:
                    try:
                        st_name = self._head.get_section(sym[&#39;st_shndx&#39;]).name
                    except Exception:
                        pass
                st_addr = sym[&#39;st_value&#39;]
                st_name = re.sub(&#39;[\x01-\x1f]+&#39;, &#39;&#39;, st_name)
                st_type = sym[&#39;st_info&#39;][&#39;type&#39;]
                st_bind = sym[&#39;st_info&#39;][&#39;bind&#39;]
                st_size = sym[&#39;st_size&#39;]
                insert = False
                try:
                    prev = symbols[st_addr]
                except KeyError:
                    insert = True
                else:
                    insert = prev.name is None or len(prev.name) &lt; len(st_name)
                if insert:
                    symbols[st_addr] = Symbol(
                        st_addr,
                        st_name,
                        st_type == &#39;STT_FUNC&#39;,
                        st_bind == &#39;STB_GLOBAL&#39;,
                        size=st_size,
                        type_name=st_type,
                        bind_name=st_bind,
                    )
        for addr in sorted(symbols):
            yield symbols[addr]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.executable.Executable.Load" href="#refinery.lib.executable.Executable.Load">Load</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">arch</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.ascii" href="#refinery.lib.executable.Executable.ascii">ascii</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.base" href="#refinery.lib.executable.Executable.base">base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.byte_order" href="#refinery.lib.executable.Executable.byte_order">byte_order</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.data" href="#refinery.lib.executable.Executable.data">data</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.head" href="#refinery.lib.executable.Executable.head">head</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_address_space" href="#refinery.lib.executable.Executable.image_defined_address_space">image_defined_address_space</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_base" href="#refinery.lib.executable.Executable.image_defined_base">image_defined_base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_size" href="#refinery.lib.executable.Executable.image_defined_size">image_defined_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_address" href="#refinery.lib.executable.Executable.location_from_address">location_from_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_offset" href="#refinery.lib.executable.Executable.location_from_offset">location_from_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.lookup_location" href="#refinery.lib.executable.Executable.lookup_location">lookup_location</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.pointer_size" href="#refinery.lib.executable.Executable.pointer_size">pointer_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read" href="#refinery.lib.executable.Executable.read">read</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.sections" href="#refinery.lib.executable.Executable.sections">sections</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.segments" href="#refinery.lib.executable.Executable.segments">segments</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.symbols" href="#refinery.lib.executable.Executable.symbols">symbols</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.type" href="#refinery.lib.executable.Executable.type">type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.executable.ExecutableMachO"><code class="flex name class">
<span>class <span class="ident">ExecutableMachO</span></span>
<span>(</span><span>head, data, base=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A MachO-executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/lib/executable.py#L893-L978" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ExecutableMachO(Executable):
    &#34;&#34;&#34;
    A MachO-executable.
    &#34;&#34;&#34;

    _head: MachO
    _type = ET.MachO

    def _symbols(self) -&gt; Generator[Symbol, None, None]:
        raise NotImplementedError

    @lru_cache(maxsize=1)
    def image_defined_base(self) -&gt; int:
        return min(seg.vmaddr for seg, _ in self._macho_segments() if seg.vmaddr &gt; 0)

    def _macho_segments(self):
        headers: List[MachOHeader] = self._head.headers
        for header in headers:
            for cmd, segment, sections in header.commands:
                cmd: load_command
                if not cmd.get_cmd_name().startswith(&#39;LC_SEGMENT&#39;):
                    continue
                if segment.filesize &lt;= 0:
                    continue
                yield segment, sections

    def _segments(self, populate_sections=False) -&gt; Generator[Segment, None, None]:
        for segment, sections in self._macho_segments():
            v_lower = segment.vmaddr
            v_lower = self.rebase_img_to_usr(v_lower)
            p_lower = segment.fileoff
            v_upper = v_lower + segment.vmsize
            p_upper = p_lower + segment.filesize
            segment_name = self.ascii(segment.segname)
            if not populate_sections:
                sections = None
            else:
                sections = [
                    self._convert_section(section, segment_name)
                    for section in sections
                ]
            yield Segment(
                Range(p_lower, p_upper),
                Range(v_lower, v_upper),
                sections,
                segment_name
            )

    def _sections(self) -&gt; Generator[Section, None, None]:
        for segment in self.segments(populate_sections=True):
            yield segment.as_section()
            yield from segment.sections

    def _convert_section(self, section, segment: str) -&gt; Section:
        name = self.ascii(section.sectname)
        p_lower = section.offset
        v_lower = section.addr
        v_lower = self.rebase_img_to_usr(v_lower)
        p_upper = p_lower + section.size
        v_upper = v_lower + align(section.align, section.size)
        return Section(F&#39;{segment}/{name}&#39;, Range(p_lower, p_upper), Range(v_lower, v_upper), False)

    def arch(self) -&gt; Arch:
        cputype = self._head.headers[0].header.cputype
        try:
            arch = _MACHO_ARCHS[cputype]
        except KeyError:
            arch = F&#39;UNKNOWN(0x{cputype:X})&#39;
        try:
            return {
                &#39;X86&#39;       : Arch.X32,
                &#39;X86_64&#39;    : Arch.X64,
                &#39;ARM&#39;       : Arch.ARM32,
                &#39;SPARC&#39;     : Arch.SPARC32,
                &#39;POWERPC&#39;   : Arch.PPC32,
                &#39;POWERPC64&#39; : Arch.PPC64,
            }[arch]
        except KeyError:
            raise LookupError(F&#39;Unsupported architecture: {arch}&#39;)

    def byte_order(self) -&gt; BO:
        headers: List[MachOHeader] = self._head.headers
        return {
            &#39;&lt;&#39;: BO.LE,
            &#39;&gt;&#39;: BO.BE,
        }[headers[0].endian]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.executable.Executable.Load" href="#refinery.lib.executable.Executable.Load">Load</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">arch</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.ascii" href="#refinery.lib.executable.Executable.ascii">ascii</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.base" href="#refinery.lib.executable.Executable.base">base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.byte_order" href="#refinery.lib.executable.Executable.byte_order">byte_order</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.data" href="#refinery.lib.executable.Executable.data">data</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.head" href="#refinery.lib.executable.Executable.head">head</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_address_space" href="#refinery.lib.executable.Executable.image_defined_address_space">image_defined_address_space</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_base" href="#refinery.lib.executable.Executable.image_defined_base">image_defined_base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_size" href="#refinery.lib.executable.Executable.image_defined_size">image_defined_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_address" href="#refinery.lib.executable.Executable.location_from_address">location_from_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_offset" href="#refinery.lib.executable.Executable.location_from_offset">location_from_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.lookup_location" href="#refinery.lib.executable.Executable.lookup_location">lookup_location</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.pointer_size" href="#refinery.lib.executable.Executable.pointer_size">pointer_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read" href="#refinery.lib.executable.Executable.read">read</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.sections" href="#refinery.lib.executable.Executable.sections">sections</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.segments" href="#refinery.lib.executable.Executable.segments">segments</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.symbols" href="#refinery.lib.executable.Executable.symbols">symbols</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.type" href="#refinery.lib.executable.Executable.type">type</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.executable.align" href="#refinery.lib.executable.align">align</a></code></li>
<li><code><a title="refinery.lib.executable.exeroute" href="#refinery.lib.executable.exeroute">exeroute</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.executable.ParsingFailure" href="#refinery.lib.executable.ParsingFailure">ParsingFailure</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Range" href="#refinery.lib.executable.Range">Range</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.Range.range" href="#refinery.lib.executable.Range.range">range</a></code></li>
<li><code><a title="refinery.lib.executable.Range.slice" href="#refinery.lib.executable.Range.slice">slice</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.BoxedOffset" href="#refinery.lib.executable.BoxedOffset">BoxedOffset</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Location" href="#refinery.lib.executable.Location">Location</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.ArchItem" href="#refinery.lib.executable.ArchItem">ArchItem</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.ArchItem.New" href="#refinery.lib.executable.ArchItem.New">New</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Arch" href="#refinery.lib.executable.Arch">Arch</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.LT" href="#refinery.lib.executable.LT">LT</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.ET" href="#refinery.lib.executable.ET">ET</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.BO" href="#refinery.lib.executable.BO">BO</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Section" href="#refinery.lib.executable.Section">Section</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.Section.as_segment" href="#refinery.lib.executable.Section.as_segment">as_segment</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Symbol" href="#refinery.lib.executable.Symbol">Symbol</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.Symbol.get_name" href="#refinery.lib.executable.Symbol.get_name">get_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Segment" href="#refinery.lib.executable.Segment">Segment</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.Segment.as_section" href="#refinery.lib.executable.Segment.as_section">as_section</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.CompartmentNotFound" href="#refinery.lib.executable.CompartmentNotFound">CompartmentNotFound</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.Executable.Load" href="#refinery.lib.executable.Executable.Load">Load</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.ascii" href="#refinery.lib.executable.Executable.ascii">ascii</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read" href="#refinery.lib.executable.Executable.read">read</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.rebase_usr_to_img" href="#refinery.lib.executable.Executable.rebase_usr_to_img">rebase_usr_to_img</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.rebase_img_to_usr" href="#refinery.lib.executable.Executable.rebase_img_to_usr">rebase_img_to_usr</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_address" href="#refinery.lib.executable.Executable.location_from_address">location_from_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_offset" href="#refinery.lib.executable.Executable.location_from_offset">location_from_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_size" href="#refinery.lib.executable.Executable.image_defined_size">image_defined_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_address_space" href="#refinery.lib.executable.Executable.image_defined_address_space">image_defined_address_space</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.lookup_location" href="#refinery.lib.executable.Executable.lookup_location">lookup_location</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.symbols" href="#refinery.lib.executable.Executable.symbols">symbols</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.byte_order" href="#refinery.lib.executable.Executable.byte_order">byte_order</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_base" href="#refinery.lib.executable.Executable.image_defined_base">image_defined_base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">arch</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.segments" href="#refinery.lib.executable.Executable.segments">segments</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.sections" href="#refinery.lib.executable.Executable.sections">sections</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.ExecutableCodeBlob" href="#refinery.lib.executable.ExecutableCodeBlob">ExecutableCodeBlob</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.ExecutablePE" href="#refinery.lib.executable.ExecutablePE">ExecutablePE</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.ExecutablePE.image_defined_size" href="#refinery.lib.executable.ExecutablePE.image_defined_size">image_defined_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.ExecutableELF" href="#refinery.lib.executable.ExecutableELF">ExecutableELF</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.ExecutableMachO" href="#refinery.lib.executable.ExecutableMachO">ExecutableMachO</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>