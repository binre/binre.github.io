<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>the refinery.units.formats.archive.xtpyi documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats.archive.xtpyi</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L1-L613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from __future__ import annotations
from typing import TYPE_CHECKING, NamedTuple

import marshal
import enum
import io
import re
import uuid
import zlib
import os
import os.path
import contextlib
import dataclasses
import sys

from importlib.util import MAGIC_NUMBER

from refinery.units.formats.archive import Arg, ArchiveUnit
from refinery.units.pattern.carve import carve
from refinery.lib.structures import MemoryFile, StreamDetour, Struct, StructReader
from refinery.lib.tools import NoLogging, normalize_word_separators

from Cryptodome.Cipher import AES


if TYPE_CHECKING:
    from types import CodeType
    from typing import Callable, Dict, List, Tuple, Optional, Set, Union, Generator, Iterable
    from xdis import Instruction
    from refinery.lib.types import ByteStr


class Unmarshal(enum.IntEnum):
    No = 0
    Yes = 1
    YesAndDecompile = 2


def version2tuple(version: str):
    return tuple(int(k, 10) for k in re.fullmatch(R&#39;^(\d+\.\d+(?:\.\d+)?)(.*)$&#39;, version).group(1).split(&#39;.&#39;))


def decompress_peek(buffer, size=512) -&gt; Optional[bytes]:
    try:
        return zlib.decompressobj().decompress(buffer[:size])
    except zlib.error:
        return None


class Code(NamedTuple):
    version: Tuple[int]
    timestamp: int
    magic: int
    container: CodeType
    is_pypi: bool
    code_objects: dict


def extract_code_from_buffer(buffer: ByteStr, file_name: Optional[str] = None) -&gt; Generator[Code, None, None]:
    code_objects = {}
    file_name = file_name or &#39;&lt;unknown&gt;&#39;
    load = xtpyi._xdis.load.load_module_from_file_object
    with NoLogging(NoLogging.Mode.STD_ERR):
        version, timestamp, magic_int, codes, is_pypy, _, _ = load(MemoryFile(buffer), file_name, code_objects)
    if not isinstance(codes, list):
        codes = [codes]
    for code in codes:
        yield Code(version, timestamp, magic_int, code, is_pypy, code_objects)


def disassemble_code(code: CodeType, version=None) -&gt; Iterable[Instruction]:
    dis = xtpyi._xdis
    opc = None
    if version is not None:
        if isinstance(version, float):
            version = str(version)
        if not isinstance(version, str):
            version = dis.version_info.version_tuple_to_str(version)
        with contextlib.suppress(KeyError):
            opc = dis.op_imports.op_imports[version]
    return dis.std.Bytecode(code, opc=opc)


def decompile_buffer(buffer: Union[Code, ByteStr], file_name: Optional[str] = None) -&gt; ByteStr:
    main: xtpyi = xtpyi
    errors = &#39;&#39;
    python = &#39;&#39;
    codes = [buffer]

    if not isinstance(buffer, Code):
        codes = list(extract_code_from_buffer(buffer, file_name))

    def _engines():
        nonlocal errors
        try:
            dc = main._decompyle3
        except ImportError:
            errors += &#39;# The decompiler decompyle3 is not installed.\n&#39;
        else:
            yield &#39;decompyle3&#39;, dc
        try:
            dc = main._uncompyle6
        except ImportError:
            errors += &#39;# The decompiler decompyle3 is not installed.\n&#39;
        else:
            yield &#39;uncompyle6&#39;, dc

    engines = dict(_engines())

    if not engines:
        errors += &#39;# (all missing, install one of the above to enable decompilation)&#39;

    for code in codes:
        for name, engine in engines.items():
            with io.StringIO(newline=&#39;&#39;) as output, NoLogging(NoLogging.Mode.ALL):
                try:
                    engine.main.decompile(
                        co=code.container,
                        bytecode_version=code.version,
                        out=output,
                        timestamp=code.timestamp,
                        code_objects=code.code_objects,
                        is_pypy=code.is_pypi,
                        magic_int=code.magic,
                    )
                except Exception as E:
                    errors += &#39;\n&#39;.join(F&#39;# {line}&#39; for line in (
                        F&#39;Error while decompiling with {name}:&#39;, *str(E).splitlines(True)))
                    errors += &#39;\n&#39;
                else:
                    python = output.getvalue()
                    break
    if python:
        # removes leading comments
        python = python.splitlines(True)
        python.reverse()
        while python[-1].strip().startswith(&#39;#&#39;):
            python.pop()
        python.reverse()
        python = &#39;&#39;.join(python)
        return python.encode(main.codec)
    if not isinstance(buffer, Code):
        embedded = bytes(buffer | carve(&#39;printable&#39;, single=True))
        if len(buffer) - len(embedded) &lt; 0x20:
            return embedded
    disassembly = MemoryFile()
    with io.TextIOWrapper(disassembly, main.codec, newline=&#39;\n&#39;) as output:
        output.write(errors)
        output.write(&#39;# Generating Disassembly:\n\n&#39;)
        for code in codes:
            instructions = list(disassemble_code(code.container, code.version))
            width_offset = max(len(str(i.offset)) for i in instructions)
            for i in instructions:
                opname = normalize_word_separators(i.opname, &#39;.&#39;).lower()
                offset = F&#39;{i.offset:0{width_offset}d}&#39;
                output.write(F&#39;# {offset:&gt;5} {opname:&lt;25} {i.argrepr}\n&#39;)
        output.write(&#39;\n&#39;)
    return disassembly.getbuffer()


class PiType(bytes, enum.Enum):
    BINARY          = B&#39;b&#39;  # noqa / binary
    DEPENDENCY      = B&#39;d&#39;  # noqa / runtime option
    PYZ             = B&#39;z&#39;  # noqa / zlib (pyz) - frozen Python code
    PACKAGE         = B&#39;M&#39;  # noqa / Python package (__init__.py)
    MODULE          = B&#39;m&#39;  # noqa / Python module
    SOURCE          = B&#39;s&#39;  # noqa / Python script (v3)
    DATA            = B&#39;x&#39;  # noqa / data
    RUNTIME_OPTION  = B&#39;o&#39;  # noqa / runtime option
    SPLASH          = B&#39;l&#39;  # noqa / splash resources
    UNKNOWN         = B&#39;uk&#39; # noqa
    DECOMPILED      = B&#39;dc&#39; # noqa
    USERCODE        = B&#39;uc&#39; # noqa
    ENCRYPTED       = B&#39;ec&#39; # noqa


class PzType(enum.IntEnum):
    MODULE = 0
    PKG = 1
    DATA = 2


@dataclasses.dataclass
class PiMeta:
    type: PiType
    name: str
    data: Union[Callable[[], ByteStr], ByteStr]

    def unpack(self) -&gt; ByteStr:
        if callable(self.data):
            self.data = self.data()
        return self.data


def make_decompiled_item(name: str, data: ByteStr, *magics) -&gt; PiMeta:

    def extract(data=data, magics=magics):
        error = None
        if any(data[:4] == m[:4] for m in magics):
            return decompile_buffer(data, name)
        for magic in magics:
            try:
                return decompile_buffer(magic + data, name)
            except Exception as exception:
                error = exception
        return &#39;\n&#39;.join(F&#39;# {line}&#39;
            for line in str(error).splitlines(True)).encode(xtpyi.codec)

    return PiMeta(PiType.DECOMPILED, F&#39;{name}.py&#39;, extract)


class PYZ(Struct):

    MagicSignature = B&#39;PYZ\0&#39;

    def __init__(self, reader: StructReader, version: str):
        reader.bigendian = True
        self.base = reader.tell()
        signature = reader.read(4)
        if signature != self.MagicSignature:
            raise ValueError(&#39;invalid magic&#39;)
        magic = bytes(reader.read(4))
        with contextlib.suppress(KeyError, AttributeError):
            xdis = xtpyi._xdis
            if isinstance(xdis, property):
                xdis = xdis.fget()
            version = xdis.magics.versions[magic]
        vtuple = version2tuple(version)
        padding_size = 4
        if vtuple &gt;= (3, 3):
            padding_size += 4
        if vtuple &gt;= (3, 7):
            padding_size += 4
        self.version = version
        self.magic = magic + padding_size * b&#39;\0&#39;
        self.toc_offset = reader.i32()
        self.reader = reader
        self.entries: List[PiMeta] = []

    def unpack(self, decompile: bool, key: Optional[bytes] = None) -&gt; bool:
        with StreamDetour(self.reader, self.base + self.toc_offset):
            toc_data = self.reader.read()
        try:
            toc = marshal.loads(toc_data)
        except Exception as error:
            if MAGIC_NUMBER != self.magic[:4]:
                xdis = xtpyi._xdis
                if isinstance(xdis, property):
                    xdis = xdis.fget()
                _ord = xdis.marsh.Ord
                xdis.marsh.Ord = ord  # monkey-patch workaround for bug in xdis
                try:
                    toc = xdis.marsh.load(
                        MemoryFile(self.data), self.version)
                except Exception:
                    pass
                else:
                    error = None
                finally:
                    xdis.marsh.Ord = _ord
            if error is not None:
                raise error

        if isinstance(toc, list):
            try:
                toc = dict(toc)
            except Exception as error:
                self.entries = []
                self.error = error
                return

        failures = 0
        attempts = len(toc)

        for name, (pzt, offset, length) in toc.items():
            try:
                name: str
                name = name.decode(&#39;utf-8&#39;)
            except AttributeError:
                pass
            try:
                pzt = PzType(pzt)
            except Exception:
                pzt = PzType.DATA

            name = name.replace(&#39;.&#39;, &#39;/&#39;)
            if pzt is PzType.PKG:
                name = F&#39;{name}/__init__&#39;

            with StreamDetour(self.reader, self.base + offset):
                data = self.reader.read(length)

            if key:
                def decompressed(data=data):
                    cipher = AES.new(key, AES.MODE_CFB, bytes(data[:0x10]))
                    return zlib.decompress(cipher.decrypt(data[0x10:]))
            elif decompress_peek(data):
                def decompressed(data=data):
                    return zlib.decompress(data)
            else:
                failures += 1
                continue

            if decompile and pzt in (PzType.MODULE, PzType.PKG):
                def decompiled(data=data, name=name, magic=self.magic):
                    data = decompressed(data)
                    if data[:4] != magic[:4]:
                        data = magic + data
                    return decompile_buffer(data, name)
                self.entries.append(PiMeta(PiType.DECOMPILED, F&#39;{name}.py&#39;, decompiled))
                name = F&#39;{name}.pyc&#39;
                type = PiType.SOURCE
            else:
                type = PiType.DATA

            self.entries.append(PiMeta(type, name, decompressed))

        if key:
            if failures &gt;= 6:
                xtpyi.logger.warning(F&#39;pyz decompression failed for {failures - 5} additional items&#39;)
            return True
        elif failures &gt; 0.7 * attempts:
            self.entries.clear()
            return False
        else:
            return True


class PiTOCEntry(Struct):

    def __init__(self, reader: StructReader):
        reader.bigendian = True
        entry_start_offset = reader.tell()
        self.size_of_entry = reader.i32()
        self.offset = reader.i32()
        self.size_of_compressed_data = reader.i32()
        self.size_od_uncompressed_data = reader.i32()
        self.is_compressed = bool(reader.read_byte())
        entry_type = bytes(reader.read(1))
        name_length = self.size_of_entry - reader.tell() + entry_start_offset
        if name_length &gt; 0x1000:
            raise RuntimeError(F&#39;Refusing to process TOC entry with name of size {name_length}.&#39;)
        name, *_ = bytes(reader.read(name_length)).partition(B&#39;\0&#39;)
        try:
            name = name.decode(&#39;utf8&#39;, &#39;backslashreplace&#39;)
        except Exception:
            name = None
        if not all(part.isprintable() for part in re.split(&#39;\\s*&#39;, name)):
            raise RuntimeError(&#39;Refusing to process TOC entry with non-printable name.&#39;)
        name = name or str(uuid.uuid4())
        if entry_type == B&#39;Z&#39;:
            entry_type = B&#39;z&#39;
        try:
            self.type = PiType(entry_type)
        except ValueError:
            xtpyi.log_warn(F&#39;unknown type {entry_type!r} in field {name}&#39;)
            self.type = PiType.UNKNOWN
        self.name = name

    def __hash__(self):
        return hash(self.name)


class PyInstallerArchiveEpilogue(Struct):

    MagicSignature = bytes.fromhex(&#39;4D45490C0B0A0B0E&#39;)

    def _read_libname(self, reader: StructReader) -&gt; Optional[str]:
        position = reader.tell()
        try:
            libname, t, rest = reader.read_bytes(64).partition(B&#39;\0&#39;)
        except EOFError:
            reader.seekset(position)
            return None
        try:
            libname = libname.decode(&#39;utf8&#39;)
        except Exception:
            reader.seekset(position)
            return None
        if not t or any(rest) or len(rest) &lt; 10 or not re.fullmatch(R&#39;[\s!-~]+&#39;, libname):
            reader.seekset(position)
            return None
        return libname

    def __init__(self, reader: StructReader, offset: int, unmarshal: Unmarshal = Unmarshal.No, decompile: bool = False):
        self.decompile = decompile
        reader.bigendian = True
        reader.seekset(offset)
        self.reader = reader
        signature = reader.read_bytes(8)
        if signature != self.MagicSignature:
            raise ValueError(
                F&#39;offset 0x{offset:X} has invalid signature {signature.hex().upper()}; &#39;
                F&#39;should be {self.MagicSignature.hex().upper()}&#39;)
        self.size = reader.i32()
        toc_offset = reader.i32()
        toc_length = reader.i32()
        self.py_version = &#39;.&#39;.join(str(reader.u32()))
        self.py_libname = self._read_libname(reader)
        self.offset = reader.tell() - self.size

        self.toc: Dict[str, PiTOCEntry] = {}
        toc_end = self.offset + toc_offset + toc_length
        reader.seekset(self.offset + toc_offset)
        while reader.tell() &lt; toc_end:
            try:
                entry = PiTOCEntry(reader)
            except EOFError:
                xtpyi.logger.warning(&#39;end of file while reading TOC&#39;)
                break
            except Exception as error:
                xtpyi.logger.warning(F&#39;unexpected error while reading TOC: {error!s}&#39;)
                break
            if entry.name in self.toc:
                raise KeyError(F&#39;duplicate name {entry.name}&#39;)
            self.toc[entry.name] = entry

        self.files: Dict[str, PiMeta] = {}
        no_pyz_found = True
        pyz_entries: Dict[str, PYZ] = {}

        for entry in list(self.toc.values()):
            if entry.type is not PiType.PYZ:
                continue
            no_pyz_found = False
            name, xt = os.path.splitext(entry.name)
            name_pyz = F&#39;{name}.pyz&#39;
            if name == entry.name:
                del self.toc[name]
                self.toc[name_pyz] = entry
                entry.name = name_pyz
            reader.seekset(self.offset + entry.offset)
            if entry.is_compressed:
                data = self.extract(entry.name).unpack()
            else:
                data = reader
            pyz_entries[name] = PYZ(data, self.py_version)

        magics = {pyz.magic for pyz in pyz_entries.values()}

        if not magics:
            if not no_pyz_found:
                xtpyi.logger.warning(
                    &#39;no magic signature could be recovered from embedded pyzip archives; this is &#39;
                    &#39;unsual and means that there is no way to guess the missing magic for source &#39;
                    &#39;file entries and it will likely not be possible to decompile them.&#39;)
            return
        elif len(magics) &gt; 1:
            xtpyi.logger.warning(&#39;more than one magic signature was recovered; this is unusual.&#39;)

        magics = list(magics)
        keys: Set[bytes] = set()

        for entry in self.toc.values():
            extracted = self.extract(entry.name)
            if entry.type not in (PiType.SOURCE, PiType.MODULE):
                self.files[entry.name] = extracted
                continue
            data = extracted.unpack()
            name, _ = os.path.splitext(extracted.name)
            del self.files[extracted.name]
            extracted.name = F&#39;{name}.pyc&#39;
            self.files[extracted.name] = extracted
            is_crypto_key = name.endswith(&#39;crypto_key&#39;)

            if len(magics) == 1 and data[:4] != magics[0]:
                extracted.data = magics[0] + data

            if is_crypto_key or self.decompile:
                decompiled = make_decompiled_item(name, data, *magics)
                if entry.type is PiType.SOURCE:
                    decompiled.type = PiType.USERCODE
                self.files[decompiled.name] = decompiled

            if is_crypto_key:
                for key in decompiled.unpack() | carve(&#39;string&#39;, decode=True):
                    if len(key) != 0x10:
                        continue
                    xtpyi.logger.info(F&#39;found key: {key.decode(xtpyi.codec)}&#39;)
                    keys.add(key)

        if unmarshal is Unmarshal.No:
            return

        if not keys:
            key = None
        else:
            key = next(iter(keys))

        for name, pyz in pyz_entries.items():
            pyz.unpack(unmarshal is Unmarshal.YesAndDecompile, key)
            for unpacked in pyz.entries:
                unpacked.name = path = F&#39;{name}/{unpacked.name}&#39;
                if path in self.files:
                    raise ValueError(F&#39;duplicate file name: {path}&#39;)
                self.files[path] = unpacked

    def extract(self, name: str) -&gt; PiMeta:
        try:
            return self.files[name]
        except KeyError:
            pass
        entry = self.toc[name]
        with StreamDetour(self.reader, self.offset + entry.offset):
            data = self.reader.read(entry.size_of_compressed_data)
        if entry.is_compressed:
            def extracted(d=data): return zlib.decompress(d)
        else:
            extracted = data
        result = PiMeta(entry.type, name, extracted)
        self.files[name] = result
        return result


class xtpyi(ArchiveUnit):
    &#34;&#34;&#34;
    Extracts and decompiles files from a Python Installer (aka PyInstaller) archive.
    &#34;&#34;&#34;
    def __init__(
        self, *paths, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False,
        path=b&#39;path&#39;, date=b&#39;date&#39;,
        decompile: Arg.Switch(&#39;-c&#39;, help=&#39;Attempt to decompile PYC files.&#39;),
        user_code: Arg.Switch(&#39;-u&#39;, group=&#39;FILTER&#39;, help=(
            &#39;Extract only source code files from the root of the archive. These usually implement &#39;
            &#39;the actual domain logic. This implies the --decompile option.&#39;)) = False,
        unmarshal: Arg(&#39;-y&#39;, action=&#39;count&#39;, group=&#39;FILTER&#39;, help=(
            &#39;(DANGEROUS) Unmarshal embedded PYZ archives. Warning: Maliciously crafted packages can &#39;
            &#39;potentially exploit this to execute code. It is advised to only use this option inside &#39;
            &#39;an isolated environment. Specify twice to decompile unmarshalled Python bytecode.&#39;
        )) = 0
    ):
        super().__init__(
            *paths,
            list=list,
            join_path=join_path,
            drop_path=drop_path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            path=path,
            date=date,
            decompile=decompile,
            unmarshal=unmarshal,
            user_code=user_code,
        )

    @ArchiveUnit.Requires(&#39;xdis&#39;, &#39;arc&#39;, &#39;python&#39;, &#39;extended&#39;)
    def _xdis():
        import xdis.load
        import xdis.magics
        import xdis.marsh
        import xdis.op_imports
        import xdis.version_info
        import xdis
        A, B, C, *_ = sys.version_info
        version = F&#39;{A}.{B}.{C}&#39;
        canonic = F&#39;{A}.{B}&#39;
        if version not in xdis.magics.canonic_python_version:
            import importlib.util
            magic = importlib.util.MAGIC_NUMBER
            xdis.magics.add_magic_from_int(xdis.magics.magic2int(magic), version)
            xdis.magics.by_magic.setdefault(magic, set()).add(version)
            xdis.magics.by_version[version] = magic
            xdis.magics.magics[canonic] = magic
            xdis.magics.canonic_python_version[canonic] = canonic
            xdis.magics.add_canonic_versions(version, canonic)
            xdis.op_imports.op_imports.setdefault(canonic,
                next(iter(reversed(xdis.op_imports.op_imports.values()))))
        del A, B, C, version
        import xdis.std
        return xdis

    @ArchiveUnit.Requires(&#39;uncompyle6&#39;, &#39;arc&#39;, &#39;python&#39;, &#39;extended&#39;)
    def _uncompyle6():
        import uncompyle6
        import uncompyle6.main
        return uncompyle6

    @ArchiveUnit.Requires(&#39;decompyle3&#39;, &#39;arc&#39;, &#39;python&#39;)
    def _decompyle3():
        import decompyle3
        import decompyle3.main
        return decompyle3

    def unpack(self, data):
        view = memoryview(data)
        positions = [m.start() for m in re.finditer(re.escape(PyInstallerArchiveEpilogue.MagicSignature), view)]
        mode = Unmarshal(min(2, int(self.args.unmarshal)))
        self.log_debug(F&#39;unmarshal mode: {mode.name}&#39;)
        if not positions:
            raise LookupError(&#39;unable to find PyInstaller signature&#39;)
        if len(positions) &gt; 2:
            # first position is expected to be the sentinel value in the unpacker stub
            width = max(len(F&#39;{p:X}&#39;) for p in positions)
            for position in positions:
                self.log_info(F&#39;magic signature found at offset 0x{position:0{width}X}&#39;)
            self.log_warn(F&#39;found {len(positions) - 1} potential PyInstaller epilogue markers; using last one.&#39;)
        decompile = self.args.decompile
        uc_target = PiType.USERCODE if decompile else PiType.SOURCE
        archive = PyInstallerArchiveEpilogue(view, positions[-1], mode, decompile)
        for name, file in archive.files.items():
            if self.args.user_code:
                if file.type != uc_target:
                    continue
                if name.startswith(&#39;pyiboot&#39;):
                    continue
            yield self._pack(name, None, file.data, type=file.type.name)

    @classmethod
    def handles(cls, data: ByteStr) -&gt; Optional[bool]:
        return PyInstallerArchiveEpilogue.MagicSignature in data</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.version2tuple"><code class="name flex">
<span>def <span class="ident">version2tuple</span></span>(<span>version)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L41-L42" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def version2tuple(version: str):
    return tuple(int(k, 10) for k in re.fullmatch(R&#39;^(\d+\.\d+(?:\.\d+)?)(.*)$&#39;, version).group(1).split(&#39;.&#39;))</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.decompress_peek"><code class="name flex">
<span>def <span class="ident">decompress_peek</span></span>(<span>buffer, size=512)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L45-L49" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decompress_peek(buffer, size=512) -&gt; Optional[bytes]:
    try:
        return zlib.decompressobj().decompress(buffer[:size])
    except zlib.error:
        return None</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.extract_code_from_buffer"><code class="name flex">
<span>def <span class="ident">extract_code_from_buffer</span></span>(<span>buffer, file_name=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L61-L70" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extract_code_from_buffer(buffer: ByteStr, file_name: Optional[str] = None) -&gt; Generator[Code, None, None]:
    code_objects = {}
    file_name = file_name or &#39;&lt;unknown&gt;&#39;
    load = xtpyi._xdis.load.load_module_from_file_object
    with NoLogging(NoLogging.Mode.STD_ERR):
        version, timestamp, magic_int, codes, is_pypy, _, _ = load(MemoryFile(buffer), file_name, code_objects)
    if not isinstance(codes, list):
        codes = [codes]
    for code in codes:
        yield Code(version, timestamp, magic_int, code, is_pypy, code_objects)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.disassemble_code"><code class="name flex">
<span>def <span class="ident">disassemble_code</span></span>(<span>code, version=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L73-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def disassemble_code(code: CodeType, version=None) -&gt; Iterable[Instruction]:
    dis = xtpyi._xdis
    opc = None
    if version is not None:
        if isinstance(version, float):
            version = str(version)
        if not isinstance(version, str):
            version = dis.version_info.version_tuple_to_str(version)
        with contextlib.suppress(KeyError):
            opc = dis.op_imports.op_imports[version]
    return dis.std.Bytecode(code, opc=opc)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.decompile_buffer"><code class="name flex">
<span>def <span class="ident">decompile_buffer</span></span>(<span>buffer, file_name=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L86-L160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decompile_buffer(buffer: Union[Code, ByteStr], file_name: Optional[str] = None) -&gt; ByteStr:
    main: xtpyi = xtpyi
    errors = &#39;&#39;
    python = &#39;&#39;
    codes = [buffer]

    if not isinstance(buffer, Code):
        codes = list(extract_code_from_buffer(buffer, file_name))

    def _engines():
        nonlocal errors
        try:
            dc = main._decompyle3
        except ImportError:
            errors += &#39;# The decompiler decompyle3 is not installed.\n&#39;
        else:
            yield &#39;decompyle3&#39;, dc
        try:
            dc = main._uncompyle6
        except ImportError:
            errors += &#39;# The decompiler decompyle3 is not installed.\n&#39;
        else:
            yield &#39;uncompyle6&#39;, dc

    engines = dict(_engines())

    if not engines:
        errors += &#39;# (all missing, install one of the above to enable decompilation)&#39;

    for code in codes:
        for name, engine in engines.items():
            with io.StringIO(newline=&#39;&#39;) as output, NoLogging(NoLogging.Mode.ALL):
                try:
                    engine.main.decompile(
                        co=code.container,
                        bytecode_version=code.version,
                        out=output,
                        timestamp=code.timestamp,
                        code_objects=code.code_objects,
                        is_pypy=code.is_pypi,
                        magic_int=code.magic,
                    )
                except Exception as E:
                    errors += &#39;\n&#39;.join(F&#39;# {line}&#39; for line in (
                        F&#39;Error while decompiling with {name}:&#39;, *str(E).splitlines(True)))
                    errors += &#39;\n&#39;
                else:
                    python = output.getvalue()
                    break
    if python:
        # removes leading comments
        python = python.splitlines(True)
        python.reverse()
        while python[-1].strip().startswith(&#39;#&#39;):
            python.pop()
        python.reverse()
        python = &#39;&#39;.join(python)
        return python.encode(main.codec)
    if not isinstance(buffer, Code):
        embedded = bytes(buffer | carve(&#39;printable&#39;, single=True))
        if len(buffer) - len(embedded) &lt; 0x20:
            return embedded
    disassembly = MemoryFile()
    with io.TextIOWrapper(disassembly, main.codec, newline=&#39;\n&#39;) as output:
        output.write(errors)
        output.write(&#39;# Generating Disassembly:\n\n&#39;)
        for code in codes:
            instructions = list(disassemble_code(code.container, code.version))
            width_offset = max(len(str(i.offset)) for i in instructions)
            for i in instructions:
                opname = normalize_word_separators(i.opname, &#39;.&#39;).lower()
                offset = F&#39;{i.offset:0{width_offset}d}&#39;
                output.write(F&#39;# {offset:&gt;5} {opname:&lt;25} {i.argrepr}\n&#39;)
        output.write(&#39;\n&#39;)
    return disassembly.getbuffer()</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.make_decompiled_item"><code class="name flex">
<span>def <span class="ident">make_decompiled_item</span></span>(<span>name, data, *magics)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L197-L211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def make_decompiled_item(name: str, data: ByteStr, *magics) -&gt; PiMeta:

    def extract(data=data, magics=magics):
        error = None
        if any(data[:4] == m[:4] for m in magics):
            return decompile_buffer(data, name)
        for magic in magics:
            try:
                return decompile_buffer(magic + data, name)
            except Exception as exception:
                error = exception
        return &#39;\n&#39;.join(F&#39;# {line}&#39;
            for line in str(error).splitlines(True)).encode(xtpyi.codec)

    return PiMeta(PiType.DECOMPILED, F&#39;{name}.py&#39;, extract)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.Unmarshal"><code class="flex name class">
<span>class <span class="ident">Unmarshal</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L35-L38" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Unmarshal(enum.IntEnum):
    No = 0
    Yes = 1
    YesAndDecompile = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.Unmarshal.No"><code class="name">var <span class="ident">No</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.Unmarshal.Yes"><code class="name">var <span class="ident">Yes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.Unmarshal.YesAndDecompile"><code class="name">var <span class="ident">YesAndDecompile</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.Code"><code class="flex name class">
<span>class <span class="ident">Code</span></span>
<span>(</span><span>version, timestamp, magic, container, is_pypi, code_objects)</span>
</code></dt>
<dd>
<section class="desc"><p>Code(version, timestamp, magic, container, is_pypi, code_objects)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L52-L58" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Code(NamedTuple):
    version: Tuple[int]
    timestamp: int
    magic: int
    container: CodeType
    is_pypi: bool
    code_objects: dict</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.Code.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.Code.timestamp"><code class="name">var <span class="ident">timestamp</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.Code.magic"><code class="name">var <span class="ident">magic</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.Code.container"><code class="name">var <span class="ident">container</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.Code.is_pypi"><code class="name">var <span class="ident">is_pypi</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 4</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.Code.code_objects"><code class="name">var <span class="ident">code_objects</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 5</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType"><code class="flex name class">
<span>class <span class="ident">PiType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L163-L176" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PiType(bytes, enum.Enum):
    BINARY          = B&#39;b&#39;  # noqa / binary
    DEPENDENCY      = B&#39;d&#39;  # noqa / runtime option
    PYZ             = B&#39;z&#39;  # noqa / zlib (pyz) - frozen Python code
    PACKAGE         = B&#39;M&#39;  # noqa / Python package (__init__.py)
    MODULE          = B&#39;m&#39;  # noqa / Python module
    SOURCE          = B&#39;s&#39;  # noqa / Python script (v3)
    DATA            = B&#39;x&#39;  # noqa / data
    RUNTIME_OPTION  = B&#39;o&#39;  # noqa / runtime option
    SPLASH          = B&#39;l&#39;  # noqa / splash resources
    UNKNOWN         = B&#39;uk&#39; # noqa
    DECOMPILED      = B&#39;dc&#39; # noqa
    USERCODE        = B&#39;uc&#39; # noqa
    ENCRYPTED       = B&#39;ec&#39; # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.bytes</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PiType.BINARY"><code class="name">var <span class="ident">BINARY</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.DEPENDENCY"><code class="name">var <span class="ident">DEPENDENCY</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.PYZ"><code class="name">var <span class="ident">PYZ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.PACKAGE"><code class="name">var <span class="ident">PACKAGE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.MODULE"><code class="name">var <span class="ident">MODULE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.SOURCE"><code class="name">var <span class="ident">SOURCE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.DATA"><code class="name">var <span class="ident">DATA</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.RUNTIME_OPTION"><code class="name">var <span class="ident">RUNTIME_OPTION</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.SPLASH"><code class="name">var <span class="ident">SPLASH</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.UNKNOWN"><code class="name">var <span class="ident">UNKNOWN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.DECOMPILED"><code class="name">var <span class="ident">DECOMPILED</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.USERCODE"><code class="name">var <span class="ident">USERCODE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.ENCRYPTED"><code class="name">var <span class="ident">ENCRYPTED</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PzType"><code class="flex name class">
<span>class <span class="ident">PzType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L179-L182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PzType(enum.IntEnum):
    MODULE = 0
    PKG = 1
    DATA = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PzType.MODULE"><code class="name">var <span class="ident">MODULE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PzType.PKG"><code class="name">var <span class="ident">PKG</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PzType.DATA"><code class="name">var <span class="ident">DATA</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiMeta"><code class="flex name class">
<span>class <span class="ident">PiMeta</span></span>
<span>(</span><span>type, name, data)</span>
</code></dt>
<dd>
<section class="desc"><p>PiMeta(type: 'PiType', name: 'str', data: 'Union[Callable[[], ByteStr], ByteStr]')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L186-L194" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PiMeta:
    type: PiType
    name: str
    data: Union[Callable[[], ByteStr], ByteStr]

    def unpack(self) -&gt; ByteStr:
        if callable(self.data):
            self.data = self.data()
        return self.data</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PiMeta.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiMeta.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiMeta.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PiMeta.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L191-L194" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self) -&gt; ByteStr:
    if callable(self.data):
        self.data = self.data()
    return self.data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PYZ"><code class="flex name class">
<span>class <span class="ident">PYZ</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L214-L328" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PYZ(Struct):

    MagicSignature = B&#39;PYZ\0&#39;

    def __init__(self, reader: StructReader, version: str):
        reader.bigendian = True
        self.base = reader.tell()
        signature = reader.read(4)
        if signature != self.MagicSignature:
            raise ValueError(&#39;invalid magic&#39;)
        magic = bytes(reader.read(4))
        with contextlib.suppress(KeyError, AttributeError):
            xdis = xtpyi._xdis
            if isinstance(xdis, property):
                xdis = xdis.fget()
            version = xdis.magics.versions[magic]
        vtuple = version2tuple(version)
        padding_size = 4
        if vtuple &gt;= (3, 3):
            padding_size += 4
        if vtuple &gt;= (3, 7):
            padding_size += 4
        self.version = version
        self.magic = magic + padding_size * b&#39;\0&#39;
        self.toc_offset = reader.i32()
        self.reader = reader
        self.entries: List[PiMeta] = []

    def unpack(self, decompile: bool, key: Optional[bytes] = None) -&gt; bool:
        with StreamDetour(self.reader, self.base + self.toc_offset):
            toc_data = self.reader.read()
        try:
            toc = marshal.loads(toc_data)
        except Exception as error:
            if MAGIC_NUMBER != self.magic[:4]:
                xdis = xtpyi._xdis
                if isinstance(xdis, property):
                    xdis = xdis.fget()
                _ord = xdis.marsh.Ord
                xdis.marsh.Ord = ord  # monkey-patch workaround for bug in xdis
                try:
                    toc = xdis.marsh.load(
                        MemoryFile(self.data), self.version)
                except Exception:
                    pass
                else:
                    error = None
                finally:
                    xdis.marsh.Ord = _ord
            if error is not None:
                raise error

        if isinstance(toc, list):
            try:
                toc = dict(toc)
            except Exception as error:
                self.entries = []
                self.error = error
                return

        failures = 0
        attempts = len(toc)

        for name, (pzt, offset, length) in toc.items():
            try:
                name: str
                name = name.decode(&#39;utf-8&#39;)
            except AttributeError:
                pass
            try:
                pzt = PzType(pzt)
            except Exception:
                pzt = PzType.DATA

            name = name.replace(&#39;.&#39;, &#39;/&#39;)
            if pzt is PzType.PKG:
                name = F&#39;{name}/__init__&#39;

            with StreamDetour(self.reader, self.base + offset):
                data = self.reader.read(length)

            if key:
                def decompressed(data=data):
                    cipher = AES.new(key, AES.MODE_CFB, bytes(data[:0x10]))
                    return zlib.decompress(cipher.decrypt(data[0x10:]))
            elif decompress_peek(data):
                def decompressed(data=data):
                    return zlib.decompress(data)
            else:
                failures += 1
                continue

            if decompile and pzt in (PzType.MODULE, PzType.PKG):
                def decompiled(data=data, name=name, magic=self.magic):
                    data = decompressed(data)
                    if data[:4] != magic[:4]:
                        data = magic + data
                    return decompile_buffer(data, name)
                self.entries.append(PiMeta(PiType.DECOMPILED, F&#39;{name}.py&#39;, decompiled))
                name = F&#39;{name}.pyc&#39;
                type = PiType.SOURCE
            else:
                type = PiType.DATA

            self.entries.append(PiMeta(type, name, decompressed))

        if key:
            if failures &gt;= 6:
                xtpyi.logger.warning(F&#39;pyz decompression failed for {failures - 5} additional items&#39;)
            return True
        elif failures &gt; 0.7 * attempts:
            self.entries.clear()
            return False
        else:
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PYZ.MagicSignature"><code class="name">var <span class="ident">MagicSignature</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PYZ.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, decompile, key=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L242-L328" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self, decompile: bool, key: Optional[bytes] = None) -&gt; bool:
    with StreamDetour(self.reader, self.base + self.toc_offset):
        toc_data = self.reader.read()
    try:
        toc = marshal.loads(toc_data)
    except Exception as error:
        if MAGIC_NUMBER != self.magic[:4]:
            xdis = xtpyi._xdis
            if isinstance(xdis, property):
                xdis = xdis.fget()
            _ord = xdis.marsh.Ord
            xdis.marsh.Ord = ord  # monkey-patch workaround for bug in xdis
            try:
                toc = xdis.marsh.load(
                    MemoryFile(self.data), self.version)
            except Exception:
                pass
            else:
                error = None
            finally:
                xdis.marsh.Ord = _ord
        if error is not None:
            raise error

    if isinstance(toc, list):
        try:
            toc = dict(toc)
        except Exception as error:
            self.entries = []
            self.error = error
            return

    failures = 0
    attempts = len(toc)

    for name, (pzt, offset, length) in toc.items():
        try:
            name: str
            name = name.decode(&#39;utf-8&#39;)
        except AttributeError:
            pass
        try:
            pzt = PzType(pzt)
        except Exception:
            pzt = PzType.DATA

        name = name.replace(&#39;.&#39;, &#39;/&#39;)
        if pzt is PzType.PKG:
            name = F&#39;{name}/__init__&#39;

        with StreamDetour(self.reader, self.base + offset):
            data = self.reader.read(length)

        if key:
            def decompressed(data=data):
                cipher = AES.new(key, AES.MODE_CFB, bytes(data[:0x10]))
                return zlib.decompress(cipher.decrypt(data[0x10:]))
        elif decompress_peek(data):
            def decompressed(data=data):
                return zlib.decompress(data)
        else:
            failures += 1
            continue

        if decompile and pzt in (PzType.MODULE, PzType.PKG):
            def decompiled(data=data, name=name, magic=self.magic):
                data = decompressed(data)
                if data[:4] != magic[:4]:
                    data = magic + data
                return decompile_buffer(data, name)
            self.entries.append(PiMeta(PiType.DECOMPILED, F&#39;{name}.py&#39;, decompiled))
            name = F&#39;{name}.pyc&#39;
            type = PiType.SOURCE
        else:
            type = PiType.DATA

        self.entries.append(PiMeta(type, name, decompressed))

    if key:
        if failures &gt;= 6:
            xtpyi.logger.warning(F&#39;pyz decompression failed for {failures - 5} additional items&#39;)
        return True
    elif failures &gt; 0.7 * attempts:
        self.entries.clear()
        return False
    else:
        return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiTOCEntry"><code class="flex name class">
<span>class <span class="ident">PiTOCEntry</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L331-L363" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PiTOCEntry(Struct):

    def __init__(self, reader: StructReader):
        reader.bigendian = True
        entry_start_offset = reader.tell()
        self.size_of_entry = reader.i32()
        self.offset = reader.i32()
        self.size_of_compressed_data = reader.i32()
        self.size_od_uncompressed_data = reader.i32()
        self.is_compressed = bool(reader.read_byte())
        entry_type = bytes(reader.read(1))
        name_length = self.size_of_entry - reader.tell() + entry_start_offset
        if name_length &gt; 0x1000:
            raise RuntimeError(F&#39;Refusing to process TOC entry with name of size {name_length}.&#39;)
        name, *_ = bytes(reader.read(name_length)).partition(B&#39;\0&#39;)
        try:
            name = name.decode(&#39;utf8&#39;, &#39;backslashreplace&#39;)
        except Exception:
            name = None
        if not all(part.isprintable() for part in re.split(&#39;\\s*&#39;, name)):
            raise RuntimeError(&#39;Refusing to process TOC entry with non-printable name.&#39;)
        name = name or str(uuid.uuid4())
        if entry_type == B&#39;Z&#39;:
            entry_type = B&#39;z&#39;
        try:
            self.type = PiType(entry_type)
        except ValueError:
            xtpyi.log_warn(F&#39;unknown type {entry_type!r} in field {name}&#39;)
            self.type = PiType.UNKNOWN
        self.name = name

    def __hash__(self):
        return hash(self.name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue"><code class="flex name class">
<span>class <span class="ident">PyInstallerArchiveEpilogue</span></span>
<span>(</span><span>reader, offset, unmarshal=Unmarshal.No, decompile=False)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L366-L514" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PyInstallerArchiveEpilogue(Struct):

    MagicSignature = bytes.fromhex(&#39;4D45490C0B0A0B0E&#39;)

    def _read_libname(self, reader: StructReader) -&gt; Optional[str]:
        position = reader.tell()
        try:
            libname, t, rest = reader.read_bytes(64).partition(B&#39;\0&#39;)
        except EOFError:
            reader.seekset(position)
            return None
        try:
            libname = libname.decode(&#39;utf8&#39;)
        except Exception:
            reader.seekset(position)
            return None
        if not t or any(rest) or len(rest) &lt; 10 or not re.fullmatch(R&#39;[\s!-~]+&#39;, libname):
            reader.seekset(position)
            return None
        return libname

    def __init__(self, reader: StructReader, offset: int, unmarshal: Unmarshal = Unmarshal.No, decompile: bool = False):
        self.decompile = decompile
        reader.bigendian = True
        reader.seekset(offset)
        self.reader = reader
        signature = reader.read_bytes(8)
        if signature != self.MagicSignature:
            raise ValueError(
                F&#39;offset 0x{offset:X} has invalid signature {signature.hex().upper()}; &#39;
                F&#39;should be {self.MagicSignature.hex().upper()}&#39;)
        self.size = reader.i32()
        toc_offset = reader.i32()
        toc_length = reader.i32()
        self.py_version = &#39;.&#39;.join(str(reader.u32()))
        self.py_libname = self._read_libname(reader)
        self.offset = reader.tell() - self.size

        self.toc: Dict[str, PiTOCEntry] = {}
        toc_end = self.offset + toc_offset + toc_length
        reader.seekset(self.offset + toc_offset)
        while reader.tell() &lt; toc_end:
            try:
                entry = PiTOCEntry(reader)
            except EOFError:
                xtpyi.logger.warning(&#39;end of file while reading TOC&#39;)
                break
            except Exception as error:
                xtpyi.logger.warning(F&#39;unexpected error while reading TOC: {error!s}&#39;)
                break
            if entry.name in self.toc:
                raise KeyError(F&#39;duplicate name {entry.name}&#39;)
            self.toc[entry.name] = entry

        self.files: Dict[str, PiMeta] = {}
        no_pyz_found = True
        pyz_entries: Dict[str, PYZ] = {}

        for entry in list(self.toc.values()):
            if entry.type is not PiType.PYZ:
                continue
            no_pyz_found = False
            name, xt = os.path.splitext(entry.name)
            name_pyz = F&#39;{name}.pyz&#39;
            if name == entry.name:
                del self.toc[name]
                self.toc[name_pyz] = entry
                entry.name = name_pyz
            reader.seekset(self.offset + entry.offset)
            if entry.is_compressed:
                data = self.extract(entry.name).unpack()
            else:
                data = reader
            pyz_entries[name] = PYZ(data, self.py_version)

        magics = {pyz.magic for pyz in pyz_entries.values()}

        if not magics:
            if not no_pyz_found:
                xtpyi.logger.warning(
                    &#39;no magic signature could be recovered from embedded pyzip archives; this is &#39;
                    &#39;unsual and means that there is no way to guess the missing magic for source &#39;
                    &#39;file entries and it will likely not be possible to decompile them.&#39;)
            return
        elif len(magics) &gt; 1:
            xtpyi.logger.warning(&#39;more than one magic signature was recovered; this is unusual.&#39;)

        magics = list(magics)
        keys: Set[bytes] = set()

        for entry in self.toc.values():
            extracted = self.extract(entry.name)
            if entry.type not in (PiType.SOURCE, PiType.MODULE):
                self.files[entry.name] = extracted
                continue
            data = extracted.unpack()
            name, _ = os.path.splitext(extracted.name)
            del self.files[extracted.name]
            extracted.name = F&#39;{name}.pyc&#39;
            self.files[extracted.name] = extracted
            is_crypto_key = name.endswith(&#39;crypto_key&#39;)

            if len(magics) == 1 and data[:4] != magics[0]:
                extracted.data = magics[0] + data

            if is_crypto_key or self.decompile:
                decompiled = make_decompiled_item(name, data, *magics)
                if entry.type is PiType.SOURCE:
                    decompiled.type = PiType.USERCODE
                self.files[decompiled.name] = decompiled

            if is_crypto_key:
                for key in decompiled.unpack() | carve(&#39;string&#39;, decode=True):
                    if len(key) != 0x10:
                        continue
                    xtpyi.logger.info(F&#39;found key: {key.decode(xtpyi.codec)}&#39;)
                    keys.add(key)

        if unmarshal is Unmarshal.No:
            return

        if not keys:
            key = None
        else:
            key = next(iter(keys))

        for name, pyz in pyz_entries.items():
            pyz.unpack(unmarshal is Unmarshal.YesAndDecompile, key)
            for unpacked in pyz.entries:
                unpacked.name = path = F&#39;{name}/{unpacked.name}&#39;
                if path in self.files:
                    raise ValueError(F&#39;duplicate file name: {path}&#39;)
                self.files[path] = unpacked

    def extract(self, name: str) -&gt; PiMeta:
        try:
            return self.files[name]
        except KeyError:
            pass
        entry = self.toc[name]
        with StreamDetour(self.reader, self.offset + entry.offset):
            data = self.reader.read(entry.size_of_compressed_data)
        if entry.is_compressed:
            def extracted(d=data): return zlib.decompress(d)
        else:
            extracted = data
        result = PiMeta(entry.type, name, extracted)
        self.files[name] = result
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue.MagicSignature"><code class="name">var <span class="ident">MagicSignature</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L500-L514" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extract(self, name: str) -&gt; PiMeta:
    try:
        return self.files[name]
    except KeyError:
        pass
    entry = self.toc[name]
    with StreamDetour(self.reader, self.offset + entry.offset):
        data = self.reader.read(entry.size_of_compressed_data)
    if entry.is_compressed:
        def extracted(d=data): return zlib.decompress(d)
    else:
        extracted = data
    result = PiMeta(entry.type, name, extracted)
    self.files[name] = result
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.xtpyi"><code class="flex name class">
<span>class <span class="ident">xtpyi</span></span>
<span>(</span><span>*paths, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False, path=b'path', date=b'date', decompile, user_code=False, unmarshal=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts and decompiles files from a Python Installer (aka PyInstaller) archive.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L517-L613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class xtpyi(ArchiveUnit):
    &#34;&#34;&#34;
    Extracts and decompiles files from a Python Installer (aka PyInstaller) archive.
    &#34;&#34;&#34;
    def __init__(
        self, *paths, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False,
        path=b&#39;path&#39;, date=b&#39;date&#39;,
        decompile: Arg.Switch(&#39;-c&#39;, help=&#39;Attempt to decompile PYC files.&#39;),
        user_code: Arg.Switch(&#39;-u&#39;, group=&#39;FILTER&#39;, help=(
            &#39;Extract only source code files from the root of the archive. These usually implement &#39;
            &#39;the actual domain logic. This implies the --decompile option.&#39;)) = False,
        unmarshal: Arg(&#39;-y&#39;, action=&#39;count&#39;, group=&#39;FILTER&#39;, help=(
            &#39;(DANGEROUS) Unmarshal embedded PYZ archives. Warning: Maliciously crafted packages can &#39;
            &#39;potentially exploit this to execute code. It is advised to only use this option inside &#39;
            &#39;an isolated environment. Specify twice to decompile unmarshalled Python bytecode.&#39;
        )) = 0
    ):
        super().__init__(
            *paths,
            list=list,
            join_path=join_path,
            drop_path=drop_path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            path=path,
            date=date,
            decompile=decompile,
            unmarshal=unmarshal,
            user_code=user_code,
        )

    @ArchiveUnit.Requires(&#39;xdis&#39;, &#39;arc&#39;, &#39;python&#39;, &#39;extended&#39;)
    def _xdis():
        import xdis.load
        import xdis.magics
        import xdis.marsh
        import xdis.op_imports
        import xdis.version_info
        import xdis
        A, B, C, *_ = sys.version_info
        version = F&#39;{A}.{B}.{C}&#39;
        canonic = F&#39;{A}.{B}&#39;
        if version not in xdis.magics.canonic_python_version:
            import importlib.util
            magic = importlib.util.MAGIC_NUMBER
            xdis.magics.add_magic_from_int(xdis.magics.magic2int(magic), version)
            xdis.magics.by_magic.setdefault(magic, set()).add(version)
            xdis.magics.by_version[version] = magic
            xdis.magics.magics[canonic] = magic
            xdis.magics.canonic_python_version[canonic] = canonic
            xdis.magics.add_canonic_versions(version, canonic)
            xdis.op_imports.op_imports.setdefault(canonic,
                next(iter(reversed(xdis.op_imports.op_imports.values()))))
        del A, B, C, version
        import xdis.std
        return xdis

    @ArchiveUnit.Requires(&#39;uncompyle6&#39;, &#39;arc&#39;, &#39;python&#39;, &#39;extended&#39;)
    def _uncompyle6():
        import uncompyle6
        import uncompyle6.main
        return uncompyle6

    @ArchiveUnit.Requires(&#39;decompyle3&#39;, &#39;arc&#39;, &#39;python&#39;)
    def _decompyle3():
        import decompyle3
        import decompyle3.main
        return decompyle3

    def unpack(self, data):
        view = memoryview(data)
        positions = [m.start() for m in re.finditer(re.escape(PyInstallerArchiveEpilogue.MagicSignature), view)]
        mode = Unmarshal(min(2, int(self.args.unmarshal)))
        self.log_debug(F&#39;unmarshal mode: {mode.name}&#39;)
        if not positions:
            raise LookupError(&#39;unable to find PyInstaller signature&#39;)
        if len(positions) &gt; 2:
            # first position is expected to be the sentinel value in the unpacker stub
            width = max(len(F&#39;{p:X}&#39;) for p in positions)
            for position in positions:
                self.log_info(F&#39;magic signature found at offset 0x{position:0{width}X}&#39;)
            self.log_warn(F&#39;found {len(positions) - 1} potential PyInstaller epilogue markers; using last one.&#39;)
        decompile = self.args.decompile
        uc_target = PiType.USERCODE if decompile else PiType.SOURCE
        archive = PyInstallerArchiveEpilogue(view, positions[-1], mode, decompile)
        for name, file in archive.files.items():
            if self.args.user_code:
                if file.type != uc_target:
                    continue
                if name.startswith(&#39;pyiboot&#39;):
                    continue
            yield self._pack(name, None, file.data, type=file.type.name)

    @classmethod
    def handles(cls, data: ByteStr) -&gt; Optional[bool]:
        return PyInstallerArchiveEpilogue.MagicSignature in data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.ArchiveUnit" href="index.html#refinery.units.formats.archive.ArchiveUnit">ArchiveUnit</a></li>
<li><a title="refinery.units.formats.PathExtractorUnit" href="../index.html#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></li>
<li><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.xtpyi.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.xtpyi.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.xtpyi.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtpyi.py#L587-L609" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self, data):
    view = memoryview(data)
    positions = [m.start() for m in re.finditer(re.escape(PyInstallerArchiveEpilogue.MagicSignature), view)]
    mode = Unmarshal(min(2, int(self.args.unmarshal)))
    self.log_debug(F&#39;unmarshal mode: {mode.name}&#39;)
    if not positions:
        raise LookupError(&#39;unable to find PyInstaller signature&#39;)
    if len(positions) &gt; 2:
        # first position is expected to be the sentinel value in the unpacker stub
        width = max(len(F&#39;{p:X}&#39;) for p in positions)
        for position in positions:
            self.log_info(F&#39;magic signature found at offset 0x{position:0{width}X}&#39;)
        self.log_warn(F&#39;found {len(positions) - 1} potential PyInstaller epilogue markers; using last one.&#39;)
    decompile = self.args.decompile
    uc_target = PiType.USERCODE if decompile else PiType.SOURCE
    archive = PyInstallerArchiveEpilogue(view, positions[-1], mode, decompile)
    for name, file in archive.files.items():
        if self.args.user_code:
            if file.type != uc_target:
                continue
            if name.startswith(&#39;pyiboot&#39;):
                continue
        yield self._pack(name, None, file.data, type=file.type.name)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.formats.archive.ArchiveUnit" href="index.html#refinery.units.formats.archive.ArchiveUnit">ArchiveUnit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.Arg" href="../../index.html#refinery.units.Unit.Arg">Arg</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.CustomPathSeparator" href="../index.html#refinery.units.formats.PathExtractorUnit.CustomPathSeparator">CustomPathSeparator</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.assemble" href="../../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.filter" href="../../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.finish" href="../../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.handles" href="../../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.is_quiet" href="../../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.labelled" href="../../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.leniency" href="../../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_debug" href="../../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_detach" href="../../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_fail" href="../../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_info" href="../../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_level" href="../../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_warn" href="../../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.nozzle" href="../../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.process" href="../../index.html#refinery.units.UnitBase.process">process</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.read" href="../../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.read1" href="../../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.reverse" href="../../index.html#refinery.units.UnitBase.reverse">reverse</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.run" href="../../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.source" href="../../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.superinit" href="../../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.formats.archive" href="index.html">refinery.units.formats.archive</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtpyi.version2tuple" href="#refinery.units.formats.archive.xtpyi.version2tuple">version2tuple</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtpyi.decompress_peek" href="#refinery.units.formats.archive.xtpyi.decompress_peek">decompress_peek</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtpyi.extract_code_from_buffer" href="#refinery.units.formats.archive.xtpyi.extract_code_from_buffer">extract_code_from_buffer</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtpyi.disassemble_code" href="#refinery.units.formats.archive.xtpyi.disassemble_code">disassemble_code</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtpyi.decompile_buffer" href="#refinery.units.formats.archive.xtpyi.decompile_buffer">decompile_buffer</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtpyi.make_decompiled_item" href="#refinery.units.formats.archive.xtpyi.make_decompiled_item">make_decompiled_item</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.Unmarshal" href="#refinery.units.formats.archive.xtpyi.Unmarshal">Unmarshal</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.Code" href="#refinery.units.formats.archive.xtpyi.Code">Code</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PiType" href="#refinery.units.formats.archive.xtpyi.PiType">PiType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PzType" href="#refinery.units.formats.archive.xtpyi.PzType">PzType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PiMeta" href="#refinery.units.formats.archive.xtpyi.PiMeta">PiMeta</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtpyi.PiMeta.unpack" href="#refinery.units.formats.archive.xtpyi.PiMeta.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PYZ" href="#refinery.units.formats.archive.xtpyi.PYZ">PYZ</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtpyi.PYZ.unpack" href="#refinery.units.formats.archive.xtpyi.PYZ.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PiTOCEntry" href="#refinery.units.formats.archive.xtpyi.PiTOCEntry">PiTOCEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue" href="#refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue">PyInstallerArchiveEpilogue</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue.extract" href="#refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue.extract">extract</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.xtpyi" href="#refinery.units.formats.archive.xtpyi.xtpyi">xtpyi</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtpyi.xtpyi.unpack" href="#refinery.units.formats.archive.xtpyi.xtpyi.unpack">unpack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>