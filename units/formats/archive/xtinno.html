<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>the refinery.units.formats.archive.xtinno documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats.archive.xtinno</code></h1>
</header>
<section id="section-intro">
<p>InnoSetup parsing based on <a href="https://constexpr.org/innoextract/">innoextract</a> source code and its Python port in <a href="https://malcat.fr/">Malcat</a>.
The <a href="https://malcat.fr/">Malcat</a> implementation served as the initial template but was re-written to work
with refinery's data structures.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1-L2662" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
InnoSetup parsing based on [innoextract][IE] source code and its Python port in [Malcat][MC].
The [Malcat][MC] implementation served as the initial template but was re-written to work
with refinery&#39;s data structures.

[IE]: https://constexpr.org/innoextract/
[MC]: https://malcat.fr/
&#34;&#34;&#34;
from __future__ import annotations

import enum
import re
import struct
import functools
import base64
import dataclasses
import codecs

import lzma
import zlib
import bz2

from datetime import datetime, timezone
from hashlib import sha256, sha1, md5

from refinery.units.formats.archive import ArchiveUnit
from refinery.units.formats.pe.perc import perc
from refinery.lib.structures import Struct, StructReader
from refinery.lib.mime import FileMagicInfo as magic

from refinery.lib.tools import exception_to_string, one
from refinery.lib.lcid import LCID, DEFAULT_CODEPAGE
from refinery.lib.types import ByteStr
from refinery.lib.json import BytesAsStringEncoder
from refinery.lib.decompression import parse_lzma_properties

from refinery.units.crypto.cipher.rc4 import rc4
from refinery.units.crypto.cipher.chacha import xchacha
from refinery.units.crypto.keyderive.pbkdf2 import pbkdf2

from typing import TYPE_CHECKING, NamedTuple

if TYPE_CHECKING:
    from typing import (
        List,
        Optional,
        Type,
        TypeVar,
    )
    _T = TypeVar(&#39;_T&#39;)
    _E = TypeVar(&#39;_T&#39;, bound=enum.IntEnum)


class InvalidPassword(ValueError):
    def __init__(self, password: Optional[str] = None):
        if password is None:
            super().__init__(&#39;A password is required and none was given.&#39;)
        else:
            super().__init__(&#39;The given password is not correct.&#39;)


class IncorrectVersion(RuntimeError):
    pass


class FileChunkOutOfBounds(LookupError):
    pass


class IVF(enum.IntFlag):
    NoFlag   = 0b0000 # noqa
    Legacy   = 0b0001 # noqa
    Bits16   = 0b0010 # noqa
    UTF_16   = 0b0100 # noqa
    InnoSX   = 0b1000 # noqa
    Legacy32 = 0b0001
    Legacy16 = 0b0011
    IsLegacy = 0b0011


def _enum(options: Type[_E], value: int, default: _E):
    try:
        return options(value)
    except ValueError:
        return default


class InnoVersion(NamedTuple):
    major: int
    minor: int
    patch: int
    build: int = 0
    flags: IVF = IVF.NoFlag

    @property
    def semver(self):
        return (self.major, self.minor, self.patch, self.build)

    @property
    def unicode(self):
        return self.flags &amp; IVF.UTF_16 == IVF.UTF_16

    @property
    def legacy(self):
        return self.flags &amp; IVF.Legacy

    @property
    def ascii(self):
        return self.flags &amp; IVF.UTF_16 == IVF.NoFlag

    @property
    def isx(self):
        return bool(self.flags &amp; IVF.InnoSX)

    @property
    def bits(self):
        return 0x10 if self.flags &amp; IVF.Bits16 else 0x20

    @classmethod
    def ParseLegacy(cls, dfn: bytes):
        v, s, _ = dfn.partition(B&#39;\x1A&#39;)
        if s and (m := re.fullmatch(BR&#39;i(\d+)\.(\d+)\.(\d+)--(16|32)&#39;, v)):
            major = int(m[1])
            minor = int(m[2])
            build = int(m[3])
            flags = IVF.Legacy16 if m[3] == B&#39;16&#39; else IVF.Legacy32
            return cls(major, minor, build, 0, flags)
        raise ValueError(dfn)

    @classmethod
    def Parse(cls, dfn: bytes):
        versions: List[InnoVersion] = []
        for match in [m.groups() for m in re.finditer(rb&#39;(.*?)\((\d+(?:\.\d+){2,3})(?:.*?\(([uU])\))?&#39;, dfn)]:
            sv = tuple(map(int, match[1].split(B&#39;.&#39;)))
            sv = (sv + (0,))[:4]
            vf = IVF.NoFlag
            if sv &gt;= (6, 3, 0) or match[2]:
                vf |= IVF.UTF_16
            if any(isx in match[0] for isx in (B&#39;My Inno Setup Extensions&#39;, B&#39;with ISX&#39;)):
                vf |= IVF.InnoSX
            versions.append(InnoVersion(*sv, vf))
        if len(versions) == 1:
            return versions[0]
        if len(versions) == 2:
            a, b = versions
            return InnoVersion(*max(a.semver, b.semver), a.flags | b.flags)
        raise ValueError(dfn)

    def __str__(self):
        v = F&#39;v{self.major}.{self.minor}.{self.patch:02d}.{self.build}&#39;
        a = R&#39;a&#39;
        u = R&#39;u&#39;
        if self.flags &amp; IVF.InnoSX:
            a = R&#39;&#39;
            v = F&#39;{v}x&#39;
        t = u if self.flags &amp; IVF.UTF_16 else a
        v = F&#39;{v}{t}&#39;
        if b := {
            IVF.Legacy16: &#39;16&#39;,
            IVF.Legacy32: &#39;32&#39;,
        }.get(self.flags &amp; IVF.IsLegacy):
            v = F&#39;{v}/{b}&#39;
        return v

    def __repr__(self):
        return str(self)

    def is_ambiguous(self):
        try:
            return _IS_AMBIGUOUS[self]
        except KeyError:
            return True


_I = InnoVersion

_FILE_TIME_1970_01_01 = 116444736000000000
_DEFAULT_INNO_VERSION = _I(5, 0, 0, 0, IVF.UTF_16)

_IS_AMBIGUOUS = {
    _I(1, 2, 10, 0, IVF.Legacy16): False,
    _I(1, 2, 10, 0, IVF.Legacy32): False,
    _I(1, 3,  3, 0, IVF.NoFlag): False, # noqa
    _I(1, 3,  9, 0, IVF.NoFlag): False, # noqa
    _I(1, 3, 10, 0, IVF.NoFlag): False, # noqa
    _I(1, 3, 10, 0, IVF.InnoSX): False, # noqa
    _I(1, 3, 12, 1, IVF.InnoSX): False, # noqa
    _I(1, 3, 21, 0, IVF.NoFlag): True,  # noqa
    _I(1, 3, 21, 0, IVF.InnoSX): True,  # noqa
    _I(1, 3, 24, 0, IVF.NoFlag): False, # noqa
    _I(1, 3, 24, 0, IVF.InnoSX): False, # noqa
    _I(1, 3, 25, 0, IVF.NoFlag): False, # noqa
    _I(1, 3, 25, 0, IVF.InnoSX): False, # noqa
    _I(2, 0,  0, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  1, 0, IVF.NoFlag): True,  # noqa
    _I(2, 0,  2, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  5, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  6, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  6, 0, IVF.InnoSX): False, # noqa
    _I(2, 0,  7, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  8, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  8, 0, IVF.InnoSX): False, # noqa
    _I(2, 0, 10, 0, IVF.InnoSX): False, # noqa
    _I(2, 0, 11, 0, IVF.NoFlag): False, # noqa
    _I(2, 0, 11, 0, IVF.InnoSX): False, # noqa
    _I(2, 0, 17, 0, IVF.NoFlag): False, # noqa
    _I(2, 0, 17, 0, IVF.InnoSX): False, # noqa
    _I(2, 0, 18, 0, IVF.NoFlag): False, # noqa
    _I(2, 0, 18, 0, IVF.InnoSX): False, # noqa
    _I(3, 0,  0, 0, IVF.NoFlag): False, # noqa
    _I(3, 0,  1, 0, IVF.NoFlag): False, # noqa
    _I(3, 0,  1, 0, IVF.InnoSX): False, # noqa
    _I(3, 0,  3, 0, IVF.NoFlag): True,  # noqa
    _I(3, 0,  3, 0, IVF.InnoSX): True,  # noqa
    _I(3, 0,  4, 0, IVF.NoFlag): False, # noqa
    _I(3, 0,  4, 0, IVF.InnoSX): False, # noqa
    _I(3, 0,  5, 0, IVF.NoFlag): False, # noqa
    _I(3, 0,  6, 1, IVF.InnoSX): False, # noqa
    _I(4, 0,  0, 0, IVF.NoFlag): False, # noqa
    _I(4, 0,  1, 0, IVF.NoFlag): False, # noqa
    _I(4, 0,  3, 0, IVF.NoFlag): False, # noqa
    _I(4, 0,  5, 0, IVF.NoFlag): False, # noqa
    _I(4, 0,  9, 0, IVF.NoFlag): False, # noqa
    _I(4, 0, 10, 0, IVF.NoFlag): False, # noqa
    _I(4, 0, 11, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  0, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  2, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  3, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  4, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  5, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  6, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  8, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  0, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  1, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  2, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  3, 0, IVF.NoFlag): True,  # noqa
    _I(4, 2,  4, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  5, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  6, 0, IVF.NoFlag): False, # noqa
    _I(5, 0,  0, 0, IVF.NoFlag): False, # noqa
    _I(5, 0,  1, 0, IVF.NoFlag): False, # noqa
    _I(5, 0,  3, 0, IVF.NoFlag): False, # noqa
    _I(5, 0,  4, 0, IVF.NoFlag): False, # noqa
    _I(5, 1,  0, 0, IVF.NoFlag): False, # noqa
    _I(5, 1,  2, 0, IVF.NoFlag): False, # noqa
    _I(5, 1,  7, 0, IVF.NoFlag): False, # noqa
    _I(5, 1, 10, 0, IVF.NoFlag): False, # noqa
    _I(5, 1, 13, 0, IVF.NoFlag): False, # noqa
    _I(5, 2,  0, 0, IVF.NoFlag): False, # noqa
    _I(5, 2,  1, 0, IVF.NoFlag): False, # noqa
    _I(5, 2,  3, 0, IVF.NoFlag): False, # noqa
    _I(5, 2,  5, 0, IVF.NoFlag): False, # noqa
    _I(5, 2,  5, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  0, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  0, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  3, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  3, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  5, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  5, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  6, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  6, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  7, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  7, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  8, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  8, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  9, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  9, 0, IVF.UTF_16): False, # noqa
    _I(5, 3, 10, 0, IVF.NoFlag): True,  # noqa
    _I(5, 3, 10, 0, IVF.UTF_16): True,  # noqa
    _I(5, 3, 10, 1, IVF.NoFlag): False, # noqa
    _I(5, 3, 10, 1, IVF.UTF_16): False, # noqa
    _I(5, 4,  2, 0, IVF.NoFlag): True,  # noqa
    _I(5, 4,  2, 0, IVF.UTF_16): True,  # noqa
    _I(5, 4,  2, 1, IVF.NoFlag): False, # noqa
    _I(5, 4,  2, 1, IVF.UTF_16): False, # noqa
    _I(5, 5,  0, 0, IVF.NoFlag): True,  # noqa
    _I(5, 5,  0, 0, IVF.UTF_16): True,  # noqa
    _I(5, 5,  0, 1, IVF.NoFlag): False, # noqa
    _I(5, 5,  0, 1, IVF.UTF_16): False, # noqa
    _I(5, 5,  6, 0, IVF.NoFlag): False, # noqa
    _I(5, 5,  6, 0, IVF.UTF_16): False, # noqa
    _I(5, 5,  7, 0, IVF.NoFlag): True,  # noqa
    _I(5, 5,  7, 0, IVF.UTF_16): True,  # noqa
    _I(5, 5,  7, 1, IVF.NoFlag): True,  # noqa
    _I(5, 5,  7, 1, IVF.UTF_16): True,  # noqa
    _I(5, 6,  0, 0, IVF.NoFlag): False, # noqa
    _I(5, 6,  0, 0, IVF.UTF_16): False, # noqa
    _I(5, 6,  2, 0, IVF.NoFlag): False, # noqa
    _I(5, 6,  2, 0, IVF.UTF_16): False, # noqa
    _I(6, 0,  0, 0, IVF.UTF_16): False, # noqa
    _I(6, 1,  0, 0, IVF.UTF_16): False, # noqa
    _I(6, 3,  0, 0, IVF.UTF_16): False, # noqa
    _I(6, 4,  0, 0, IVF.UTF_16): False, # noqa
    _I(6, 4,  0, 1, IVF.UTF_16): False, # noqa
}

_VERSIONS = sorted(_IS_AMBIGUOUS)


class JsonStruct(Struct):
    def json(self):
        def _json(v):
            if isinstance(v, list):
                return [_json(x) for x in v]
            if isinstance(v, dict):
                return {x: _json(y) for x, y in v.items()}
            if isinstance(v, JsonStruct):
                return v.json()
            if isinstance(v, enum.IntFlag):
                return [option.name for option in v.__class__ if v &amp; option == option]
            if isinstance(v, enum.IntEnum):
                return v.name
            if isinstance(v, memoryview):
                return codecs.decode(v, &#39;latin1&#39;)
            return v
        return {
            k: _json(v) for k, v in self.__dict__.items()
            if not k.startswith(&#39;_&#39;)
        }


class InnoStruct(JsonStruct):
    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, codec: str = &#39;latin1&#39;):
        if version.unicode:
            self._read_string = functools.partial(
                reader.read_length_prefixed_utf16, bytecount=True)
        else:
            def _read():
                data = reader.read_length_prefixed()
                try:
                    return codecs.decode(data, codec)
                except (LookupError, UnicodeDecodeError):
                    # TODO
                    return codecs.decode(data, &#39;latin1&#39;)
            self._read_string = _read


class CheckSumType(enum.IntEnum):
    Missing = 0 # noqa
    Adler32 = 1 # noqa
    CRC32   = 2 # noqa
    MD5     = 3 # noqa
    SHA1    = 4 # noqa
    SHA256  = 5 # noqa

    def strong(self):
        return self.value &gt;= 3


class Flags(enum.IntFlag):
    Empty                       = 0           # noqa
    DisableStartupPrompt        = enum.auto() # noqa
    Uninstallable               = enum.auto() # noqa
    CreateAppDir                = enum.auto() # noqa
    DisableDirPage              = enum.auto() # noqa
    DisableDirExistsWarning     = enum.auto() # noqa
    DisableProgramGroupPage     = enum.auto() # noqa
    AllowNoIcons                = enum.auto() # noqa
    AlwaysRestart               = enum.auto() # noqa
    BackSolid                   = enum.auto() # noqa
    AlwaysUsePersonalGroup      = enum.auto() # noqa
    WindowVisible               = enum.auto() # noqa
    WindowShowCaption           = enum.auto() # noqa
    WindowResizable             = enum.auto() # noqa
    WindowStartMaximized        = enum.auto() # noqa
    EnableDirDoesntExistWarning = enum.auto() # noqa
    DisableAppendDir            = enum.auto() # noqa
    Password                    = enum.auto() # noqa
    AllowRootDirectory          = enum.auto() # noqa
    DisableFinishedPage         = enum.auto() # noqa
    AdminPrivilegesRequired     = enum.auto() # noqa
    AlwaysCreateUninstallIcon   = enum.auto() # noqa
    OverwriteUninstRegEntries   = enum.auto() # noqa
    ChangesAssociations         = enum.auto() # noqa
    CreateUninstallRegKey       = enum.auto() # noqa
    UsePreviousAppDir           = enum.auto() # noqa
    BackColorHorizontal         = enum.auto() # noqa
    UsePreviousGroup            = enum.auto() # noqa
    UpdateUninstallLogAppName   = enum.auto() # noqa
    UsePreviousSetupType        = enum.auto() # noqa
    DisableReadyMemo            = enum.auto() # noqa
    AlwaysShowComponentsList    = enum.auto() # noqa
    FlatComponentsList          = enum.auto() # noqa
    ShowComponentSizes          = enum.auto() # noqa
    UsePreviousTasks            = enum.auto() # noqa
    DisableReadyPage            = enum.auto() # noqa
    AlwaysShowDirOnReadyPage    = enum.auto() # noqa
    AlwaysShowGroupOnReadyPage  = enum.auto() # noqa
    BzipUsed                    = enum.auto() # noqa
    AllowUNCPath                = enum.auto() # noqa
    UserInfoPage                = enum.auto() # noqa
    UsePreviousUserInfo         = enum.auto() # noqa
    UninstallRestartComputer    = enum.auto() # noqa
    RestartIfNeededByRun        = enum.auto() # noqa
    ShowTasksTreeLines          = enum.auto() # noqa
    ShowLanguageDialog          = enum.auto() # noqa
    DetectLanguageUsingLocale   = enum.auto() # noqa
    AllowCancelDuringInstall    = enum.auto() # noqa
    WizardImageStretch          = enum.auto() # noqa
    AppendDefaultDirName        = enum.auto() # noqa
    AppendDefaultGroupName      = enum.auto() # noqa
    EncryptionUsed              = enum.auto() # noqa
    ChangesEnvironment          = enum.auto() # noqa
    ShowUndisplayableLanguages  = enum.auto() # noqa
    SetupLogging                = enum.auto() # noqa
    SignedUninstaller           = enum.auto() # noqa
    UsePreviousLanguage         = enum.auto() # noqa
    DisableWelcomePage          = enum.auto() # noqa
    CloseApplications           = enum.auto() # noqa
    RestartApplications         = enum.auto() # noqa
    AllowNetworkDrive           = enum.auto() # noqa
    ForceCloseApplications      = enum.auto() # noqa
    AppNameHasConsts            = enum.auto() # noqa
    UsePreviousPrivileges       = enum.auto() # noqa
    WizardResizable             = enum.auto() # noqa
    UninstallLogging            = enum.auto() # noqa


class AutoBool(enum.IntEnum):
    Auto = 0
    No = 1
    Yes = 2

    @classmethod
    def From(cls, b: bool):
        return AutoBool.Yes if b else AutoBool.No


class WizardStyle(enum.IntEnum):
    Classic = 0
    Modern = 1


class StoredAlphaFormat(enum.IntEnum):
    AlphaIgnored = 0
    AlphaDefined = 1
    AlphaPremultiplied = 2


class UninstallLogMode(enum.IntEnum):
    Append = 0
    New = 1
    Overwrite = 2


class SetupStyle(enum.IntEnum):
    Classic = 0
    Modern = 1


class PrivilegesRequired(enum.IntEnum):
    Nothing = 0
    PowerUser = 1
    Admin = 2
    Lowest = 3


class PrivilegesRequiredOverrideAllowed(enum.IntEnum):
    CommandLine = 0
    Dialog = 1


class LanguageDetection(enum.IntEnum):
    UI = 0
    Locale = 1
    Nothing = 2


class CompressionMethod(enum.IntEnum):
    Store = 0
    Flate = 1
    BZip2 = 2
    LZMA1 = 3
    LZMA2 = 4

    def legacy_check(self, max: int, ver: str):
        if self.value &gt; max:
            raise ValueError(F&#39;Compression method {self.value} cannot be represented before version {ver}.&#39;)
        return self

    def legacy_conversion_pre_4_2_5(self):
        return self.legacy_check(2, &#39;4.2.5&#39;).__class__(self.value + 1)

    def legacy_conversion_pre_4_2_6(self):
        if self == CompressionMethod.Store:
            return self
        return self.legacy_check(2, &#39;4.2.6&#39;).__class__(self.value + 1)

    def legacy_conversion_pre_5_3_9(self):
        return self.legacy_check(3, &#39;5.3.9&#39;)


class Architecture(enum.IntFlag):
    Unknown = 0b00000 # noqa
    X86     = 0b00001 # noqa
    AMD64   = 0b00010 # noqa
    IA64    = 0b00100 # noqa
    ARM64   = 0b01000 # noqa
    All     = 0b01111 # noqa


class PasswordType(enum.IntEnum):
    CRC32     = 0           # noqa
    Nothing   = 0           # noqa
    MD5       = enum.auto() # noqa
    SHA1      = enum.auto() # noqa
    XChaCha20 = enum.auto() # noqa


class SetupTypeEnum(enum.IntEnum):
    User = 0
    DefaultFull = 1
    DefaultCompact = 2
    DefaultCustom = 3


class SetupFlags(enum.IntFlag):
    Fixed                     = 0b00001 # noqa
    Restart                   = 0b00010 # noqa
    DisableNoUninstallWarning = 0b00100 # noqa
    Exclusive                 = 0b01000 # noqa
    DontInheritCheck          = 0b10000 # noqa


class StreamCompressionMethod(enum.IntEnum):
    Store = 0
    Flate = 1
    LZMA1 = 2


class StreamHeader(InnoStruct):
    def __init__(self, reader: StructReader[memoryview], name: str, version: InnoVersion):
        super().__init__(reader, version)
        self.Name = name
        self.HeaderCrc = reader.u32()
        self.CompressedSize = size = reader.u32()
        if version &gt;= (4, 0, 9):
            self.StoredSize = self.CompressedSize
            if not reader.u8():
                self.Compression = StreamCompressionMethod.Store
            elif version &gt;= (4, 1, 6):
                self.Compression = StreamCompressionMethod.LZMA1
            else:
                self.Compression = StreamCompressionMethod.Flate
        else:
            self.UncompresedSize = reader.u32()
            if size == 0xFFFFFFFF:
                self.StoredSize = self.UncompresedSize
                self.Compression = StreamCompressionMethod.Store
            else:
                self.StoredSize = size
                self.Compression = StreamCompressionMethod.Flate
            # Add the size of a CRC32 checksum for each 4KiB subblock
            block_count, _r = divmod(self.StoredSize, 4096)
            block_count += int(bool(_r))
            self.StoredSize += 4 * block_count


class CrcCompressedBlock(JsonStruct):
    def __init__(self, reader: StructReader[memoryview], size: int):
        self.BlockCrc = reader.u32()
        self.BlockData = reader.read(size)


class TSetupOffsets(Struct):
    def __init__(self, reader: StructReader[memoryview]):
        self.id = reader.read(12)
        self.version = reader.u32()
        self.total_size = reader.u32()
        self.exe_offset = reader.u32()
        self.exe_uncompressed_size = reader.u32()
        self.exe_crc = reader.u32()
        self.setup0_offset = reader.u32()
        self.setup1_offset = reader.u32()
        self.offsets_crc = reader.u32()
        self.base = min(
            self.exe_offset,
            self.setup0_offset,
            self.setup1_offset,
        )
        self.setup0 = self.setup0_offset - self.base
        self.setup1 = self.setup1_offset - self.base


@dataclasses.dataclass
class InnoFile:
    reader: StructReader[ByteStr]
    version: InnoVersion
    meta: SetupDataEntry
    path: str = &#34;&#34;
    dupe: bool = False
    setup: Optional[SetupFile] = None
    compression_method: Optional[CompressionMethod] = None
    password_hash: bytes = B&#39;&#39;
    password_salt: bytes = B&#39;&#39;
    password_type: PasswordType = PasswordType.Nothing

    @property
    def tags(self):
        if s := self.setup:
            return s.Flags
        else:
            return SetupFileFlags.Empty

    @property
    def unicode(self):
        return self.version.unicode

    @property
    def compression(self):
        if self.meta.Flags &amp; SetupDataEntryFlags.ChunkCompressed:
            return self.compression_method
        return CompressionMethod.Store

    @property
    def offset(self):
        return self.meta.Offset

    @property
    def size(self):
        return self.meta.FileSize

    @property
    def date(self):
        return self.meta.FileTime

    @property
    def chunk_offset(self):
        return self.meta.ChunkOffset

    @property
    def chunk_length(self):
        return self.meta.ChunkSize

    @property
    def checksum(self):
        return self.meta.Checksum

    @property
    def checksum_type(self):
        return self.meta.ChecksumType

    @property
    def encrypted(self):
        return bool(self.meta.Flags &amp; SetupDataEntryFlags.ChunkEncrypted)

    @property
    def filtered(self):
        return bool(self.meta.Flags &amp; SetupDataEntryFlags.CallInstructionOptimized)

    def check(self, data: ByteStr):
        t = self.checksum_type
        if t == CheckSumType.Missing:
            return None
        if t == CheckSumType.Adler32:
            return zlib.adler32(data) &amp; 0xFFFFFFFF
        if t == CheckSumType.CRC32:
            return zlib.crc32(data) &amp; 0xFFFFFFFF
        if t == CheckSumType.MD5:
            return md5(data).digest()
        if t == CheckSumType.SHA1:
            return sha1(data).digest()
        if t == CheckSumType.SHA256:
            return sha256(data).digest()
        raise ValueError(F&#39;Unknown checksum type: {t!r}&#39;)


@dataclasses.dataclass
class InnoStream:
    header: StreamHeader
    blocks: list[CrcCompressedBlock] = dataclasses.field(default_factory=list)
    data: Optional[bytearray] = None

    @property
    def compression(self):
        return self.header.Compression

    @property
    def name(self):
        return self.header.Name


class InstallMode(enum.IntEnum):
    Normal     = 0           # noqa
    Silent     = enum.auto() # noqa
    VerySilent = enum.auto() # noqa


class SetupHeader(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)

        def read_string():
            return reader.read_length_prefixed()

        if version &lt; (1, 3, 0):
            # skip uncompressed size
            reader.u32()

        if True:
            self.AppName = read_string()
            self.AppVersionedName = read_string()
        if version &gt;= (1, 3, 0):
            self.AppId = read_string()
        if True:
            self.AppCopyright = read_string()
        if version &gt;= (1, 3, 0):
            self.AppPublisher = read_string()
            self.AppPublisherUrl = read_string()
        if version &gt;= (5, 1, 13):
            self.AppSupportPhone = read_string()
        if version &gt;= (1, 3, 0):
            self.AppSupportUrl = read_string()
            self.AppUpdatesUrl = read_string()
            self.AppVersion = read_string()
        if True:
            self.DefaultDirName = read_string()
            self.DefaultGroupName = read_string()
        if version &lt; (3, 0, 0):
            self.UninstallIconName = reader.read_length_prefixed(encoding=&#39;cp1252&#39;)
        if True:
            self.BaseFilename = read_string()
        if (1, 3, 0) &lt;= version &lt; (5, 2, 5):
            self._license = reader.read_length_prefixed_ascii()
            self.InfoHead = reader.read_length_prefixed_ascii()
            self.InfoTail = reader.read_length_prefixed_ascii()
        if version &gt;= (1, 3, 3):
            self.UninstallFilesDir = read_string()
        if version &gt;= (1, 3, 6):
            self.UninstallName = read_string()
            self.UninstallIcon = read_string()
        if version &gt;= (1, 3, 14):
            self.AppMutex = read_string()
        if version &gt;= (3, 0, 0):
            self.DefaultUsername = read_string()
            self.DefaultOrganisation = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 6, 1):
            self.DefaultSerial = read_string()
        if (4, 0, 0) &lt;= version &lt; (5, 2, 5) or version.isx and version &gt;= (1, 3, 24):
            self.CompiledCode = read_string()
        if version &gt;= (4, 2, 4):
            self.AppReadmeFile = read_string()
            self.AppContact = read_string()
            self.AppComment = read_string()
            self.AppModifyPath = read_string()
        if version &gt;= (5, 3, 8):
            self.CreateUninstallRegistryKey = read_string()
        if version &gt;= (5, 3, 10):
            self.Uninstallable = read_string()
        if version &gt;= (5, 5, 0):
            self.CloseApplicationsFilter = read_string()
        if version &gt;= (5, 5, 6):
            self.SetupMutex = read_string()
        if version &gt;= (5, 6, 1):
            self.ChangesEnvironment = read_string()
            self.ChangesAssociations = read_string()
        if version &gt;= (6, 3, 0):
            self.ArchitecturesAllowed32 = read_string()
            self.ArchitecturesAllowed64 = read_string()
        if version &gt;= (5, 2, 5):
            self._license = reader.read_length_prefixed_ascii()
            self.InfoHead = reader.read_length_prefixed_ascii()
            self.InfoTail = reader.read_length_prefixed_ascii()
        if version &gt;= (5, 2, 1) and version &lt; (5, 3, 10):
            self.UninstallerSignature = read_string()
        if version &gt;= (5, 2, 5):
            self.CompiledCode = read_string()

        if self.CompiledCode and self.CompiledCode[:4] != B&#39;IFPS&#39;:
            raise ValueError(&#39;Invalid signature in compiled code.&#39;)

        if version &gt;= (2, 0, 6) and version.ascii:
            self.Charset = reader.read_integer(0x100)
        else:
            self.Charset = [False] * 0x100

        if version &gt;= (4, 0, 0):
            self.LanguageCount = reader.u32()
        elif version &gt;= (2, 0, 1):
            self.LanguageCount = 1
        else:
            self.LanguageCount = 0

        if version &gt;= (4, 2, 1):
            self.MessageCount = reader.u32()
        else:
            self.MessageCount = 0

        if version &gt;= (4, 1, 0):
            self.PermissionCount = reader.u32()
        else:
            self.PermissionCount = 0

        if version &gt;= (2, 0, 0) or version.isx:
            self.TypeCount = reader.u32()
            self.ComponentCount = reader.u32()
        else:
            self.TypeCount = 0
            self.ComponentCount = 0

        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 17):
            self.TaskCount = reader.u32()
        else:
            self.TaskCount = 0

        self.DirectoryCount = reader.u32()
        self.FileCount = reader.u32()
        self.DataEntryCount = reader.u32()
        self.IconCount = reader.u32()
        self.IniEntryCount = reader.u32()
        self.RegistryCount = reader.u32()
        self.DeleteCount = reader.u32()
        self.UninstallDeleteCount = reader.u32()
        self.RunCount = reader.u32()
        self.UninstallRunCount = reader.u32()

        if version &lt; (1, 3, 0):
            _license_len = reader.u32()
            _infhead_len = reader.u32()
            _inftail_len = reader.u32()

        self.WindowsVersion = WinVerRange(reader, version)

        self.BackColor1 = reader.u32() if (0, 0, 0) &lt;= version &lt; (6, 4, 0, 1) else 0
        self.BackColor2 = reader.u32() if (1, 3, 3) &lt;= version &lt; (6, 4, 0, 1) else 0

        if version &lt; (5, 5, 7):
            self.ImageBackColor = reader.u32()
        if (2, 0, 0) &lt;= version &lt; (5, 0, 4) or version.isx:
            self.SmallImageBackColor = reader.u32()
        if version &gt;= (6, 0, 0):
            self.WizardStyle = WizardStyle(reader.u8())
            self.WizardResizePercentX = reader.u32()
            self.WizardResizePercentY = reader.u32()
        else:
            self.WizardStyle = WizardStyle.Classic
            self.WizardResizePercentX = 0
            self.WizardResizePercentY = 0

        if version &gt;= (5, 5, 7):
            self.StoredAlphaFormat = StoredAlphaFormat(reader.u8())
        else:
            self.StoredAlphaFormat = StoredAlphaFormat.AlphaIgnored

        if version &gt;= (6, 4, 0):
            self.PasswordType = PasswordType.XChaCha20
            self.PasswordHash = reader.read(4)
        elif version &gt;= (5, 3, 9):
            self.PasswordType = PasswordType.SHA1
            self.PasswordHash = reader.read(20)
        elif version &gt;= (4, 2, 0):
            self.PasswordType = PasswordType.MD5
            self.PasswordHash = reader.read(16)
        else:
            self.PasswordType = PasswordType.CRC32
            self.PasswordHash = reader.u32()

        if version &gt;= (6, 4, 0):
            self.PasswordSalt = reader.read(44)
        elif version &gt;= (4, 2, 2):
            self.PasswordSalt = reader.read(8)
        else:
            self.PasswordSalt = None

        if version &gt;= (4, 0, 0):
            self.ExtraDiskSpace = reader.i64()
            self.SlicesPerDisk = reader.u32()
        else:
            self.ExtraDiskSpace = reader.u32()
            self.SlicesPerDisk = 1

        if (2, 0, 0) &lt;= version &lt; (5, 0, 0):
            self.InstallMode = _enum(InstallMode, reader.u8(), InstallMode.Normal)
        else:
            self.InstallMode = InstallMode.Normal
        if version &gt;= (1, 3, 0):
            self.UninstallLogMode = UninstallLogMode(reader.u8())
        else:
            self.UninstallLogMode = UninstallLogMode.New

        if version &gt;= (5, 0, 0):
            self.SetupStyle = SetupStyle.Modern
        elif (2, 0, 0) &lt;= version or version.isx and version &gt;= (1, 3, 13):
            self.SetupStyle = SetupStyle(reader.u8())
        else:
            self.SetupStyle = SetupStyle.Classic

        if version &gt;= (1, 3, 6):
            self.DirExistsWarning = AutoBool(reader.u8())
        else:
            self.DirExistsWarning = AutoBool.Auto
        if version.isx and (2, 0, 10) &lt;= version &lt; (3, 0, 0):
            self.CodeLineOffset = reader.u32()

        self.Flags = Flags.Empty

        if (3, 0, 0) &lt;= version &lt; (3, 0, 3):
            val = AutoBool(reader.u8())
            if val == AutoBool.Auto:
                self.Flags |= Flags.RestartIfNeededByRun
            elif val == AutoBool.Yes:
                self.Flags |= Flags.AlwaysRestart

        if version &gt;= (3, 0, 4) or version.isx and version &gt;= (3, 0, 3):
            self.PrivilegesRequired = PrivilegesRequired(reader.u8())
        if version &gt;= (5, 7, 0):
            self.PrivilegesRequiredOverrideAllowed = PrivilegesRequiredOverrideAllowed(reader.u8())
        if version &gt;= (4, 0, 10):
            self.ShowLanguageDialog = AutoBool(reader.u8())
            self.LanguageDetection = LanguageDetection(reader.u8())

        if version &gt;= (4, 1, 5):
            method = CompressionMethod(reader.u8())
            if version &lt; (4, 2, 5):
                method = method.legacy_conversion_pre_4_2_5()
            elif version &lt; (4, 2, 6):
                method = method.legacy_conversion_pre_4_2_5()
            elif version &lt; (5, 3, 9):
                method = method.legacy_conversion_pre_5_3_9()
            self.CompressionMethod = method

        if version &gt;= (6, 3, 0):
            self.ArchitecturesAllowed = Architecture.Unknown
            self.ArchitecturesInstalled64 = Architecture.Unknown
        elif version &gt;= (5, 1, 0):
            self.ArchitecturesAllowed = Architecture(reader.u8())
            self.ArchitecturesInstalled64 = Architecture(reader.u8())
        else:
            self.ArchitecturesAllowed = Architecture.All
            self.ArchitecturesInstalled64 = Architecture.All

        if (5, 2, 1) &lt;= version &lt; (5, 3, 10):
            self.UninstallerOriginalSize = reader.u32()
            self.UninstallheaderCrc = reader.u32()
        if version &gt;= (5, 3, 3):
            self.DisableDirPage = AutoBool(reader.u8())
            self.DisableProgramGroupPage = AutoBool(reader.u8())
        if version &gt;= (5, 5, 0):
            self.UninstallDisplaySize = reader.u64()
        elif version &gt;= (5, 3, 6):
            self.UninstallDisplaySize = reader.u32()
        else:
            self.UninstallDisplaySize = 0

        flags = []
        flags.append(Flags.DisableStartupPrompt)
        if version &lt; (5, 3, 10):
            flags.append(Flags.Uninstallable)
        flags.append(Flags.CreateAppDir)
        if version &lt; (5, 3, 3):
            flags.append(Flags.DisableDirPage)
        if version &lt; (1, 3, 6):
            flags.append(Flags.DisableDirExistsWarning)
        if version &lt; (5, 3, 3):
            flags.append(Flags.DisableProgramGroupPage)
        flags.append(Flags.AllowNoIcons)
        if version &lt; (3, 0, 0) or version &gt;= (3, 0, 3):
            flags.append(Flags.AlwaysRestart)
        if version &lt; (1, 3, 3):
            flags.append(Flags.BackSolid)
        flags.append(Flags.AlwaysUsePersonalGroup)
        flags.append(Flags.WindowVisible)
        flags.append(Flags.WindowShowCaption)
        flags.append(Flags.WindowResizable)
        flags.append(Flags.WindowStartMaximized)
        flags.append(Flags.EnableDirDoesntExistWarning)
        if version &lt; (4, 1, 2):
            flags.append(Flags.DisableAppendDir)
        flags.append(Flags.Password)
        flags.append(Flags.AllowRootDirectory)
        flags.append(Flags.DisableFinishedPage)

        if version.bits &gt; 16:
            if version &lt; (3, 0, 4):
                flags.append(Flags.AdminPrivilegesRequired)
            if version &lt; (3, 0, 0):
                flags.append(Flags.AlwaysCreateUninstallIcon)
            if version &lt; (1, 3, 6):
                flags.append(Flags.OverwriteUninstRegEntries)
            if version &lt; (5, 6, 1):
                flags.append(Flags.ChangesAssociations)

        if version &lt; (5, 3, 8):
            flags.append(Flags.CreateUninstallRegKey)

        flags.append(Flags.UsePreviousAppDir)
        flags.append(Flags.BackColorHorizontal)
        flags.append(Flags.UsePreviousGroup)
        flags.append(Flags.UpdateUninstallLogAppName)
        flags.append(Flags.UsePreviousSetupType)
        flags.append(Flags.DisableReadyMemo)
        flags.append(Flags.AlwaysShowComponentsList)
        flags.append(Flags.FlatComponentsList)
        flags.append(Flags.ShowComponentSizes)
        flags.append(Flags.UsePreviousTasks)
        flags.append(Flags.DisableReadyPage)
        flags.append(Flags.AlwaysShowDirOnReadyPage)
        flags.append(Flags.AlwaysShowGroupOnReadyPage)
        if version &lt; (4, 1, 5):
            flags.append(Flags.BzipUsed)
        flags.append(Flags.AllowUNCPath)
        flags.append(Flags.UserInfoPage)
        flags.append(Flags.UsePreviousUserInfo)
        flags.append(Flags.UninstallRestartComputer)
        flags.append(Flags.RestartIfNeededByRun)
        flags.append(Flags.ShowTasksTreeLines)
        if version &lt; (4, 0, 10):
            flags.append(Flags.ShowLanguageDialog)
        if version &gt;= (4, 0, 1) and version &lt; (4, 0, 10):
            flags.append(Flags.DetectLanguageUsingLocale)
        if version &gt;= (4, 0, 9):
            flags.append(Flags.AllowCancelDuringInstall)
        if version &gt;= (4, 1, 3):
            flags.append(Flags.WizardImageStretch)
        if version &gt;= (4, 1, 8):
            flags.append(Flags.AppendDefaultDirName)
            flags.append(Flags.AppendDefaultGroupName)
        if version &gt;= (4, 2, 2):
            flags.append(Flags.EncryptionUsed)
        if version &gt;= (5, 0, 4) and version &lt; (5, 6, 1):
            flags.append(Flags.ChangesEnvironment)
        if version &gt;= (5, 1, 7) and version.ascii:
            flags.append(Flags.ShowUndisplayableLanguages)
        if version &gt;= (5, 1, 13):
            flags.append(Flags.SetupLogging)
        if version &gt;= (5, 2, 1):
            flags.append(Flags.SignedUninstaller)
        if version &gt;= (5, 3, 8):
            flags.append(Flags.UsePreviousLanguage)
        if version &gt;= (5, 3, 9):
            flags.append(Flags.DisableWelcomePage)
        if version &gt;= (5, 5, 0):
            flags.append(Flags.CloseApplications)
            flags.append(Flags.RestartApplications)
            flags.append(Flags.AllowNetworkDrive)
        if version &gt;= (5, 5, 7):
            flags.append(Flags.ForceCloseApplications)
        if version &gt;= (6, 0, 0):
            flags.append(Flags.AppNameHasConsts)
            flags.append(Flags.UsePreviousPrivileges)
            flags.append(Flags.WizardResizable)
        if version &gt;= (6, 3, 0):
            flags.append(Flags.UninstallLogging)

        flagsize, _r = divmod(len(flags), 8)
        flagsize += int(bool(_r))
        bytecheck = bytes(reader.peek(flagsize + 1 + 4 + 1))

        if bytecheck[0] == 0:
            if bytecheck[~0] != 0 or bytecheck[~3:~0] == B&#39;\0\0\0&#39;:
                reader.u8()

        for flag in flags:
            if reader.read_bit():
                self.Flags |= flag

        if version &lt; (3, 0, 4):
            self.PrivilegesRequired = PrivilegesRequired.Admin if (
                self.Flags &amp; Flags.AdminPrivilegesRequired
            ) else PrivilegesRequired.Nothing

        if version &lt; (4, 0, 10):
            self.ShowLanguageDialog = AutoBool.From(
                self.Flags &amp; Flags.ShowLanguageDialog)
            self.LanguageDetection = LanguageDetection.Locale if (
                self.Flags &amp; Flags.DetectLanguageUsingLocale
            ) else LanguageDetection.UI

        if version &lt; (4, 1, 5):
            self.CompressionMethod = CompressionMethod.BZip2 if (
                self.Flags &amp; Flags.BzipUsed
            ) else CompressionMethod.Flate

        if version &lt; (5, 3, 3):
            self.DisableDirPage = AutoBool.From(self.Flags &amp; Flags.DisableDirPage)
            self.DisableProgramGroupPage = AutoBool.From(self.Flags &amp; Flags.DisableProgramGroupPage)

        if version &lt; (1, 3, 0):
            def _read_ascii(n: int):
                return codecs.decode(reader.read(_license_len), &#39;cp1252&#39;)
            self._license = _read_ascii(_license_len)
            self.InfoHead = _read_ascii(_infhead_len)
            self.InfoTail = _read_ascii(_inftail_len)

        reader.byte_align()

        if flagsize == 3:
            reader.u8()

    def get_license(self):
        return self._license

    def recode_strings(self, codec: str):
        for coded_string_attribute in [
            &#39;AppComment&#39;,
            &#39;AppContact&#39;,
            &#39;AppCopyright&#39;,
            &#39;AppId&#39;,
            &#39;AppModifyPath&#39;,
            &#39;AppMutex&#39;,
            &#39;AppName&#39;,
            &#39;AppPublisher&#39;,
            &#39;AppPublisherUrl&#39;,
            &#39;AppReadmeFile&#39;,
            &#39;AppSupportPhone&#39;,
            &#39;AppSupportUrl&#39;,
            &#39;AppUpdatesUrl&#39;,
            &#39;AppVersion&#39;,
            &#39;AppVersionedName&#39;,
            &#39;BaseFilename&#39;,
            &#39;ChangesAssociations&#39;,
            &#39;ChangesEnvironment&#39;,
            &#39;CloseApplicationsFilter&#39;,
            &#39;CreateUninstallRegistryKey&#39;,
            &#39;DefaultDirName&#39;,
            &#39;DefaultGroupName&#39;,
            &#39;DefaultOrganisation&#39;,
            &#39;DefaultSerial&#39;,
            &#39;DefaultUsername&#39;,
            &#39;SetupMutex&#39;,
            &#39;Uninstallable&#39;,
            &#39;UninstallFilesDir&#39;,
            &#39;UninstallIcon&#39;,
            &#39;UninstallName&#39;,
        ]:
            try:
                value: bytes = getattr(self, coded_string_attribute)
            except AttributeError:
                continue
            if not isinstance(value, (bytes, bytearray, memoryview)):
                raise RuntimeError(F&#39;Attempting to decode {coded_string_attribute} which was already decoded.&#39;)
            setattr(self, coded_string_attribute, codecs.decode(value, codec))


class Version(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Build = reader.u16() if version &gt;= (1, 3, 19) else 0
        self.Minor = reader.u8()
        self.Major = reader.u8()


class WindowsVersion(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.OS = Version(reader, version)
        self.NT = Version(reader, version)
        (
            self.ServicePackMinor,
            self.ServicePackMajor,
        ) = reader.read_struct(&#39;BB&#39;) if version &gt;= (1, 3, 19) else (0, 0)


class WinVerRange(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Min = WindowsVersion(reader, version)
        self.Max = WindowsVersion(reader, version)


class LanguageId(JsonStruct):
    def __init__(self, reader: StructReader[memoryview]):
        self.Value = reader.i32()
        self.Name = LCID.get(self.Value, None)


class SetupLanguage(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, _: TSetup):
        super().__init__(reader, version)
        read_string = self._read_string

        self.Name = read_string()
        LanguageName = reader.read_length_prefixed()

        self.DialogFont = read_string()
        self.TitleFont = read_string()
        self.WelcomeFont = read_string()
        self.CopyrightFont = read_string()
        self.Data = reader.read_length_prefixed()

        if version &gt;= (4, 0, 1):
            self.LicenseText = reader.read_length_prefixed_ascii()
            self.InfoBefore = reader.read_length_prefixed_ascii()
            self.InfoAfter = reader.read_length_prefixed_ascii()

        self.LanguageId = LanguageId(reader)

        if version &lt; (4, 2, 2):
            self.Codepage = DEFAULT_CODEPAGE.get(self.LanguageId.Value, &#39;cp1252&#39;)
        elif version.ascii:
            cp = reader.u32() or 1252
            self.Codepage = F&#39;cp{cp}&#39;
        else:
            if version &lt; (5, 3, 0):
                reader.u32()
            self.Codepage = &#39;utf-16le&#39;

        if version &gt;= (4, 2, 2):
            self.LanguageName = codecs.decode(LanguageName, &#39;utf-16le&#39;)
        else:
            self.LanguageName = codecs.decode(LanguageName, self.Codepage)

        self.DialogFontSize = reader.u32()

        if version &lt; (4, 1, 0):
            self.DialogFontStandardHeight = reader.u32()

        self.TitleFontSize = reader.u32()
        self.WelcomeFontSize = reader.u32()
        self.CopyrightFontSize = reader.u32()

        if version &gt;= (5, 2, 3):
            self.RightToLeft = reader.u8()


class SetupMessage(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        self.EncodedName = self._read_string()
        value = reader.read_length_prefixed()
        language = reader.i32()
        try:
            codec = parent.Languages[language].Codepage
        except IndexError:
            pass
        try:
            self.Value = codecs.decode(value, codec)
        except LookupError:
            # TODO: This is a fallback
            self.Value = codecs.decode(value, &#39;latin1&#39;)


class SetupType(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        self.Name = read_string()
        self.Description = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        self.WindowsVersion = WinVerRange(reader, version)
        self.CustsomTypeCode = reader.u8()
        if version &gt;= (4, 0, 3):
            self.SetupType = SetupTypeEnum(reader.u8())
        else:
            self.SetupType = SetupTypeEnum.User
        if version &gt;= (4, 0, 0):
            self.Size = reader.u64()
        else:
            self.Size = reader.u32()


class SetupComponent(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        self.Name = read_string()
        self.Description = read_string()
        self.Types = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        if version &gt;= (4, 0, 0):
            self.ExtraDiskSpace = reader.u64()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 3):
            self.Level = reader.u32()
        else:
            self.Level = 0
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 4):
            self.Used = bool(reader.u8())
        else:
            self.Used = True
        if True:
            self.WindowsVersion = WinVerRange(reader, version)
            self.Flags = SetupFlags(reader.u8())
        if version &gt;= (4, 0, 0):
            self.Size = reader.u64()
        elif version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Size = reader.u32()


class SetupTaskFlags(enum.IntFlag):
    Empty            = 0           # noqa
    Exclusive        = enum.auto() # noqa
    Unchecked        = enum.auto() # noqa
    Restart          = enum.auto() # noqa
    CheckedOne       = enum.auto() # noqa
    DontInheritCheck = enum.auto() # noqa


class SetupTask(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        self.Name = read_string()
        self.Description = read_string()
        self.GroupDescription = read_string()
        self.Components = read_string()

        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 3):
            self.Level = reader.u32()
        else:
            self.Level = 0
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 4):
            self.Used = bool(reader.u8())
        else:
            self.Used = True
        if True:
            self.WindowsVersion = WinVerRange(reader, version)

        self.Flags = SetupTaskFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if True:
            flagbit(SetupTaskFlags.Exclusive)
            flagbit(SetupTaskFlags.Unchecked)
        if version &gt;= (2, 0, 5):
            flagbit(SetupTaskFlags.Restart)
        if version &gt;= (2, 0, 6):
            flagbit(SetupTaskFlags.CheckedOne)
        if version &gt;= (4, 2, 3):
            flagbit(SetupTaskFlags.DontInheritCheck)

        reader.byte_align()


class SetupCondition(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 8):
            self.Components = read_string()
        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 17):
            self.Tasks = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        else:
            self.Check = None
        if version &gt;= (4, 1, 0):
            self.AfterInstall = read_string()
            self.BeforeInstall = read_string()


class SetupDirectoryFlags(enum.IntFlag):
    Empty                = 0           # noqa
    NeverUninstall       = enum.auto() # noqa
    DeleteAfterInstall   = enum.auto() # noqa
    AlwaysUninstall      = enum.auto() # noqa
    SetNtfsCompression   = enum.auto() # noqa
    UnsetNtfsCompression = enum.auto() # noqa


class SetupDirectory(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        if version &lt; (1, 3, 0):
            self.UncompressedSize = reader.u32()
        if True:
            self.Name = read_string()
            self.Condition = SetupCondition(reader, version, parent)

        if (4, 0, 11) &lt;= version &lt; (4, 1, 0):
            self.Permissions = read_string()
        if version &gt;= (2, 0, 11):
            self.Attributes = reader.u32()

        self.WindowsVersion = WinVerRange(reader, version)

        if version &gt;= (4, 1, 0):
            self.Permissions = reader.u16()

        self.Flags = SetupDirectoryFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0
        flagbit(SetupDirectoryFlags.NeverUninstall)
        flagbit(SetupDirectoryFlags.DeleteAfterInstall)
        flagbit(SetupDirectoryFlags.AlwaysUninstall)
        flagbit(SetupDirectoryFlags.SetNtfsCompression)
        flagbit(SetupDirectoryFlags.UnsetNtfsCompression)
        reader.byte_align()


class SetupPermission(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        self.Permission = reader.read_length_prefixed()


class SetupFileFlags(enum.IntFlag):
    Empty                              = 0           # noqa
    ConfirmOverwrite                   = enum.auto() # noqa
    NeverUninstall                     = enum.auto() # noqa
    RestartReplace                     = enum.auto() # noqa
    DeleteAfterInstall                 = enum.auto() # noqa
    RegisterServer                     = enum.auto() # noqa
    RegisterTypeLib                    = enum.auto() # noqa
    SharedFile                         = enum.auto() # noqa
    IsReadmeFile                       = enum.auto() # noqa
    CompareTimeStamp                   = enum.auto() # noqa
    FontIsNotTrueType                  = enum.auto() # noqa
    SkipIfSourceDoesntExist            = enum.auto() # noqa
    OverwriteReadOnly                  = enum.auto() # noqa
    OverwriteSameVersion               = enum.auto() # noqa
    CustomDestName                     = enum.auto() # noqa
    OnlyIfDestFileExists               = enum.auto() # noqa
    NoRegError                         = enum.auto() # noqa
    UninsRestartDelete                 = enum.auto() # noqa
    OnlyIfDoesntExist                  = enum.auto() # noqa
    IgnoreVersion                      = enum.auto() # noqa
    PromptIfOlder                      = enum.auto() # noqa
    DontCopy                           = enum.auto() # noqa
    UninsRemoveReadOnly                = enum.auto() # noqa
    RecurseSubDirsExternal             = enum.auto() # noqa
    ReplaceSameVersionIfContentsDiffer = enum.auto() # noqa
    DontVerifyChecksum                 = enum.auto() # noqa
    UninsNoSharedFilePrompt            = enum.auto() # noqa
    CreateAllSubDirs                   = enum.auto() # noqa
    Bits32                             = enum.auto() # noqa
    Bits64                             = enum.auto() # noqa
    ExternalSizePreset                 = enum.auto() # noqa
    SetNtfsCompression                 = enum.auto() # noqa
    UnsetNtfsCompression               = enum.auto() # noqa
    GacInstall                         = enum.auto() # noqa


class SetupFileType(enum.IntEnum):
    UserFile = 0
    UninstExe = 1
    RegSvrExe = 2


class SetupFileCopyMode(enum.IntEnum):
    Normal                  = 0           # noqa
    IfDoesntExist           = enum.auto() # noqa
    AlwaysOverwrite         = enum.auto() # noqa
    AlwaysSkipIfSameOrOlder = enum.auto() # noqa


class SetupFile(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        if version &lt; (1, 3, 0):
            self.UncompressedSize = reader.u32()
        if True:
            self.Source = read_string()
            self.Destination = read_string()
            self.InstallFontName = read_string()
        if version &gt;= (5, 2, 5):
            self.StrongAssemblyName = read_string()

        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)

        self.Location = reader.u32()
        self.Attributes = reader.u32()
        self.ExternalSize = reader.u64() if version &gt;= (4, 0, 0) else reader.u32()

        self.Flags = SetupFileFlags.Empty

        if version &lt; (3, 0, 5):
            copy = _enum(SetupFileCopyMode, reader.u8(), SetupFileCopyMode.Normal)
            if copy == SetupFileCopyMode.AlwaysSkipIfSameOrOlder:
                pass
            elif copy == SetupFileCopyMode.Normal:
                self.Flags |= SetupFileFlags.PromptIfOlder
            elif copy == SetupFileCopyMode.IfDoesntExist:
                self.Flags |= SetupFileFlags.OnlyIfDoesntExist | SetupFileFlags.PromptIfOlder
            elif copy == SetupFileCopyMode.AlwaysOverwrite:
                self.Flags |= SetupFileFlags.IgnoreVersion | SetupFileFlags.PromptIfOlder

        if version &gt;= (4, 1, 0):
            self.Permissions = reader.u16()

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        flagstart = reader.tell()

        if True:
            flagbit(SetupFileFlags.ConfirmOverwrite)
            flagbit(SetupFileFlags.NeverUninstall)
            flagbit(SetupFileFlags.RestartReplace)
            flagbit(SetupFileFlags.DeleteAfterInstall)
        if version.bits &gt; 16:
            flagbit(SetupFileFlags.RegisterServer)
            flagbit(SetupFileFlags.RegisterTypeLib)
            flagbit(SetupFileFlags.SharedFile)
        if version &lt; (2, 0, 0) and not version.isx:
            flagbit(SetupFileFlags.IsReadmeFile)
        if True:
            flagbit(SetupFileFlags.CompareTimeStamp)
            flagbit(SetupFileFlags.FontIsNotTrueType)
        if version &gt;= (1, 2, 5):
            flagbit(SetupFileFlags.SkipIfSourceDoesntExist)
        if version &gt;= (1, 2, 6):
            flagbit(SetupFileFlags.OverwriteReadOnly)
        if version &gt;= (1, 3, 21):
            flagbit(SetupFileFlags.OverwriteSameVersion)
            flagbit(SetupFileFlags.CustomDestName)
        if version &gt;= (1, 3, 25):
            flagbit(SetupFileFlags.OnlyIfDestFileExists)
        if version &gt;= (2, 0, 5):
            flagbit(SetupFileFlags.NoRegError)
        if version &gt;= (3, 0, 1):
            flagbit(SetupFileFlags.UninsRestartDelete)
        if version &gt;= (3, 0, 5):
            flagbit(SetupFileFlags.OnlyIfDoesntExist)
            flagbit(SetupFileFlags.IgnoreVersion)
            flagbit(SetupFileFlags.PromptIfOlder)
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 6, 1):
            flagbit(SetupFileFlags.DontCopy)
        if version &gt;= (4, 0, 5):
            flagbit(SetupFileFlags.UninsRemoveReadOnly)
        if version &gt;= (4, 1, 8):
            flagbit(SetupFileFlags.RecurseSubDirsExternal)
        if version &gt;= (4, 2, 1):
            flagbit(SetupFileFlags.ReplaceSameVersionIfContentsDiffer)
        if version &gt;= (4, 2, 5):
            flagbit(SetupFileFlags.DontVerifyChecksum)
        if version &gt;= (5, 0, 3):
            flagbit(SetupFileFlags.UninsNoSharedFilePrompt)
        if version &gt;= (5, 1, 0):
            flagbit(SetupFileFlags.CreateAllSubDirs)
        if version &gt;= (5, 1, 2):
            flagbit(SetupFileFlags.Bits32)
            flagbit(SetupFileFlags.Bits64)
        if version &gt;= (5, 2, 0):
            flagbit(SetupFileFlags.ExternalSizePreset)
            flagbit(SetupFileFlags.SetNtfsCompression)
            flagbit(SetupFileFlags.UnsetNtfsCompression)
        if version &gt;= (5, 2, 5):
            flagbit(SetupFileFlags.GacInstall)

        reader.byte_align()

        if reader.tell() - flagstart == 3:
            reader.u8()

        self.Type = SetupFileType(reader.u8())


class SetupIconCloseSetting(enum.IntEnum):
    NoSetting       = 0           # noqa
    CloseOnExit     = enum.auto() # noqa
    DontCloseOnExit = enum.auto() # noqa


class SetupIconFlags(enum.IntFlag):
    Empty                              = 0           # noqa
    NeverUninstall                     = enum.auto() # noqa
    RunMinimized                       = enum.auto() # noqa
    CreateOnlyIfFileExists             = enum.auto() # noqa
    UseAppPaths                        = enum.auto() # noqa
    FolderShortcut                     = enum.auto() # noqa
    ExcludeFromShowInNewInstall        = enum.auto() # noqa
    PreventPinning                     = enum.auto() # noqa
    HasAppUserModelToastActivatorCLSID = enum.auto() # noqa


class SetupIcon(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u32()

        self.Name = self._read_string()
        self.FileName = self._read_string()
        self.Parameters = self._read_string()
        self.WorkingDir = self._read_string()
        self.IconFile = self._read_string()
        self.Comment = self._read_string()

        self.Condition = SetupCondition(reader, version, parent)

        if version &gt;= (5, 3, 5):
            self.AppUserModelId = self._read_string()
        if version &gt;= (6, 1, 0):
            self.AppUserModelToastActivatorCLSID = reader.read_guid()

        self.WindowsVersion = WinVerRange(reader, version)
        self.IconIndex = reader.i32()

        if version &gt;= (1, 3, 24):
            self.ShowCommand = reader.i32()
        else:
            self.ShowCommand = 1

        if version &gt;= (1, 3, 15):
            self.CloseOnExit = _enum(SetupIconCloseSetting, reader.u8(), SetupIconCloseSetting.NoSetting)
        else:
            self.CloseOnExit = SetupIconCloseSetting.NoSetting

        self.HotKey = reader.u16() if version &gt;= (2, 0, 7) else 0

        self.Flags = SetupIconFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0
        if True:
            flagbit(SetupIconFlags.NeverUninstall)
        if version &lt; (1, 3, 26):
            flagbit(SetupIconFlags.RunMinimized)
        if True:
            flagbit(SetupIconFlags.CreateOnlyIfFileExists)
        if version.bits &gt; 16:
            flagbit(SetupIconFlags.UseAppPaths)
        if version &gt;= (5, 0, 3) and version &lt; (6, 3, 0):
            flagbit(SetupIconFlags.FolderShortcut)
        if version &gt;= (5, 4, 2):
            flagbit(SetupIconFlags.ExcludeFromShowInNewInstall)
        if version &gt;= (5, 5, 0):
            flagbit(SetupIconFlags.PreventPinning)
        if version &gt;= (6, 1, 0):
            flagbit(SetupIconFlags.HasAppUserModelToastActivatorCLSID)
        reader.byte_align()


class SetupIniFlags(enum.IntFlag):
    Empty                     = 0           # noqa
    CreateKeyIfDoesntExist    = enum.auto() # noqa
    UninsDeleteEntry          = enum.auto() # noqa
    UninsDeleteEntireSection  = enum.auto() # noqa
    UninsDeleteSectionIfEmpty = enum.auto() # noqa
    HasValue                  = enum.auto() # noqa


class SetupIniEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u8()

        if not (IniFile := self._read_string()):
            IniFile = &#39;{windows}/WIN.INI&#39;
        self.IniFile = IniFile

        self.Section = self._read_string()
        self.Key = self._read_string()
        self.Codepage = self._read_string()
        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.Flags = SetupIniFlags(reader.u8())


class SetupRegistryType(enum.IntEnum):
    Unset        = 0           # noqa
    String       = enum.auto() # noqa
    ExpandString = enum.auto() # noqa
    DWord        = enum.auto() # noqa
    Binary       = enum.auto() # noqa
    MultiString  = enum.auto() # noqa
    QWord        = enum.auto() # noqa


class SetupRegistryFlags(enum.IntFlag):
    Empty                       = 0           # noqa
    CreateValueIfDoesntExist    = enum.auto() # noqa
    UninsDeleteValue            = enum.auto() # noqa
    UninsClearValue             = enum.auto() # noqa
    UninsDeleteEntireKey        = enum.auto() # noqa
    UninsDeleteEntireKeyIfEmpty = enum.auto() # noqa
    PreserveStringType          = enum.auto() # noqa
    DeleteKey                   = enum.auto() # noqa
    DeleteValue                 = enum.auto() # noqa
    NoError                     = enum.auto() # noqa
    DontCreateKey               = enum.auto() # noqa
    Bits32                      = enum.auto() # noqa
    Bits64                      = enum.auto() # noqa


class SetupRegistryEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u32()

        if True:
            self.Key = self._read_string()
        if version.bits &gt; 16:
            self.Name = self._read_string()
        if True:
            self.Value = reader.read_length_prefixed()
            self.Condition = SetupCondition(reader, version, parent)
        if (4, 0, 11) &lt;= version &lt; (4, 1, 0):
            self.Permissions = reader.read_length_prefixed()

        self.WindowsVersion = WinVerRange(reader, version)
        self.Hive = reader.u32() &amp; 0x7FFFFFFF if version.bits &gt; 16 else None
        self.Permissions = reader.u16() if version &gt;= (4, 1, 0) else None
        self.Type = SetupRegistryType(reader.u8())

        self.Flags = SetupRegistryFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if version.bits &gt; 16:
            flagbit(SetupRegistryFlags.CreateValueIfDoesntExist)
            flagbit(SetupRegistryFlags.UninsDeleteValue)
        if True:
            flagbit(SetupRegistryFlags.UninsClearValue)
            flagbit(SetupRegistryFlags.UninsDeleteEntireKey)
            flagbit(SetupRegistryFlags.UninsDeleteEntireKeyIfEmpty)
        if version &gt;= (1, 2, 6):
            flagbit(SetupRegistryFlags.PreserveStringType)
        if version &gt;= (1, 3, 9):
            flagbit(SetupRegistryFlags.DeleteKey)
            flagbit(SetupRegistryFlags.DeleteValue)
        if version &gt;= (1, 3, 12):
            flagbit(SetupRegistryFlags.NoError)
        if version &gt;= (1, 3, 16):
            flagbit(SetupRegistryFlags.DontCreateKey)
        if version &gt;= (5, 1, 0):
            flagbit(SetupRegistryFlags.Bits32)
            flagbit(SetupRegistryFlags.Bits64)

        reader.byte_align()


class SetupDeleteType(enum.IntEnum):
    Files           = 0           # noqa
    FilesAndSubdirs = enum.auto() # noqa
    DirIfEmpty      = enum.auto() # noqa


class SetupDeleteEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        if version &lt; (1, 3, 0):
            reader.u32()
        self.Name = self._read_string()
        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.Type = SetupDeleteType(reader.u8())


class SetupRunWait(enum.IntEnum):
    UntilTerminated = 0 # noqa
    NoWait          = 1 # noqa
    UntilIdle       = 2 # noqa


class SetupRunFlags(enum.IntFlag):
    Empty             = 0           # noqa
    ShellExec         = enum.auto() # noqa
    SkipIfDoesntExist = enum.auto() # noqa
    PostInstall       = enum.auto() # noqa
    Unchecked         = enum.auto() # noqa
    SkipIfSilent      = enum.auto() # noqa
    SkipIfNotSilent   = enum.auto() # noqa
    HideWizard        = enum.auto() # noqa
    Bits32            = enum.auto() # noqa
    Bits64            = enum.auto() # noqa
    RunAsOriginalUser = enum.auto() # noqa
    DontLogParameters = enum.auto() # noqa
    LogOutput         = enum.auto() # noqa


class SetupRunEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        if version &lt; (1, 3, 0):
            reader.u8()
        self.Name = self._read_string()
        self.Parameters = self._read_string()
        self.WorkingDir = self._read_string()

        if version &gt;= (1, 3, 9):
            self.RunOnceId = self._read_string()
        if version &gt;= (2, 0, 2):
            self.StatusMessage = self._read_string()
        if version &gt;= (5, 1, 13):
            self.Verb = self._read_string()
        if version &gt;= (2, 0, 0) or version.isx:
            self.Description = self._read_string()

        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.ShowCommand = reader.u32() if version &gt;= (1, 3, 24) else 0
        self.Wait = SetupRunWait(reader.u8())

        self.Flags = SetupRunFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if version &gt;= (1, 2, 3):
            flagbit(SetupRunFlags.ShellExec)
        if version &gt;= (1, 3, 9) or version.isx and version &gt;= (1, 3, 8):
            flagbit(SetupRunFlags.SkipIfDoesntExist)
        if version &gt;= (2, 0, 0):
            flagbit(SetupRunFlags.PostInstall)
            flagbit(SetupRunFlags.Unchecked)
            flagbit(SetupRunFlags.SkipIfSilent)
            flagbit(SetupRunFlags.SkipIfNotSilent)
        if version &gt;= (2, 0, 8):
            flagbit(SetupRunFlags.HideWizard)
        if version &gt;= (5, 1, 10):
            flagbit(SetupRunFlags.Bits32)
            flagbit(SetupRunFlags.Bits64)
        if version &gt;= (5, 2, 0):
            flagbit(SetupRunFlags.RunAsOriginalUser)
        if version &gt;= (6, 1, 0):
            flagbit(SetupRunFlags.DontLogParameters)
        if version &gt;= (6, 3, 0):
            flagbit(SetupRunFlags.LogOutput)

        reader.byte_align()


class TSetup(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Header = h = SetupHeader(reader, version)

        def _array(count: int, parser: Type[_T]) -&gt; List[_T]:
            return [parser(reader, version, self) for _ in range(count)]

        self.Languages = _array(h.LanguageCount, SetupLanguage)
        _default_codec = &#39;cp1252&#39;

        if version.unicode:
            self.Codec = &#39;utf-16le&#39;
        elif not self.Languages:
            self.Codec = _default_codec
        else:
            self.Codec = self.Languages[0].Codepage
            if any(language.Codepage == _default_codec for language in self.Languages):
                self.Codec = _default_codec

        if version.ascii:
            h.recode_strings(self.Codec)
        else:
            h.recode_strings(&#39;latin1&#39;)

        if version &lt; (4, 0, 0):
            self._load_wizard_and_decompressor(reader, version)

        self.Messages               = _array(h.MessageCount,         SetupMessage)       # noqa
        self.Permissions            = _array(h.PermissionCount,      SetupPermission)    # noqa
        self.Types                  = _array(h.TypeCount,            SetupType)          # noqa
        self.Components             = _array(h.ComponentCount,       SetupComponent)     # noqa
        self.Tasks                  = _array(h.TaskCount,            SetupTask)          # noqa
        self.Directories            = _array(h.DirectoryCount,       SetupDirectory)     # noqa
        self.Files                  = _array(h.FileCount,            SetupFile)          # noqa

        self.DecompressDLL = None
        self.DecryptionDLL = None

        self.Icons                  = _array(h.IconCount,            SetupIcon)          # noqa
        self.IniEntries             = _array(h.IniEntryCount,        SetupIniEntry)      # noqa
        self.RegistryEntries        = _array(h.RegistryCount,        SetupRegistryEntry) # noqa
        self.DeleteEntries          = _array(h.DeleteCount,          SetupDeleteEntry)   # noqa
        self.UninstallDeleteEntries = _array(h.UninstallDeleteCount, SetupDeleteEntry)   # noqa
        self.RunEntries             = _array(h.RunCount,             SetupRunEntry)      # noqa
        self.UninstallRunEntries    = _array(h.UninstallRunCount,    SetupRunEntry)      # noqa

        if version &gt;= (4, 0, 0):
            self._load_wizard_and_decompressor(reader, version)

    def _load_wizard_and_decompressor(self, reader: StructReader[memoryview], version: InnoVersion):
        if True:
            self.WizardImagesLarge = self._load_wizard_images(reader, version)
        if version &gt;= (2, 0, 0) or version.isx:
            self.WizardImagesSmall = self._load_wizard_images(reader, version)
        method = self.Header.CompressionMethod
        crypto = self.Header.Flags &amp; Flags.EncryptionUsed and version &lt; (6, 4, 0)
        hasDLL = (
            method == CompressionMethod.BZip2
            or method == CompressionMethod.LZMA1 and version == (4, 1, 5)
            or method == CompressionMethod.Flate and version &gt;= (4, 2, 6))
        self.DecompressDLL = reader.read_length_prefixed() if hasDLL else None
        self.DecryptionDLL = reader.read_length_prefixed() if crypto else None

    def _load_wizard_images(self, reader: StructReader[memoryview], version: InnoVersion):
        count = reader.u32() if version &gt;= (5, 6, 0) else 1
        img = [reader.read_length_prefixed() for _ in range(count)]
        if version &lt; (5, 6, 0) and img and not img[0]:
            img.clear()
        return img


class SetupDataEntryFlags(enum.IntFlag):
    Empty                    = 0           # noqa    
    VersionInfoValid         = enum.auto() # noqa
    VersionInfoNotValid      = enum.auto() # noqa
    BZipped                  = enum.auto() # noqa
    TimeStampInUTC           = enum.auto() # noqa
    IsUninstallerExe         = enum.auto() # noqa
    CallInstructionOptimized = enum.auto() # noqa
    Touch                    = enum.auto() # noqa
    ChunkEncrypted           = enum.auto() # noqa
    ChunkCompressed          = enum.auto() # noqa
    SolidBreak               = enum.auto() # noqa
    Sign                     = enum.auto() # noqa
    SignOnce                 = enum.auto() # noqa


class SetupSignMode(enum.IntEnum):
    NoSetting  = 0  # noqa
    Yes        = 1  # noqa
    Once       = 2  # noqa
    Check      = 3  # noqa


class SetupDataEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.FirstSlice = reader.u32()
        self.LastSlice = reader.u32()
        self.ChunkOffset = reader.u32()
        if version &gt;= (4, 0, 1):
            self.Offset = reader.u64()
        self.FileSize = reader.u64()
        self.ChunkSize = reader.u64()

        if version &gt;= (6, 4, 0):
            self.ChecksumType = CheckSumType.SHA256
            self.Checksum = bytes(reader.read(32))
        elif version &gt;= (5, 3, 9):
            self.ChecksumType = CheckSumType.SHA1
            self.Checksum = bytes(reader.read(20))
        elif version &gt;= (4, 2, 0):
            self.ChecksumType = CheckSumType.MD5
            self.Checksum = bytes(reader.read(16))
        elif version &gt;= (4, 0, 1):
            self.ChecksumType = CheckSumType.CRC32
            self.Checksum = reader.u32()
        else:
            self.ChecksumType = CheckSumType.Adler32
            self.Checksum = reader.u32()

        ft = reader.u64()
        ts = datetime.fromtimestamp(
            (ft - _FILE_TIME_1970_01_01) / 10000000, timezone.utc)
        self.FileTime = ts

        self.FileVersionMs = reader.u32()
        self.FileVersionLs = reader.u32()

        self.Flags = 0

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        flagbit(SetupDataEntryFlags.VersionInfoNotValid)
        flagbit(SetupDataEntryFlags.VersionInfoValid)

        if version &lt; (4, 0, 1):
            flagbit(SetupDataEntryFlags.BZipped)
        if version &gt;= (4, 0, 10):
            flagbit(SetupDataEntryFlags.TimeStampInUTC)
        if version &gt;= (4, 1, 0):
            flagbit(SetupDataEntryFlags.IsUninstallerExe)
        if version &gt;= (4, 1, 8):
            flagbit(SetupDataEntryFlags.CallInstructionOptimized)
        if version &gt;= (4, 2, 0):
            flagbit(SetupDataEntryFlags.Touch)
        if version &gt;= (4, 2, 2):
            flagbit(SetupDataEntryFlags.ChunkEncrypted)
        if version &gt;= (4, 2, 5):
            flagbit(SetupDataEntryFlags.ChunkCompressed)
        if version &gt;= (5, 1, 13):
            flagbit(SetupDataEntryFlags.SolidBreak)
        if version &gt;= (5, 5, 7) and version &lt; (6, 3, 0):
            flagbit(SetupDataEntryFlags.Sign)
            flagbit(SetupDataEntryFlags.SignOnce)

        reader.byte_align()

        if version &gt;= (6, 3, 0):
            self.SignMode = SetupSignMode(reader.u8())
        elif self.Flags &amp; SetupDataEntryFlags.SignOnce:
            self.SignMode = SetupSignMode.Once
        elif self.Flags &amp; SetupDataEntryFlags.Sign:
            self.SignMode = SetupSignMode.Yes
        else:
            self.SignMode = SetupSignMode.NoSetting


class TData(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.DataEntries: list[SetupDataEntry] = []
        while not reader.eof:
            self.DataEntries.append(SetupDataEntry(reader, version))


class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: List[InnoStream]
    files: List[InnoFile]
    encrypted_file: Optional[InnoFile]
    warnings: int
    failures: List[str]
    stream0: TSetup
    stream1: TData

    def ok(self):
        return self.warnings == 0 and not self.failures


class xtinno(ArchiveUnit):
    &#34;&#34;&#34;
    Extract files from InnoSetup archives.
    &#34;&#34;&#34;
    _STREAM_NAMES = &#39;meta/TSetup&#39;, &#39;meta/TData&#39;, &#39;embedded/uninstaller.exe&#39;
    _ISCRIPT_NAME = &#39;embedded/script&#39;
    _LICENSE_NAME = &#39;embedded/license.rtf&#39;
    _OFFSETS_PATH = &#39;RCDATA/11111/0&#39;
    _CHUNK_PREFIX = b&#39;zlb\x1a&#39;
    _MAX_ATTEMPTS = 200_000

    def unpack(self, data: bytearray):
        try:
            file_metadata = one(data | perc(self._OFFSETS_PATH))
        except Exception as E:
            raise ValueError(F&#39;Could not find TSetupOffsets PE resource at {self._OFFSETS_PATH}&#39;) from E

        meta = TSetupOffsets(file_metadata)
        view = memoryview(data)
        base = meta.base
        inno = StructReader(view[base:base + meta.total_size])

        self._decompressed = {}
        password = self.args.pwd or None

        blobsize = meta.setup0 - meta.setup1
        inno.seek(meta.setup1)
        blobs = StructReader(inno.read(blobsize))

        header = bytes(inno.read(16))

        try:
            version = InnoVersion.ParseLegacy(header)
        except ValueError:
            header += bytes(inno.read(64 - 16))
            try:
                version = InnoVersion.Parse(header)
            except ValueError:
                name, _, _rest = header.partition(b&#39;\0&#39;)
                method = &#39;broken&#39;
                if any(_rest):
                    header = name.hex()
                else:
                    header = name.decode(&#39;latin1&#39;)
                if self.leniency &lt; 1:
                    raise ValueError(F&#39;unable to parse header identifier &#34;{header}&#34;&#39;)
                version = _DEFAULT_INNO_VERSION
            else:
                header, _, _ = header.partition(B&#39;\0&#39;)
                header = header.decode(&#39;latin1&#39;)
                method = &#39;modern&#39;
        else:
            header, _, _ = header.partition(B&#39;\x1A&#39;)
            header = header.decode(&#39;latin1&#39;)
            method = &#39;legacy&#39;

        self.log_info(F&#39;inno {version!s} via {method} header: {header}&#39;)

        class _notok(object):
            def __init__(self, e: Exception):
                self.failures = [str(e)]

            def ok(self):
                return False

        def _parse(v: InnoVersion):
            try:
                inno.seekset(inno_start)
                if v.legacy:
                    inno.seekrel(-48)
                r = self._try_parse_as(inno, blobs, v, password)
            except Exception as e:
                self.log_info(F&#39;exception while parsing as {v!s}: {exception_to_string(e)}&#39;)
                return _notok(e)
            else:
                results[v] = r
                return r

        inno_start = inno.tell()
        best_parse = None
        best_score = 0
        success = False
        results: dict[InnoVersion, InnoParseResult] = {}

        if not version.is_ambiguous():
            index = _VERSIONS.index(version)
        else:
            try:
                index = max(k for k, v in enumerate(_VERSIONS) if v &lt;= version)
            except Exception:
                index = 0

        upper = index + 1
        lower = index

        while lower &gt; 0 and _IS_AMBIGUOUS[_VERSIONS[lower - 1]]:
            lower -= 1

        versions = [version] + _VERSIONS[lower:index] + _VERSIONS[upper:] + _VERSIONS[:lower]

        for v in versions:
            result = _parse(v)
            if success := result.ok():
                break
            if not result.failures and (best_parse is None or result.warnings &lt; best_score):
                best_score = best_score
                best_parse = result

        if not success:
            if best_parse is not None:
                result = best_parse
                self.log_warn(F&#39;using parse result for {result.version!s} with {result.warnings} warnings&#39;)
            else:
                result = min(results.values(), key=lambda result: len(result.failures))
                self.log_warn(F&#39;using parse result for {result.version!s} with {len(result.failures)} failures&#39;)
                for k, failure in enumerate(result.failures, 1):
                    self.log_info(F&#39;failure {k}: {failure}&#39;)

        version = result.version
        codec = result.stream0.Codec
        stream0 = result.stream0
        stream1 = result.stream1
        files = result.files
        streams = result.streams
        encrypted_file = result.encrypted_file

        if version.unicode:
            codec = &#39;latin1&#39;
        self.log_info(
            F&#39;inno {version!s} &#39;
            F&#39;compression:{stream0.Header.CompressionMethod.name} &#39;
            F&#39;codepage:{codec} &#39;
            F&#39;password:{stream0.Header.PasswordType.name} &#39;
        )

        if (script := stream0.Header.CompiledCode) and encrypted_file:
            assert password is None, (
                F&#39;An encrypted test file was chosen even though a password was provided: {password!r}&#39;)
            self.log_info(F&#39;guessing password using encrypted file: {encrypted_file.path}&#39;)
            try:
                def _pwd(s: str):
                    if not s:
                        return False
                    if re.search(r&#39;\{\w+\}&#39;, s):
                        return False
                    if re.search(R&#39;^\w{2,12}://&#39;, s):
                        return False
                    return True
                from refinery.units.formats.ifpsstr import ifpsstr
                from itertools import combinations
                strings = script | ifpsstr(codec) | {str}
                strings = [s for s in strings if _pwd(s)]
                total = 0
                for k in range(1, 10):
                    self.log_info(F&#39;checking combinations of {k} strings as potential password&#39;)
                    if total &gt; self._MAX_ATTEMPTS:
                        break
                    for parts in combinations(strings, k):
                        if total &gt; self._MAX_ATTEMPTS:
                            break
                        string = &#39;&#39;.join(parts)
                        tests = [string]
                        try:
                            tests.append(bytes.fromhex(string))
                        except Exception:
                            pass
                        try:
                            tests.append(base64.b64decode(string).decode(codec))
                        except Exception:
                            pass
                        for pwd in tests:
                            try:
                                plaintext = self._read_file(encrypted_file, password=pwd)
                                if not encrypted_file.check(plaintext):
                                    continue
                                password = pwd
                                btw = F&#39; (combination of {k} parts)&#39; if k &gt; 1 else &#39;&#39;
                                self.log_info(F&#39;found password{btw}: {pwd}&#39;)
                                break
                            except Exception:
                                continue
                            finally:
                                total += 1
                        if password is not None:
                            break
            except Exception as e:
                self.log_info(F&#39;failed to extract strings from IFPS: {exception_to_string(e)}&#39;)

        if encrypted_file and password is None:
            self.log_warn(&#39;some files are password-protected and automatic password search failed&#39;)

        yield self._pack(streams[0].name, None, streams[0].data)
        with BytesAsStringEncoder as encoder:
            yield self._pack(F&#39;{streams[0].name}.json&#39;, None,
                encoder.dumps(stream0.json()).encode(self.codec))

        yield self._pack(streams[1].name, None, streams[1].data)
        with BytesAsStringEncoder as encoder:
            yield self._pack(F&#39;{streams[1].name}.json&#39;, None,
                encoder.dumps(stream1.json()).encode(self.codec))

        yield self._pack(
            streams[2].name, None, lambda s=streams[2]: self._read_stream(s))

        if license := stream0.Header.get_license():
            yield self._pack(self._LICENSE_NAME, None, license.encode(self.codec))

        if script:
            from refinery.units.formats.ifps import ifps
            yield self._pack(F&#39;{self._ISCRIPT_NAME}.ps&#39;, None, script | ifps(codec) | bytes)
            yield self._pack(F&#39;{self._ISCRIPT_NAME}.bin&#39;, None, script)

        if dll := stream0.DecompressDLL:
            yield self._pack(F&#39;embedded/decompress.{magic(dll).extension}&#39;, None, dll)

        if dll := stream0.DecryptionDLL:
            yield self._pack(F&#39;embedded/decryption.{magic(dll).extension}&#39;, None, dll)

        for size, images in (
            (&#39;small&#39;, stream0.WizardImagesSmall),
            (&#39;large&#39;, stream0.WizardImagesLarge),
        ):
            _formatting = len(str(len(images) + 1))
            for k, img in enumerate(images, 1):
                yield self._pack(F&#39;embedded/images/{size}{k:0{_formatting}d}.{magic(img).extension}&#39;, None, img)

        for file in files:
            if file.dupe:
                continue
            yield self._pack(
                file.path,
                file.date,
                lambda f=file: self._read_file_and_check(f, password=password),
                tags=[t.name for t in SetupFileFlags if t &amp; file.tags],
            )

    def _try_parse_as(
        self,
        inno: StructReader,
        blobs: StructReader,
        version: InnoVersion,
        password: Optional[str] = None,
        max_failures: int = 5
    ):
        streams: List[InnoStream] = []
        files: List[InnoFile] = []
        encrypted_file = None
        warnings = 0

        for name in self._STREAM_NAMES:
            stream = InnoStream(StreamHeader(inno, name, version))
            streams.append(stream)
            to_read = stream.header.StoredSize
            while to_read &gt; 4:
                block = CrcCompressedBlock(inno, min(to_read - 4, 0x1000))
                stream.blocks.append(block)
                to_read -= len(block)

        self.log_debug(F&#39;{version!s} parsing stream 1 (TData)&#39;)
        stream1 = TData(memoryview(self._read_stream(streams[1])), version)

        for meta in stream1.DataEntries:
            file = InnoFile(blobs, version, meta)
            files.append(file)
            if password or not file.encrypted or not file.size:
                continue
            if encrypted_file is None or file.size &lt; encrypted_file.size:
                encrypted_file = file

        self.log_debug(F&#39;{version!s} parsing stream 0 (TSetup)&#39;)
        stream0 = TSetup(memoryview(self._read_stream(streams[0])), version)
        path_dedup: dict[str, list[SetupFile]] = {}

        for file in files:
            file.compression_method = stream0.Header.CompressionMethod
            file.password_hash = stream0.Header.PasswordHash
            file.password_type = stream0.Header.PasswordType
            file.password_salt = stream0.Header.PasswordSalt

        for sf in stream0.Files:
            sf: SetupFile
            location = sf.Location
            if location == 0xFFFFFFFF or sf.Type != SetupFileType.UserFile or sf.Source:
                msg = F&#39;skipping file: offset=0x{location:08X} type={sf.Type.name}&#39;
                if sf.Source:
                    msg = F&#39;{msg} src={sf.Source}&#39;
                self.log_debug(msg)
                continue
            if location &gt;= len(files):
                self.log_warn(F&#39;parsed {len(file)} entries, ignoring invalid setup reference to entry {location + 1}&#39;)
                continue
            path = sf.Destination.replace(&#39;\\&#39;, &#39;/&#39;)
            if condition := sf.Condition.Check:
                condition = condition.replace(&#39; &#39;, &#39;-&#39;)
                path = F&#39;{condition}/{path}&#39;
            path = F&#39;data/{path}&#39;
            path_dedup.setdefault(path, []).append(sf)
            files[location].setup = sf
            files[location].path = path

        for path, infos in path_dedup.items():
            if len(infos) == 1:
                files[infos[0].Location].path = path
                continue
            bycheck = {}
            for info in infos:
                file = files[info.Location]
                if not file.checksum_type.strong():
                    bycheck.clear()
                    break
                dkey = (file.checksum, file.size)
                if dkey in bycheck:
                    self.log_debug(F&#39;skipping exact duplicate: {path}&#39;)
                    file.dupe = True
                    continue
                bycheck[dkey] = info
            if bycheck:
                if len(bycheck) == 1:
                    file.path = path
                    continue
                infos = list(bycheck.values())
            for k, info in enumerate(infos):
                files[info.Location].path = F&#39;{path}[{k}]&#39;

        _width = len(str(len(files)))

        for k, file in enumerate(files):
            if file.dupe:
                continue
            if not file.path:
                self.log_debug(F&#39;file {k} does not have a path&#39;)
                file.path = F&#39;raw/FileData{k:0{_width}d}&#39;

        warnings = sum(1 for file in files if file.setup is None)
        failures = []
        nonempty = [f for f in files if f.size &gt; 0]

        self._decompressed.clear()

        for file in nonempty:
            if len(failures) &gt;= max_failures:
                break
            if file.setup is None:
                failures.append(F&#39;file {file.path} had no associated metadata&#39;)
                continue
            if file.chunk_length &lt; 0x10000:
                try:
                    data = self._read_file(file)
                except InvalidPassword:
                    continue
                except Exception as e:
                    failures.append(F&#39;extraction error for {file.path}: {e!s}&#39;)
                    continue
                if file.check(data) != file.checksum:
                    failures.append(F&#39;invalid checksum for {file.path}&#39;)

        return InnoParseResult(
            version,
            streams,
            files,
            encrypted_file,
            warnings,
            failures,
            stream0,
            stream1,
        )

    def _read_stream(self, stream: InnoStream):
        if stream.data is not None:
            return stream.data
        result = bytearray()
        it = iter(stream.blocks)
        if stream.compression == StreamCompressionMethod.Store:
            class _dummy(self):
                def decompress(self, b):
                    return b
            dec = _dummy()
        elif stream.compression == StreamCompressionMethod.LZMA1:
            import lzma
            first = next(it).BlockData
            prop, first = first[:5], first[5:]
            filter = parse_lzma_properties(prop, 1)
            dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[filter])
            result.extend(dec.decompress(first))
        elif stream.compression == StreamCompressionMethod.Flate:
            import zlib
            dec = zlib.decompressobj()
        for block in it:
            result.extend(dec.decompress(block.BlockData))
        stream.data = result
        return result

    def _read_chunk(self, file: InnoFile, password: Optional[str] = None):
        reader = file.reader
        offset = file.chunk_offset
        length = file.chunk_length
        method = file.compression

        if offset + length &gt; len(reader):
            span = F&#39;0x{offset:X}-0x{offset + length:X}&#39;
            raise LookupError(
                F&#39;File data spans 0x{len(file.reader):X} bytes, but the file {file.path} is located at {span}.&#39;)

        reader.seek(offset)
        prefix = reader.read(4)

        if prefix != self._CHUNK_PREFIX:
            raise ValueError(F&#39;Error reading chunk at offset 0x{offset:X}; invalid magic {prefix.hex()}.&#39;)

        if file.encrypted:
            if file.password_type == PasswordType.Nothing:
                raise RuntimeError(F&#39;File {file.path} is encrypted, but no password type was set.&#39;)
            if password is None:
                raise InvalidPassword
            if file.password_type == PasswordType.XChaCha20:
                salt, iterations, nonce = struct.unpack(&#39;=16sI24s&#39;, file.password_salt)
                key = password.encode(&#39;utf8&#39;) | pbkdf2(32, salt, iterations, &#39;SHA256&#39;) | bytes
                test_nonce = list(struct.unpack(&#39;6I&#39;, nonce))
                test_nonce[2] = ~test_nonce[2]
                test_nonce = struct.pack(&#39;6I&#39;, test_nonce)
                if B&#39;\0\0\0\0&#39; | xchacha(key, nonce=test_nonce) | bytes != file.password_hash:
                    raise InvalidPassword(password)
                decryptor = xchacha(key, nonce=nonce)
            else:
                password_bytes = password.encode(
                    &#39;utf-16le&#39; if file.unicode else &#39;utf8&#39;)
                algorithm = {
                    PasswordType.SHA1: sha1,
                    PasswordType.MD5 : md5,
                }[file.password_type]
                hash = algorithm(b&#39;PasswordCheckHash&#39; + file.password_salt)
                hash.update(password_bytes)
                if hash.digest() != file.password_hash:
                    raise InvalidPassword(password)
                hash = algorithm(reader.read(8))
                hash.update(password_bytes)
                decryptor = rc4(hash.digest(), discard=1000)

        data = reader.read_exactly(length)

        if file.encrypted:
            data = data | decryptor | bytearray

        if method is None:
            return chunk

        try:
            if method == CompressionMethod.Store:
                chunk = data
            elif method == CompressionMethod.LZMA1:
                props = parse_lzma_properties(data[0:5], 1)
                dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[props])
                chunk = dec.decompress(data[5:])
            elif method == CompressionMethod.LZMA2:
                props = parse_lzma_properties(data[0:1], 2)
                dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[props])
                chunk = dec.decompress(data[1:])
            elif method == CompressionMethod.BZip2:
                chunk = bz2.decompress(data)
            elif method == CompressionMethod.Flate:
                chunk = zlib.decompress(data)
        except Exception as E:
            if not file.encrypted:
                raise
            raise InvalidPassword(password) from E

        return chunk

    def _read_file(
        self,
        file: InnoFile,
        password: Optional[str] = None,
    ):
        offset = file.chunk_offset
        length = file.chunk_length

        try:
            chunk = self._decompressed[offset, length]
        except KeyError:
            chunk = self._decompressed[offset, length] = self._read_chunk(file, password)

        view = memoryview(chunk)
        data = view[file.offset:file.offset + file.size]

        if file.filtered:
            if file.version &gt;= (5, 2, 0):
                flip = (file.version &gt;= (5, 3, 9))
                data = self._filter_new(data, flip_high_byte=flip)
            else:
                data = self._filter_old(data)

        return data

    def _read_file_and_check(
        self,
        file: InnoFile,
        password: Optional[str] = None,
    ):
        data = self._read_file(file, password)

        if not self.leniency and (cs := file.check(data)) is not None and cs != file.checksum:
            if isinstance(cs, int):
                computed = F&#39;{cs:08X}&#39;
                expected = F&#39;{file.checksum:08X}&#39;
            else:
                computed = cs.hex().upper()
                expected = file.checksum.hex().upper()
            raise ValueError(F&#39;checksum error; computed:{computed} expected:{expected} [ignore this check with -L]&#39;)

        return data

    @ArchiveUnit.Requires(&#39;numpy&#39;, &#39;speed&#39;, &#39;default&#39;, &#39;extended&#39;)
    def _numpy():
        import numpy
        return numpy

    def _filter_new(self, data: ByteStr, flip_high_byte=False):
        try:
            np = self._numpy
        except ImportError:
            return self._filter_new_fallback(data, flip_high_byte)
        u08 = np.uint8
        u32 = np.uint32
        ab0 = bytearray()
        ab1 = bytearray()
        ab2 = bytearray()
        ab3 = bytearray()
        positions = []
        if isinstance(data, bytearray):
            out = data
        else:
            out = bytearray(data)
        mem = memoryview(out)
        for k in range(0, len(mem), 0x10000):
            for match in re.finditer(B&#39;(?s)[\xE8\xE9]....&#39;, mem[k:k + 0x10000], flags=re.DOTALL):
                a = match.start() + k
                top = mem[a + 4]
                if top != 0x00 and top != 0xFF:
                    continue
                ab0.append(mem[a + 1])
                ab1.append(mem[a + 2])
                ab2.append(mem[a + 3])
                ab3.append(top)
                positions.append(a + 5)
        ab0 = np.frombuffer(ab0, dtype=u08)
        ab1 = np.frombuffer(ab1, dtype=u08)
        low = np.frombuffer(ab2, dtype=u08).astype(u32)
        msb = np.frombuffer(ab3, dtype=u08)
        sub = np.fromiter(positions, dtype=u32)
        low &lt;&lt;= 8
        low += ab1
        low &lt;&lt;= 8
        low += ab0
        low -= sub
        low &amp;= 0xFFFFFF
        if flip_high_byte:
            flips = low &gt;&gt; 23
            keeps = 1 - flips
            keeps *= msb
            msb ^= 0xFF
            msb *= flips
            msb += keeps
        low += (msb.astype(u32) &lt;&lt; 24)
        addresses = low.tobytes()
        for k, offset in enumerate(positions):
            out[offset - 4:offset] = addresses[k * 4:(k + 1) * 4]
        return out

    def _filter_new_fallback(self, data: ByteStr, flip_high_byte=False):
        block_size = 0x10000
        out = bytearray(data)
        i = 0
        while len(data) - i &gt;= 5:
            c = out[i]
            block_size_left = block_size - (i % block_size)
            i += 1
            if (c == 0xE8 or c == 0xE9) and block_size_left &gt;= 5:
                address = out[i:i + 4]
                i += 4
                if address[3] == 0 or address[3] == 0xFF:
                    rel = address[0] | address[1] &lt;&lt; 8 | address[2] &lt;&lt; 16
                    rel -= i &amp; 0xFFFFFF
                    out[i - 4] = rel &amp; 0xFF
                    out[i - 3] = (rel &gt;&gt; 8) &amp; 0xFF
                    out[i - 2] = (rel &gt;&gt; 16) &amp; 0xFF
                    if flip_high_byte and (rel &amp; 0x800000) != 0:
                        out[i - 1] = (~out[i - 1]) &amp; 0xFF
        return out

    @staticmethod
    def _filter_old(data: ByteStr):
        if not isinstance(data, bytearray):
            data = bytearray(data)
        addr_bytes_left = 0
        addr_offset = 5
        addr = 0
        for i, c in enumerate(data):
            if addr_bytes_left == 0:
                if c == 0xE8 or c == 0xE9:
                    addr = (~addr_offset + 1) &amp; 0xFFFFFFFF
                    addr_bytes_left = 4
            else:
                addr = (addr + c) &amp; 0xFFFFFFFF
                c = addr &amp; 0xFF
                addr = addr &gt;&gt; 8
                addr_bytes_left -= 1
            data[i] = c
        return data

    @classmethod
    def handles(self, data):
        if data[:2] != B&#39;MZ&#39;:
            return False
        if re.search(re.escape(self._CHUNK_PREFIX), data) is None:
            return False
        return bool(
            re.search(BR&#39;Inno Setup Setup Data \(\d+\.\d+\.&#39;, data))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InvalidPassword"><code class="flex name class">
<span>class <span class="ident">InvalidPassword</span></span>
<span>(</span><span>password=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Inappropriate argument value (of correct type).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L56-L61" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InvalidPassword(ValueError):
    def __init__(self, password: Optional[str] = None):
        if password is None:
            super().__init__(&#39;A password is required and none was given.&#39;)
        else:
            super().__init__(&#39;The given password is not correct.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.IncorrectVersion"><code class="flex name class">
<span>class <span class="ident">IncorrectVersion</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Unspecified run-time error.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L64-L65" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IncorrectVersion(RuntimeError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.RuntimeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.FileChunkOutOfBounds"><code class="flex name class">
<span>class <span class="ident">FileChunkOutOfBounds</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for lookup errors.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L68-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FileChunkOutOfBounds(LookupError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.LookupError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.IVF"><code class="flex name class">
<span>class <span class="ident">IVF</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L72-L80" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IVF(enum.IntFlag):
    NoFlag   = 0b0000 # noqa
    Legacy   = 0b0001 # noqa
    Bits16   = 0b0010 # noqa
    UTF_16   = 0b0100 # noqa
    InnoSX   = 0b1000 # noqa
    Legacy32 = 0b0001
    Legacy16 = 0b0011
    IsLegacy = 0b0011</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.IVF.NoFlag"><code class="name">var <span class="ident">NoFlag</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.IVF.Legacy"><code class="name">var <span class="ident">Legacy</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.IVF.Bits16"><code class="name">var <span class="ident">Bits16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.IVF.UTF_16"><code class="name">var <span class="ident">UTF_16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.IVF.InnoSX"><code class="name">var <span class="ident">InnoSX</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.IVF.Legacy32"><code class="name">var <span class="ident">Legacy32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.IVF.Legacy16"><code class="name">var <span class="ident">Legacy16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.IVF.IsLegacy"><code class="name">var <span class="ident">IsLegacy</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion"><code class="flex name class">
<span>class <span class="ident">InnoVersion</span></span>
<span>(</span><span>major, minor, patch, build=0, flags=IVF.NoFlag)</span>
</code></dt>
<dd>
<section class="desc"><p>InnoVersion(major, minor, patch, build, flags)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L90-L174" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoVersion(NamedTuple):
    major: int
    minor: int
    patch: int
    build: int = 0
    flags: IVF = IVF.NoFlag

    @property
    def semver(self):
        return (self.major, self.minor, self.patch, self.build)

    @property
    def unicode(self):
        return self.flags &amp; IVF.UTF_16 == IVF.UTF_16

    @property
    def legacy(self):
        return self.flags &amp; IVF.Legacy

    @property
    def ascii(self):
        return self.flags &amp; IVF.UTF_16 == IVF.NoFlag

    @property
    def isx(self):
        return bool(self.flags &amp; IVF.InnoSX)

    @property
    def bits(self):
        return 0x10 if self.flags &amp; IVF.Bits16 else 0x20

    @classmethod
    def ParseLegacy(cls, dfn: bytes):
        v, s, _ = dfn.partition(B&#39;\x1A&#39;)
        if s and (m := re.fullmatch(BR&#39;i(\d+)\.(\d+)\.(\d+)--(16|32)&#39;, v)):
            major = int(m[1])
            minor = int(m[2])
            build = int(m[3])
            flags = IVF.Legacy16 if m[3] == B&#39;16&#39; else IVF.Legacy32
            return cls(major, minor, build, 0, flags)
        raise ValueError(dfn)

    @classmethod
    def Parse(cls, dfn: bytes):
        versions: List[InnoVersion] = []
        for match in [m.groups() for m in re.finditer(rb&#39;(.*?)\((\d+(?:\.\d+){2,3})(?:.*?\(([uU])\))?&#39;, dfn)]:
            sv = tuple(map(int, match[1].split(B&#39;.&#39;)))
            sv = (sv + (0,))[:4]
            vf = IVF.NoFlag
            if sv &gt;= (6, 3, 0) or match[2]:
                vf |= IVF.UTF_16
            if any(isx in match[0] for isx in (B&#39;My Inno Setup Extensions&#39;, B&#39;with ISX&#39;)):
                vf |= IVF.InnoSX
            versions.append(InnoVersion(*sv, vf))
        if len(versions) == 1:
            return versions[0]
        if len(versions) == 2:
            a, b = versions
            return InnoVersion(*max(a.semver, b.semver), a.flags | b.flags)
        raise ValueError(dfn)

    def __str__(self):
        v = F&#39;v{self.major}.{self.minor}.{self.patch:02d}.{self.build}&#39;
        a = R&#39;a&#39;
        u = R&#39;u&#39;
        if self.flags &amp; IVF.InnoSX:
            a = R&#39;&#39;
            v = F&#39;{v}x&#39;
        t = u if self.flags &amp; IVF.UTF_16 else a
        v = F&#39;{v}{t}&#39;
        if b := {
            IVF.Legacy16: &#39;16&#39;,
            IVF.Legacy32: &#39;32&#39;,
        }.get(self.flags &amp; IVF.IsLegacy):
            v = F&#39;{v}/{b}&#39;
        return v

    def __repr__(self):
        return str(self)

    def is_ambiguous(self):
        try:
            return _IS_AMBIGUOUS[self]
        except KeyError:
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.ParseLegacy"><code class="name flex">
<span>def <span class="ident">ParseLegacy</span></span>(<span>dfn)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L121-L130" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def ParseLegacy(cls, dfn: bytes):
    v, s, _ = dfn.partition(B&#39;\x1A&#39;)
    if s and (m := re.fullmatch(BR&#39;i(\d+)\.(\d+)\.(\d+)--(16|32)&#39;, v)):
        major = int(m[1])
        minor = int(m[2])
        build = int(m[3])
        flags = IVF.Legacy16 if m[3] == B&#39;16&#39; else IVF.Legacy32
        return cls(major, minor, build, 0, flags)
    raise ValueError(dfn)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>dfn)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L132-L149" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def Parse(cls, dfn: bytes):
    versions: List[InnoVersion] = []
    for match in [m.groups() for m in re.finditer(rb&#39;(.*?)\((\d+(?:\.\d+){2,3})(?:.*?\(([uU])\))?&#39;, dfn)]:
        sv = tuple(map(int, match[1].split(B&#39;.&#39;)))
        sv = (sv + (0,))[:4]
        vf = IVF.NoFlag
        if sv &gt;= (6, 3, 0) or match[2]:
            vf |= IVF.UTF_16
        if any(isx in match[0] for isx in (B&#39;My Inno Setup Extensions&#39;, B&#39;with ISX&#39;)):
            vf |= IVF.InnoSX
        versions.append(InnoVersion(*sv, vf))
    if len(versions) == 1:
        return versions[0]
    if len(versions) == 2:
        a, b = versions
        return InnoVersion(*max(a.semver, b.semver), a.flags | b.flags)
    raise ValueError(dfn)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.major"><code class="name">var <span class="ident">major</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.minor"><code class="name">var <span class="ident">minor</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.build"><code class="name">var <span class="ident">build</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 4</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.semver"><code class="name">var <span class="ident">semver</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L97-L99" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def semver(self):
    return (self.major, self.minor, self.patch, self.build)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.unicode"><code class="name">var <span class="ident">unicode</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L101-L103" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def unicode(self):
    return self.flags &amp; IVF.UTF_16 == IVF.UTF_16</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.legacy"><code class="name">var <span class="ident">legacy</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L105-L107" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def legacy(self):
    return self.flags &amp; IVF.Legacy</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.ascii"><code class="name">var <span class="ident">ascii</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L109-L111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def ascii(self):
    return self.flags &amp; IVF.UTF_16 == IVF.NoFlag</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.isx"><code class="name">var <span class="ident">isx</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L113-L115" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def isx(self):
    return bool(self.flags &amp; IVF.InnoSX)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.bits"><code class="name">var <span class="ident">bits</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def bits(self):
    return 0x10 if self.flags &amp; IVF.Bits16 else 0x20</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InnoVersion.is_ambiguous"><code class="name flex">
<span>def <span class="ident">is_ambiguous</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L170-L174" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_ambiguous(self):
    try:
        return _IS_AMBIGUOUS[self]
    except KeyError:
        return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.JsonStruct"><code class="flex name class">
<span>class <span class="ident">JsonStruct</span></span>
<span>(</span><span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L302-L321" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class JsonStruct(Struct):
    def json(self):
        def _json(v):
            if isinstance(v, list):
                return [_json(x) for x in v]
            if isinstance(v, dict):
                return {x: _json(y) for x, y in v.items()}
            if isinstance(v, JsonStruct):
                return v.json()
            if isinstance(v, enum.IntFlag):
                return [option.name for option in v.__class__ if v &amp; option == option]
            if isinstance(v, enum.IntEnum):
                return v.name
            if isinstance(v, memoryview):
                return codecs.decode(v, &#39;latin1&#39;)
            return v
        return {
            k: _json(v) for k, v in self.__dict__.items()
            if not k.startswith(&#39;_&#39;)
        }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.CrcCompressedBlock" href="#refinery.units.formats.archive.xtinno.CrcCompressedBlock">CrcCompressedBlock</a></li>
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.LanguageId" href="#refinery.units.formats.archive.xtinno.LanguageId">LanguageId</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.JsonStruct.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L303-L321" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self):
    def _json(v):
        if isinstance(v, list):
            return [_json(x) for x in v]
        if isinstance(v, dict):
            return {x: _json(y) for x, y in v.items()}
        if isinstance(v, JsonStruct):
            return v.json()
        if isinstance(v, enum.IntFlag):
            return [option.name for option in v.__class__ if v &amp; option == option]
        if isinstance(v, enum.IntEnum):
            return v.name
        if isinstance(v, memoryview):
            return codecs.decode(v, &#39;latin1&#39;)
        return v
    return {
        k: _json(v) for k, v in self.__dict__.items()
        if not k.startswith(&#39;_&#39;)
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoStruct"><code class="flex name class">
<span>class <span class="ident">InnoStruct</span></span>
<span>(</span><span>reader, version, codec='latin1')</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L324-L337" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoStruct(JsonStruct):
    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, codec: str = &#39;latin1&#39;):
        if version.unicode:
            self._read_string = functools.partial(
                reader.read_length_prefixed_utf16, bytecount=True)
        else:
            def _read():
                data = reader.read_length_prefixed()
                try:
                    return codecs.decode(data, codec)
                except (LookupError, UnicodeDecodeError):
                    # TODO
                    return codecs.decode(data, &#39;latin1&#39;)
            self._read_string = _read</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.SetupComponent" href="#refinery.units.formats.archive.xtinno.SetupComponent">SetupComponent</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupCondition" href="#refinery.units.formats.archive.xtinno.SetupCondition">SetupCondition</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupDataEntry" href="#refinery.units.formats.archive.xtinno.SetupDataEntry">SetupDataEntry</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupDeleteEntry" href="#refinery.units.formats.archive.xtinno.SetupDeleteEntry">SetupDeleteEntry</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupDirectory" href="#refinery.units.formats.archive.xtinno.SetupDirectory">SetupDirectory</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupFile" href="#refinery.units.formats.archive.xtinno.SetupFile">SetupFile</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupHeader" href="#refinery.units.formats.archive.xtinno.SetupHeader">SetupHeader</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupIcon" href="#refinery.units.formats.archive.xtinno.SetupIcon">SetupIcon</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupIniEntry" href="#refinery.units.formats.archive.xtinno.SetupIniEntry">SetupIniEntry</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupLanguage" href="#refinery.units.formats.archive.xtinno.SetupLanguage">SetupLanguage</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupMessage" href="#refinery.units.formats.archive.xtinno.SetupMessage">SetupMessage</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupPermission" href="#refinery.units.formats.archive.xtinno.SetupPermission">SetupPermission</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupRegistryEntry" href="#refinery.units.formats.archive.xtinno.SetupRegistryEntry">SetupRegistryEntry</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupRunEntry" href="#refinery.units.formats.archive.xtinno.SetupRunEntry">SetupRunEntry</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupTask" href="#refinery.units.formats.archive.xtinno.SetupTask">SetupTask</a></li>
<li><a title="refinery.units.formats.archive.xtinno.SetupType" href="#refinery.units.formats.archive.xtinno.SetupType">SetupType</a></li>
<li><a title="refinery.units.formats.archive.xtinno.StreamHeader" href="#refinery.units.formats.archive.xtinno.StreamHeader">StreamHeader</a></li>
<li><a title="refinery.units.formats.archive.xtinno.TData" href="#refinery.units.formats.archive.xtinno.TData">TData</a></li>
<li><a title="refinery.units.formats.archive.xtinno.TSetup" href="#refinery.units.formats.archive.xtinno.TSetup">TSetup</a></li>
<li><a title="refinery.units.formats.archive.xtinno.Version" href="#refinery.units.formats.archive.xtinno.Version">Version</a></li>
<li><a title="refinery.units.formats.archive.xtinno.WinVerRange" href="#refinery.units.formats.archive.xtinno.WinVerRange">WinVerRange</a></li>
<li><a title="refinery.units.formats.archive.xtinno.WindowsVersion" href="#refinery.units.formats.archive.xtinno.WindowsVersion">WindowsVersion</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CheckSumType"><code class="flex name class">
<span>class <span class="ident">CheckSumType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L340-L349" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CheckSumType(enum.IntEnum):
    Missing = 0 # noqa
    Adler32 = 1 # noqa
    CRC32   = 2 # noqa
    MD5     = 3 # noqa
    SHA1    = 4 # noqa
    SHA256  = 5 # noqa

    def strong(self):
        return self.value &gt;= 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.CheckSumType.Missing"><code class="name">var <span class="ident">Missing</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CheckSumType.Adler32"><code class="name">var <span class="ident">Adler32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CheckSumType.CRC32"><code class="name">var <span class="ident">CRC32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CheckSumType.MD5"><code class="name">var <span class="ident">MD5</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CheckSumType.SHA1"><code class="name">var <span class="ident">SHA1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CheckSumType.SHA256"><code class="name">var <span class="ident">SHA256</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.CheckSumType.strong"><code class="name flex">
<span>def <span class="ident">strong</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L348-L349" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def strong(self):
    return self.value &gt;= 3</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags"><code class="flex name class">
<span>class <span class="ident">Flags</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L352-L418" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Flags(enum.IntFlag):
    Empty                       = 0           # noqa
    DisableStartupPrompt        = enum.auto() # noqa
    Uninstallable               = enum.auto() # noqa
    CreateAppDir                = enum.auto() # noqa
    DisableDirPage              = enum.auto() # noqa
    DisableDirExistsWarning     = enum.auto() # noqa
    DisableProgramGroupPage     = enum.auto() # noqa
    AllowNoIcons                = enum.auto() # noqa
    AlwaysRestart               = enum.auto() # noqa
    BackSolid                   = enum.auto() # noqa
    AlwaysUsePersonalGroup      = enum.auto() # noqa
    WindowVisible               = enum.auto() # noqa
    WindowShowCaption           = enum.auto() # noqa
    WindowResizable             = enum.auto() # noqa
    WindowStartMaximized        = enum.auto() # noqa
    EnableDirDoesntExistWarning = enum.auto() # noqa
    DisableAppendDir            = enum.auto() # noqa
    Password                    = enum.auto() # noqa
    AllowRootDirectory          = enum.auto() # noqa
    DisableFinishedPage         = enum.auto() # noqa
    AdminPrivilegesRequired     = enum.auto() # noqa
    AlwaysCreateUninstallIcon   = enum.auto() # noqa
    OverwriteUninstRegEntries   = enum.auto() # noqa
    ChangesAssociations         = enum.auto() # noqa
    CreateUninstallRegKey       = enum.auto() # noqa
    UsePreviousAppDir           = enum.auto() # noqa
    BackColorHorizontal         = enum.auto() # noqa
    UsePreviousGroup            = enum.auto() # noqa
    UpdateUninstallLogAppName   = enum.auto() # noqa
    UsePreviousSetupType        = enum.auto() # noqa
    DisableReadyMemo            = enum.auto() # noqa
    AlwaysShowComponentsList    = enum.auto() # noqa
    FlatComponentsList          = enum.auto() # noqa
    ShowComponentSizes          = enum.auto() # noqa
    UsePreviousTasks            = enum.auto() # noqa
    DisableReadyPage            = enum.auto() # noqa
    AlwaysShowDirOnReadyPage    = enum.auto() # noqa
    AlwaysShowGroupOnReadyPage  = enum.auto() # noqa
    BzipUsed                    = enum.auto() # noqa
    AllowUNCPath                = enum.auto() # noqa
    UserInfoPage                = enum.auto() # noqa
    UsePreviousUserInfo         = enum.auto() # noqa
    UninstallRestartComputer    = enum.auto() # noqa
    RestartIfNeededByRun        = enum.auto() # noqa
    ShowTasksTreeLines          = enum.auto() # noqa
    ShowLanguageDialog          = enum.auto() # noqa
    DetectLanguageUsingLocale   = enum.auto() # noqa
    AllowCancelDuringInstall    = enum.auto() # noqa
    WizardImageStretch          = enum.auto() # noqa
    AppendDefaultDirName        = enum.auto() # noqa
    AppendDefaultGroupName      = enum.auto() # noqa
    EncryptionUsed              = enum.auto() # noqa
    ChangesEnvironment          = enum.auto() # noqa
    ShowUndisplayableLanguages  = enum.auto() # noqa
    SetupLogging                = enum.auto() # noqa
    SignedUninstaller           = enum.auto() # noqa
    UsePreviousLanguage         = enum.auto() # noqa
    DisableWelcomePage          = enum.auto() # noqa
    CloseApplications           = enum.auto() # noqa
    RestartApplications         = enum.auto() # noqa
    AllowNetworkDrive           = enum.auto() # noqa
    ForceCloseApplications      = enum.auto() # noqa
    AppNameHasConsts            = enum.auto() # noqa
    UsePreviousPrivileges       = enum.auto() # noqa
    WizardResizable             = enum.auto() # noqa
    UninstallLogging            = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.Flags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.DisableStartupPrompt"><code class="name">var <span class="ident">DisableStartupPrompt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.Uninstallable"><code class="name">var <span class="ident">Uninstallable</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.CreateAppDir"><code class="name">var <span class="ident">CreateAppDir</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.DisableDirPage"><code class="name">var <span class="ident">DisableDirPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.DisableDirExistsWarning"><code class="name">var <span class="ident">DisableDirExistsWarning</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.DisableProgramGroupPage"><code class="name">var <span class="ident">DisableProgramGroupPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AllowNoIcons"><code class="name">var <span class="ident">AllowNoIcons</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AlwaysRestart"><code class="name">var <span class="ident">AlwaysRestart</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.BackSolid"><code class="name">var <span class="ident">BackSolid</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AlwaysUsePersonalGroup"><code class="name">var <span class="ident">AlwaysUsePersonalGroup</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.WindowVisible"><code class="name">var <span class="ident">WindowVisible</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.WindowShowCaption"><code class="name">var <span class="ident">WindowShowCaption</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.WindowResizable"><code class="name">var <span class="ident">WindowResizable</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.WindowStartMaximized"><code class="name">var <span class="ident">WindowStartMaximized</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.EnableDirDoesntExistWarning"><code class="name">var <span class="ident">EnableDirDoesntExistWarning</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.DisableAppendDir"><code class="name">var <span class="ident">DisableAppendDir</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.Password"><code class="name">var <span class="ident">Password</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AllowRootDirectory"><code class="name">var <span class="ident">AllowRootDirectory</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.DisableFinishedPage"><code class="name">var <span class="ident">DisableFinishedPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AdminPrivilegesRequired"><code class="name">var <span class="ident">AdminPrivilegesRequired</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AlwaysCreateUninstallIcon"><code class="name">var <span class="ident">AlwaysCreateUninstallIcon</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.OverwriteUninstRegEntries"><code class="name">var <span class="ident">OverwriteUninstRegEntries</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.ChangesAssociations"><code class="name">var <span class="ident">ChangesAssociations</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.CreateUninstallRegKey"><code class="name">var <span class="ident">CreateUninstallRegKey</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UsePreviousAppDir"><code class="name">var <span class="ident">UsePreviousAppDir</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.BackColorHorizontal"><code class="name">var <span class="ident">BackColorHorizontal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UsePreviousGroup"><code class="name">var <span class="ident">UsePreviousGroup</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UpdateUninstallLogAppName"><code class="name">var <span class="ident">UpdateUninstallLogAppName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UsePreviousSetupType"><code class="name">var <span class="ident">UsePreviousSetupType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.DisableReadyMemo"><code class="name">var <span class="ident">DisableReadyMemo</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AlwaysShowComponentsList"><code class="name">var <span class="ident">AlwaysShowComponentsList</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.FlatComponentsList"><code class="name">var <span class="ident">FlatComponentsList</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.ShowComponentSizes"><code class="name">var <span class="ident">ShowComponentSizes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UsePreviousTasks"><code class="name">var <span class="ident">UsePreviousTasks</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.DisableReadyPage"><code class="name">var <span class="ident">DisableReadyPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AlwaysShowDirOnReadyPage"><code class="name">var <span class="ident">AlwaysShowDirOnReadyPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AlwaysShowGroupOnReadyPage"><code class="name">var <span class="ident">AlwaysShowGroupOnReadyPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.BzipUsed"><code class="name">var <span class="ident">BzipUsed</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AllowUNCPath"><code class="name">var <span class="ident">AllowUNCPath</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UserInfoPage"><code class="name">var <span class="ident">UserInfoPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UsePreviousUserInfo"><code class="name">var <span class="ident">UsePreviousUserInfo</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UninstallRestartComputer"><code class="name">var <span class="ident">UninstallRestartComputer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.RestartIfNeededByRun"><code class="name">var <span class="ident">RestartIfNeededByRun</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.ShowTasksTreeLines"><code class="name">var <span class="ident">ShowTasksTreeLines</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.ShowLanguageDialog"><code class="name">var <span class="ident">ShowLanguageDialog</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.DetectLanguageUsingLocale"><code class="name">var <span class="ident">DetectLanguageUsingLocale</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AllowCancelDuringInstall"><code class="name">var <span class="ident">AllowCancelDuringInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.WizardImageStretch"><code class="name">var <span class="ident">WizardImageStretch</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AppendDefaultDirName"><code class="name">var <span class="ident">AppendDefaultDirName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AppendDefaultGroupName"><code class="name">var <span class="ident">AppendDefaultGroupName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.EncryptionUsed"><code class="name">var <span class="ident">EncryptionUsed</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.ChangesEnvironment"><code class="name">var <span class="ident">ChangesEnvironment</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.ShowUndisplayableLanguages"><code class="name">var <span class="ident">ShowUndisplayableLanguages</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.SetupLogging"><code class="name">var <span class="ident">SetupLogging</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.SignedUninstaller"><code class="name">var <span class="ident">SignedUninstaller</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UsePreviousLanguage"><code class="name">var <span class="ident">UsePreviousLanguage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.DisableWelcomePage"><code class="name">var <span class="ident">DisableWelcomePage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.CloseApplications"><code class="name">var <span class="ident">CloseApplications</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.RestartApplications"><code class="name">var <span class="ident">RestartApplications</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AllowNetworkDrive"><code class="name">var <span class="ident">AllowNetworkDrive</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.ForceCloseApplications"><code class="name">var <span class="ident">ForceCloseApplications</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.AppNameHasConsts"><code class="name">var <span class="ident">AppNameHasConsts</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UsePreviousPrivileges"><code class="name">var <span class="ident">UsePreviousPrivileges</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.WizardResizable"><code class="name">var <span class="ident">WizardResizable</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Flags.UninstallLogging"><code class="name">var <span class="ident">UninstallLogging</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.AutoBool"><code class="flex name class">
<span>class <span class="ident">AutoBool</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L421-L428" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class AutoBool(enum.IntEnum):
    Auto = 0
    No = 1
    Yes = 2

    @classmethod
    def From(cls, b: bool):
        return AutoBool.Yes if b else AutoBool.No</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.AutoBool.Auto"><code class="name">var <span class="ident">Auto</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.AutoBool.No"><code class="name">var <span class="ident">No</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.AutoBool.Yes"><code class="name">var <span class="ident">Yes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.AutoBool.From"><code class="name flex">
<span>def <span class="ident">From</span></span>(<span>b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L426-L428" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def From(cls, b: bool):
    return AutoBool.Yes if b else AutoBool.No</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.WizardStyle"><code class="flex name class">
<span>class <span class="ident">WizardStyle</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L431-L433" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WizardStyle(enum.IntEnum):
    Classic = 0
    Modern = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.WizardStyle.Classic"><code class="name">var <span class="ident">Classic</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.WizardStyle.Modern"><code class="name">var <span class="ident">Modern</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.StoredAlphaFormat"><code class="flex name class">
<span>class <span class="ident">StoredAlphaFormat</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L436-L439" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StoredAlphaFormat(enum.IntEnum):
    AlphaIgnored = 0
    AlphaDefined = 1
    AlphaPremultiplied = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.StoredAlphaFormat.AlphaIgnored"><code class="name">var <span class="ident">AlphaIgnored</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.StoredAlphaFormat.AlphaDefined"><code class="name">var <span class="ident">AlphaDefined</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.StoredAlphaFormat.AlphaPremultiplied"><code class="name">var <span class="ident">AlphaPremultiplied</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.UninstallLogMode"><code class="flex name class">
<span>class <span class="ident">UninstallLogMode</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L442-L445" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class UninstallLogMode(enum.IntEnum):
    Append = 0
    New = 1
    Overwrite = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.UninstallLogMode.Append"><code class="name">var <span class="ident">Append</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.UninstallLogMode.New"><code class="name">var <span class="ident">New</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.UninstallLogMode.Overwrite"><code class="name">var <span class="ident">Overwrite</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupStyle"><code class="flex name class">
<span>class <span class="ident">SetupStyle</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L448-L450" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupStyle(enum.IntEnum):
    Classic = 0
    Modern = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupStyle.Classic"><code class="name">var <span class="ident">Classic</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupStyle.Modern"><code class="name">var <span class="ident">Modern</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PrivilegesRequired"><code class="flex name class">
<span>class <span class="ident">PrivilegesRequired</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L453-L457" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PrivilegesRequired(enum.IntEnum):
    Nothing = 0
    PowerUser = 1
    Admin = 2
    Lowest = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.PrivilegesRequired.Nothing"><code class="name">var <span class="ident">Nothing</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PrivilegesRequired.PowerUser"><code class="name">var <span class="ident">PowerUser</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PrivilegesRequired.Admin"><code class="name">var <span class="ident">Admin</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PrivilegesRequired.Lowest"><code class="name">var <span class="ident">Lowest</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PrivilegesRequiredOverrideAllowed"><code class="flex name class">
<span>class <span class="ident">PrivilegesRequiredOverrideAllowed</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L460-L462" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PrivilegesRequiredOverrideAllowed(enum.IntEnum):
    CommandLine = 0
    Dialog = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.PrivilegesRequiredOverrideAllowed.CommandLine"><code class="name">var <span class="ident">CommandLine</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PrivilegesRequiredOverrideAllowed.Dialog"><code class="name">var <span class="ident">Dialog</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.LanguageDetection"><code class="flex name class">
<span>class <span class="ident">LanguageDetection</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L465-L468" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LanguageDetection(enum.IntEnum):
    UI = 0
    Locale = 1
    Nothing = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.LanguageDetection.UI"><code class="name">var <span class="ident">UI</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.LanguageDetection.Locale"><code class="name">var <span class="ident">Locale</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.LanguageDetection.Nothing"><code class="name">var <span class="ident">Nothing</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CompressionMethod"><code class="flex name class">
<span>class <span class="ident">CompressionMethod</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L471-L492" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CompressionMethod(enum.IntEnum):
    Store = 0
    Flate = 1
    BZip2 = 2
    LZMA1 = 3
    LZMA2 = 4

    def legacy_check(self, max: int, ver: str):
        if self.value &gt; max:
            raise ValueError(F&#39;Compression method {self.value} cannot be represented before version {ver}.&#39;)
        return self

    def legacy_conversion_pre_4_2_5(self):
        return self.legacy_check(2, &#39;4.2.5&#39;).__class__(self.value + 1)

    def legacy_conversion_pre_4_2_6(self):
        if self == CompressionMethod.Store:
            return self
        return self.legacy_check(2, &#39;4.2.6&#39;).__class__(self.value + 1)

    def legacy_conversion_pre_5_3_9(self):
        return self.legacy_check(3, &#39;5.3.9&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.CompressionMethod.Store"><code class="name">var <span class="ident">Store</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CompressionMethod.Flate"><code class="name">var <span class="ident">Flate</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CompressionMethod.BZip2"><code class="name">var <span class="ident">BZip2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CompressionMethod.LZMA1"><code class="name">var <span class="ident">LZMA1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CompressionMethod.LZMA2"><code class="name">var <span class="ident">LZMA2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.CompressionMethod.legacy_check"><code class="name flex">
<span>def <span class="ident">legacy_check</span></span>(<span>self, max, ver)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L478-L481" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def legacy_check(self, max: int, ver: str):
    if self.value &gt; max:
        raise ValueError(F&#39;Compression method {self.value} cannot be represented before version {ver}.&#39;)
    return self</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CompressionMethod.legacy_conversion_pre_4_2_5"><code class="name flex">
<span>def <span class="ident">legacy_conversion_pre_4_2_5</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L483-L484" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def legacy_conversion_pre_4_2_5(self):
    return self.legacy_check(2, &#39;4.2.5&#39;).__class__(self.value + 1)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CompressionMethod.legacy_conversion_pre_4_2_6"><code class="name flex">
<span>def <span class="ident">legacy_conversion_pre_4_2_6</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L486-L489" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def legacy_conversion_pre_4_2_6(self):
    if self == CompressionMethod.Store:
        return self
    return self.legacy_check(2, &#39;4.2.6&#39;).__class__(self.value + 1)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CompressionMethod.legacy_conversion_pre_5_3_9"><code class="name flex">
<span>def <span class="ident">legacy_conversion_pre_5_3_9</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L491-L492" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def legacy_conversion_pre_5_3_9(self):
    return self.legacy_check(3, &#39;5.3.9&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Architecture"><code class="flex name class">
<span>class <span class="ident">Architecture</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L495-L501" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Architecture(enum.IntFlag):
    Unknown = 0b00000 # noqa
    X86     = 0b00001 # noqa
    AMD64   = 0b00010 # noqa
    IA64    = 0b00100 # noqa
    ARM64   = 0b01000 # noqa
    All     = 0b01111 # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.Architecture.Unknown"><code class="name">var <span class="ident">Unknown</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Architecture.X86"><code class="name">var <span class="ident">X86</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Architecture.AMD64"><code class="name">var <span class="ident">AMD64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Architecture.IA64"><code class="name">var <span class="ident">IA64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Architecture.ARM64"><code class="name">var <span class="ident">ARM64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Architecture.All"><code class="name">var <span class="ident">All</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PasswordType"><code class="flex name class">
<span>class <span class="ident">PasswordType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L504-L509" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PasswordType(enum.IntEnum):
    CRC32     = 0           # noqa
    Nothing   = 0           # noqa
    MD5       = enum.auto() # noqa
    SHA1      = enum.auto() # noqa
    XChaCha20 = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.PasswordType.CRC32"><code class="name">var <span class="ident">CRC32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PasswordType.Nothing"><code class="name">var <span class="ident">Nothing</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PasswordType.MD5"><code class="name">var <span class="ident">MD5</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PasswordType.SHA1"><code class="name">var <span class="ident">SHA1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.PasswordType.XChaCha20"><code class="name">var <span class="ident">XChaCha20</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTypeEnum"><code class="flex name class">
<span>class <span class="ident">SetupTypeEnum</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L512-L516" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupTypeEnum(enum.IntEnum):
    User = 0
    DefaultFull = 1
    DefaultCompact = 2
    DefaultCustom = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupTypeEnum.User"><code class="name">var <span class="ident">User</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTypeEnum.DefaultFull"><code class="name">var <span class="ident">DefaultFull</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTypeEnum.DefaultCompact"><code class="name">var <span class="ident">DefaultCompact</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTypeEnum.DefaultCustom"><code class="name">var <span class="ident">DefaultCustom</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFlags"><code class="flex name class">
<span>class <span class="ident">SetupFlags</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L519-L524" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupFlags(enum.IntFlag):
    Fixed                     = 0b00001 # noqa
    Restart                   = 0b00010 # noqa
    DisableNoUninstallWarning = 0b00100 # noqa
    Exclusive                 = 0b01000 # noqa
    DontInheritCheck          = 0b10000 # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupFlags.Fixed"><code class="name">var <span class="ident">Fixed</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFlags.Restart"><code class="name">var <span class="ident">Restart</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFlags.DisableNoUninstallWarning"><code class="name">var <span class="ident">DisableNoUninstallWarning</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFlags.Exclusive"><code class="name">var <span class="ident">Exclusive</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFlags.DontInheritCheck"><code class="name">var <span class="ident">DontInheritCheck</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.StreamCompressionMethod"><code class="flex name class">
<span>class <span class="ident">StreamCompressionMethod</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L527-L530" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StreamCompressionMethod(enum.IntEnum):
    Store = 0
    Flate = 1
    LZMA1 = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.StreamCompressionMethod.Store"><code class="name">var <span class="ident">Store</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.StreamCompressionMethod.Flate"><code class="name">var <span class="ident">Flate</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.StreamCompressionMethod.LZMA1"><code class="name">var <span class="ident">LZMA1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.StreamHeader"><code class="flex name class">
<span>class <span class="ident">StreamHeader</span></span>
<span>(</span><span>reader, name, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L533-L558" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StreamHeader(InnoStruct):
    def __init__(self, reader: StructReader[memoryview], name: str, version: InnoVersion):
        super().__init__(reader, version)
        self.Name = name
        self.HeaderCrc = reader.u32()
        self.CompressedSize = size = reader.u32()
        if version &gt;= (4, 0, 9):
            self.StoredSize = self.CompressedSize
            if not reader.u8():
                self.Compression = StreamCompressionMethod.Store
            elif version &gt;= (4, 1, 6):
                self.Compression = StreamCompressionMethod.LZMA1
            else:
                self.Compression = StreamCompressionMethod.Flate
        else:
            self.UncompresedSize = reader.u32()
            if size == 0xFFFFFFFF:
                self.StoredSize = self.UncompresedSize
                self.Compression = StreamCompressionMethod.Store
            else:
                self.StoredSize = size
                self.Compression = StreamCompressionMethod.Flate
            # Add the size of a CRC32 checksum for each 4KiB subblock
            block_count, _r = divmod(self.StoredSize, 4096)
            block_count += int(bool(_r))
            self.StoredSize += 4 * block_count</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.CrcCompressedBlock"><code class="flex name class">
<span>class <span class="ident">CrcCompressedBlock</span></span>
<span>(</span><span>reader, size)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L561-L564" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CrcCompressedBlock(JsonStruct):
    def __init__(self, reader: StructReader[memoryview], size: int):
        self.BlockCrc = reader.u32()
        self.BlockData = reader.read(size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.TSetupOffsets"><code class="flex name class">
<span>class <span class="ident">TSetupOffsets</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L567-L584" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TSetupOffsets(Struct):
    def __init__(self, reader: StructReader[memoryview]):
        self.id = reader.read(12)
        self.version = reader.u32()
        self.total_size = reader.u32()
        self.exe_offset = reader.u32()
        self.exe_uncompressed_size = reader.u32()
        self.exe_crc = reader.u32()
        self.setup0_offset = reader.u32()
        self.setup1_offset = reader.u32()
        self.offsets_crc = reader.u32()
        self.base = min(
            self.exe_offset,
            self.setup0_offset,
            self.setup1_offset,
        )
        self.setup0 = self.setup0_offset - self.base
        self.setup1 = self.setup1_offset - self.base</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile"><code class="flex name class">
<span>class <span class="ident">InnoFile</span></span>
<span>(</span><span>reader, version, meta, path='', dupe=False, setup=None, compression_method=None, password_hash=b'', password_salt=b'', password_type=PasswordType.CRC32)</span>
</code></dt>
<dd>
<section class="desc"><p>InnoFile(reader: 'StructReader[ByteStr]', version: 'InnoVersion', meta: 'SetupDataEntry', path: 'str' = '', dupe: 'bool' = False, setup: 'Optional[SetupFile]' = None, compression_method: 'Optional[CompressionMethod]' = None, password_hash: 'bytes' = b'', password_salt: 'bytes' = b'', password_type: 'PasswordType' = <PasswordType.CRC32: 0>)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L588-L667" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoFile:
    reader: StructReader[ByteStr]
    version: InnoVersion
    meta: SetupDataEntry
    path: str = &#34;&#34;
    dupe: bool = False
    setup: Optional[SetupFile] = None
    compression_method: Optional[CompressionMethod] = None
    password_hash: bytes = B&#39;&#39;
    password_salt: bytes = B&#39;&#39;
    password_type: PasswordType = PasswordType.Nothing

    @property
    def tags(self):
        if s := self.setup:
            return s.Flags
        else:
            return SetupFileFlags.Empty

    @property
    def unicode(self):
        return self.version.unicode

    @property
    def compression(self):
        if self.meta.Flags &amp; SetupDataEntryFlags.ChunkCompressed:
            return self.compression_method
        return CompressionMethod.Store

    @property
    def offset(self):
        return self.meta.Offset

    @property
    def size(self):
        return self.meta.FileSize

    @property
    def date(self):
        return self.meta.FileTime

    @property
    def chunk_offset(self):
        return self.meta.ChunkOffset

    @property
    def chunk_length(self):
        return self.meta.ChunkSize

    @property
    def checksum(self):
        return self.meta.Checksum

    @property
    def checksum_type(self):
        return self.meta.ChecksumType

    @property
    def encrypted(self):
        return bool(self.meta.Flags &amp; SetupDataEntryFlags.ChunkEncrypted)

    @property
    def filtered(self):
        return bool(self.meta.Flags &amp; SetupDataEntryFlags.CallInstructionOptimized)

    def check(self, data: ByteStr):
        t = self.checksum_type
        if t == CheckSumType.Missing:
            return None
        if t == CheckSumType.Adler32:
            return zlib.adler32(data) &amp; 0xFFFFFFFF
        if t == CheckSumType.CRC32:
            return zlib.crc32(data) &amp; 0xFFFFFFFF
        if t == CheckSumType.MD5:
            return md5(data).digest()
        if t == CheckSumType.SHA1:
            return sha1(data).digest()
        if t == CheckSumType.SHA256:
            return sha256(data).digest()
        raise ValueError(F&#39;Unknown checksum type: {t!r}&#39;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.reader"><code class="name">var <span class="ident">reader</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.meta"><code class="name">var <span class="ident">meta</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.dupe"><code class="name">var <span class="ident">dupe</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.setup"><code class="name">var <span class="ident">setup</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.compression_method"><code class="name">var <span class="ident">compression_method</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.password_hash"><code class="name">var <span class="ident">password_hash</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.password_salt"><code class="name">var <span class="ident">password_salt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.password_type"><code class="name">var <span class="ident">password_type</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.tags"><code class="name">var <span class="ident">tags</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L600-L605" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def tags(self):
    if s := self.setup:
        return s.Flags
    else:
        return SetupFileFlags.Empty</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.unicode"><code class="name">var <span class="ident">unicode</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L607-L609" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def unicode(self):
    return self.version.unicode</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.compression"><code class="name">var <span class="ident">compression</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L611-L615" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def compression(self):
    if self.meta.Flags &amp; SetupDataEntryFlags.ChunkCompressed:
        return self.compression_method
    return CompressionMethod.Store</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L617-L619" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def offset(self):
    return self.meta.Offset</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L621-L623" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def size(self):
    return self.meta.FileSize</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.date"><code class="name">var <span class="ident">date</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L625-L627" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def date(self):
    return self.meta.FileTime</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.chunk_offset"><code class="name">var <span class="ident">chunk_offset</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L629-L631" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def chunk_offset(self):
    return self.meta.ChunkOffset</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.chunk_length"><code class="name">var <span class="ident">chunk_length</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L633-L635" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def chunk_length(self):
    return self.meta.ChunkSize</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.checksum"><code class="name">var <span class="ident">checksum</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L637-L639" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def checksum(self):
    return self.meta.Checksum</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.checksum_type"><code class="name">var <span class="ident">checksum_type</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L641-L643" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def checksum_type(self):
    return self.meta.ChecksumType</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.encrypted"><code class="name">var <span class="ident">encrypted</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L645-L647" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def encrypted(self):
    return bool(self.meta.Flags &amp; SetupDataEntryFlags.ChunkEncrypted)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.filtered"><code class="name">var <span class="ident">filtered</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L649-L651" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def filtered(self):
    return bool(self.meta.Flags &amp; SetupDataEntryFlags.CallInstructionOptimized)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InnoFile.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L653-L667" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check(self, data: ByteStr):
    t = self.checksum_type
    if t == CheckSumType.Missing:
        return None
    if t == CheckSumType.Adler32:
        return zlib.adler32(data) &amp; 0xFFFFFFFF
    if t == CheckSumType.CRC32:
        return zlib.crc32(data) &amp; 0xFFFFFFFF
    if t == CheckSumType.MD5:
        return md5(data).digest()
    if t == CheckSumType.SHA1:
        return sha1(data).digest()
    if t == CheckSumType.SHA256:
        return sha256(data).digest()
    raise ValueError(F&#39;Unknown checksum type: {t!r}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoStream"><code class="flex name class">
<span>class <span class="ident">InnoStream</span></span>
<span>(</span><span>header, blocks=&lt;factory&gt;, data=None)</span>
</code></dt>
<dd>
<section class="desc"><p>InnoStream(header: 'StreamHeader', blocks: 'list[CrcCompressedBlock]' = <factory>, data: 'Optional[bytearray]' = None)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L671-L682" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoStream:
    header: StreamHeader
    blocks: list[CrcCompressedBlock] = dataclasses.field(default_factory=list)
    data: Optional[bytearray] = None

    @property
    def compression(self):
        return self.header.Compression

    @property
    def name(self):
        return self.header.Name</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InnoStream.header"><code class="name">var <span class="ident">header</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoStream.blocks"><code class="name">var <span class="ident">blocks</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoStream.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InnoStream.compression"><code class="name">var <span class="ident">compression</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L676-L678" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def compression(self):
    return self.header.Compression</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoStream.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L680-L682" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def name(self):
    return self.header.Name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InstallMode"><code class="flex name class">
<span>class <span class="ident">InstallMode</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L685-L688" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InstallMode(enum.IntEnum):
    Normal     = 0           # noqa
    Silent     = enum.auto() # noqa
    VerySilent = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InstallMode.Normal"><code class="name">var <span class="ident">Normal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InstallMode.Silent"><code class="name">var <span class="ident">Silent</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InstallMode.VerySilent"><code class="name">var <span class="ident">VerySilent</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupHeader"><code class="flex name class">
<span>class <span class="ident">SetupHeader</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L691-L1135" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupHeader(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)

        def read_string():
            return reader.read_length_prefixed()

        if version &lt; (1, 3, 0):
            # skip uncompressed size
            reader.u32()

        if True:
            self.AppName = read_string()
            self.AppVersionedName = read_string()
        if version &gt;= (1, 3, 0):
            self.AppId = read_string()
        if True:
            self.AppCopyright = read_string()
        if version &gt;= (1, 3, 0):
            self.AppPublisher = read_string()
            self.AppPublisherUrl = read_string()
        if version &gt;= (5, 1, 13):
            self.AppSupportPhone = read_string()
        if version &gt;= (1, 3, 0):
            self.AppSupportUrl = read_string()
            self.AppUpdatesUrl = read_string()
            self.AppVersion = read_string()
        if True:
            self.DefaultDirName = read_string()
            self.DefaultGroupName = read_string()
        if version &lt; (3, 0, 0):
            self.UninstallIconName = reader.read_length_prefixed(encoding=&#39;cp1252&#39;)
        if True:
            self.BaseFilename = read_string()
        if (1, 3, 0) &lt;= version &lt; (5, 2, 5):
            self._license = reader.read_length_prefixed_ascii()
            self.InfoHead = reader.read_length_prefixed_ascii()
            self.InfoTail = reader.read_length_prefixed_ascii()
        if version &gt;= (1, 3, 3):
            self.UninstallFilesDir = read_string()
        if version &gt;= (1, 3, 6):
            self.UninstallName = read_string()
            self.UninstallIcon = read_string()
        if version &gt;= (1, 3, 14):
            self.AppMutex = read_string()
        if version &gt;= (3, 0, 0):
            self.DefaultUsername = read_string()
            self.DefaultOrganisation = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 6, 1):
            self.DefaultSerial = read_string()
        if (4, 0, 0) &lt;= version &lt; (5, 2, 5) or version.isx and version &gt;= (1, 3, 24):
            self.CompiledCode = read_string()
        if version &gt;= (4, 2, 4):
            self.AppReadmeFile = read_string()
            self.AppContact = read_string()
            self.AppComment = read_string()
            self.AppModifyPath = read_string()
        if version &gt;= (5, 3, 8):
            self.CreateUninstallRegistryKey = read_string()
        if version &gt;= (5, 3, 10):
            self.Uninstallable = read_string()
        if version &gt;= (5, 5, 0):
            self.CloseApplicationsFilter = read_string()
        if version &gt;= (5, 5, 6):
            self.SetupMutex = read_string()
        if version &gt;= (5, 6, 1):
            self.ChangesEnvironment = read_string()
            self.ChangesAssociations = read_string()
        if version &gt;= (6, 3, 0):
            self.ArchitecturesAllowed32 = read_string()
            self.ArchitecturesAllowed64 = read_string()
        if version &gt;= (5, 2, 5):
            self._license = reader.read_length_prefixed_ascii()
            self.InfoHead = reader.read_length_prefixed_ascii()
            self.InfoTail = reader.read_length_prefixed_ascii()
        if version &gt;= (5, 2, 1) and version &lt; (5, 3, 10):
            self.UninstallerSignature = read_string()
        if version &gt;= (5, 2, 5):
            self.CompiledCode = read_string()

        if self.CompiledCode and self.CompiledCode[:4] != B&#39;IFPS&#39;:
            raise ValueError(&#39;Invalid signature in compiled code.&#39;)

        if version &gt;= (2, 0, 6) and version.ascii:
            self.Charset = reader.read_integer(0x100)
        else:
            self.Charset = [False] * 0x100

        if version &gt;= (4, 0, 0):
            self.LanguageCount = reader.u32()
        elif version &gt;= (2, 0, 1):
            self.LanguageCount = 1
        else:
            self.LanguageCount = 0

        if version &gt;= (4, 2, 1):
            self.MessageCount = reader.u32()
        else:
            self.MessageCount = 0

        if version &gt;= (4, 1, 0):
            self.PermissionCount = reader.u32()
        else:
            self.PermissionCount = 0

        if version &gt;= (2, 0, 0) or version.isx:
            self.TypeCount = reader.u32()
            self.ComponentCount = reader.u32()
        else:
            self.TypeCount = 0
            self.ComponentCount = 0

        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 17):
            self.TaskCount = reader.u32()
        else:
            self.TaskCount = 0

        self.DirectoryCount = reader.u32()
        self.FileCount = reader.u32()
        self.DataEntryCount = reader.u32()
        self.IconCount = reader.u32()
        self.IniEntryCount = reader.u32()
        self.RegistryCount = reader.u32()
        self.DeleteCount = reader.u32()
        self.UninstallDeleteCount = reader.u32()
        self.RunCount = reader.u32()
        self.UninstallRunCount = reader.u32()

        if version &lt; (1, 3, 0):
            _license_len = reader.u32()
            _infhead_len = reader.u32()
            _inftail_len = reader.u32()

        self.WindowsVersion = WinVerRange(reader, version)

        self.BackColor1 = reader.u32() if (0, 0, 0) &lt;= version &lt; (6, 4, 0, 1) else 0
        self.BackColor2 = reader.u32() if (1, 3, 3) &lt;= version &lt; (6, 4, 0, 1) else 0

        if version &lt; (5, 5, 7):
            self.ImageBackColor = reader.u32()
        if (2, 0, 0) &lt;= version &lt; (5, 0, 4) or version.isx:
            self.SmallImageBackColor = reader.u32()
        if version &gt;= (6, 0, 0):
            self.WizardStyle = WizardStyle(reader.u8())
            self.WizardResizePercentX = reader.u32()
            self.WizardResizePercentY = reader.u32()
        else:
            self.WizardStyle = WizardStyle.Classic
            self.WizardResizePercentX = 0
            self.WizardResizePercentY = 0

        if version &gt;= (5, 5, 7):
            self.StoredAlphaFormat = StoredAlphaFormat(reader.u8())
        else:
            self.StoredAlphaFormat = StoredAlphaFormat.AlphaIgnored

        if version &gt;= (6, 4, 0):
            self.PasswordType = PasswordType.XChaCha20
            self.PasswordHash = reader.read(4)
        elif version &gt;= (5, 3, 9):
            self.PasswordType = PasswordType.SHA1
            self.PasswordHash = reader.read(20)
        elif version &gt;= (4, 2, 0):
            self.PasswordType = PasswordType.MD5
            self.PasswordHash = reader.read(16)
        else:
            self.PasswordType = PasswordType.CRC32
            self.PasswordHash = reader.u32()

        if version &gt;= (6, 4, 0):
            self.PasswordSalt = reader.read(44)
        elif version &gt;= (4, 2, 2):
            self.PasswordSalt = reader.read(8)
        else:
            self.PasswordSalt = None

        if version &gt;= (4, 0, 0):
            self.ExtraDiskSpace = reader.i64()
            self.SlicesPerDisk = reader.u32()
        else:
            self.ExtraDiskSpace = reader.u32()
            self.SlicesPerDisk = 1

        if (2, 0, 0) &lt;= version &lt; (5, 0, 0):
            self.InstallMode = _enum(InstallMode, reader.u8(), InstallMode.Normal)
        else:
            self.InstallMode = InstallMode.Normal
        if version &gt;= (1, 3, 0):
            self.UninstallLogMode = UninstallLogMode(reader.u8())
        else:
            self.UninstallLogMode = UninstallLogMode.New

        if version &gt;= (5, 0, 0):
            self.SetupStyle = SetupStyle.Modern
        elif (2, 0, 0) &lt;= version or version.isx and version &gt;= (1, 3, 13):
            self.SetupStyle = SetupStyle(reader.u8())
        else:
            self.SetupStyle = SetupStyle.Classic

        if version &gt;= (1, 3, 6):
            self.DirExistsWarning = AutoBool(reader.u8())
        else:
            self.DirExistsWarning = AutoBool.Auto
        if version.isx and (2, 0, 10) &lt;= version &lt; (3, 0, 0):
            self.CodeLineOffset = reader.u32()

        self.Flags = Flags.Empty

        if (3, 0, 0) &lt;= version &lt; (3, 0, 3):
            val = AutoBool(reader.u8())
            if val == AutoBool.Auto:
                self.Flags |= Flags.RestartIfNeededByRun
            elif val == AutoBool.Yes:
                self.Flags |= Flags.AlwaysRestart

        if version &gt;= (3, 0, 4) or version.isx and version &gt;= (3, 0, 3):
            self.PrivilegesRequired = PrivilegesRequired(reader.u8())
        if version &gt;= (5, 7, 0):
            self.PrivilegesRequiredOverrideAllowed = PrivilegesRequiredOverrideAllowed(reader.u8())
        if version &gt;= (4, 0, 10):
            self.ShowLanguageDialog = AutoBool(reader.u8())
            self.LanguageDetection = LanguageDetection(reader.u8())

        if version &gt;= (4, 1, 5):
            method = CompressionMethod(reader.u8())
            if version &lt; (4, 2, 5):
                method = method.legacy_conversion_pre_4_2_5()
            elif version &lt; (4, 2, 6):
                method = method.legacy_conversion_pre_4_2_5()
            elif version &lt; (5, 3, 9):
                method = method.legacy_conversion_pre_5_3_9()
            self.CompressionMethod = method

        if version &gt;= (6, 3, 0):
            self.ArchitecturesAllowed = Architecture.Unknown
            self.ArchitecturesInstalled64 = Architecture.Unknown
        elif version &gt;= (5, 1, 0):
            self.ArchitecturesAllowed = Architecture(reader.u8())
            self.ArchitecturesInstalled64 = Architecture(reader.u8())
        else:
            self.ArchitecturesAllowed = Architecture.All
            self.ArchitecturesInstalled64 = Architecture.All

        if (5, 2, 1) &lt;= version &lt; (5, 3, 10):
            self.UninstallerOriginalSize = reader.u32()
            self.UninstallheaderCrc = reader.u32()
        if version &gt;= (5, 3, 3):
            self.DisableDirPage = AutoBool(reader.u8())
            self.DisableProgramGroupPage = AutoBool(reader.u8())
        if version &gt;= (5, 5, 0):
            self.UninstallDisplaySize = reader.u64()
        elif version &gt;= (5, 3, 6):
            self.UninstallDisplaySize = reader.u32()
        else:
            self.UninstallDisplaySize = 0

        flags = []
        flags.append(Flags.DisableStartupPrompt)
        if version &lt; (5, 3, 10):
            flags.append(Flags.Uninstallable)
        flags.append(Flags.CreateAppDir)
        if version &lt; (5, 3, 3):
            flags.append(Flags.DisableDirPage)
        if version &lt; (1, 3, 6):
            flags.append(Flags.DisableDirExistsWarning)
        if version &lt; (5, 3, 3):
            flags.append(Flags.DisableProgramGroupPage)
        flags.append(Flags.AllowNoIcons)
        if version &lt; (3, 0, 0) or version &gt;= (3, 0, 3):
            flags.append(Flags.AlwaysRestart)
        if version &lt; (1, 3, 3):
            flags.append(Flags.BackSolid)
        flags.append(Flags.AlwaysUsePersonalGroup)
        flags.append(Flags.WindowVisible)
        flags.append(Flags.WindowShowCaption)
        flags.append(Flags.WindowResizable)
        flags.append(Flags.WindowStartMaximized)
        flags.append(Flags.EnableDirDoesntExistWarning)
        if version &lt; (4, 1, 2):
            flags.append(Flags.DisableAppendDir)
        flags.append(Flags.Password)
        flags.append(Flags.AllowRootDirectory)
        flags.append(Flags.DisableFinishedPage)

        if version.bits &gt; 16:
            if version &lt; (3, 0, 4):
                flags.append(Flags.AdminPrivilegesRequired)
            if version &lt; (3, 0, 0):
                flags.append(Flags.AlwaysCreateUninstallIcon)
            if version &lt; (1, 3, 6):
                flags.append(Flags.OverwriteUninstRegEntries)
            if version &lt; (5, 6, 1):
                flags.append(Flags.ChangesAssociations)

        if version &lt; (5, 3, 8):
            flags.append(Flags.CreateUninstallRegKey)

        flags.append(Flags.UsePreviousAppDir)
        flags.append(Flags.BackColorHorizontal)
        flags.append(Flags.UsePreviousGroup)
        flags.append(Flags.UpdateUninstallLogAppName)
        flags.append(Flags.UsePreviousSetupType)
        flags.append(Flags.DisableReadyMemo)
        flags.append(Flags.AlwaysShowComponentsList)
        flags.append(Flags.FlatComponentsList)
        flags.append(Flags.ShowComponentSizes)
        flags.append(Flags.UsePreviousTasks)
        flags.append(Flags.DisableReadyPage)
        flags.append(Flags.AlwaysShowDirOnReadyPage)
        flags.append(Flags.AlwaysShowGroupOnReadyPage)
        if version &lt; (4, 1, 5):
            flags.append(Flags.BzipUsed)
        flags.append(Flags.AllowUNCPath)
        flags.append(Flags.UserInfoPage)
        flags.append(Flags.UsePreviousUserInfo)
        flags.append(Flags.UninstallRestartComputer)
        flags.append(Flags.RestartIfNeededByRun)
        flags.append(Flags.ShowTasksTreeLines)
        if version &lt; (4, 0, 10):
            flags.append(Flags.ShowLanguageDialog)
        if version &gt;= (4, 0, 1) and version &lt; (4, 0, 10):
            flags.append(Flags.DetectLanguageUsingLocale)
        if version &gt;= (4, 0, 9):
            flags.append(Flags.AllowCancelDuringInstall)
        if version &gt;= (4, 1, 3):
            flags.append(Flags.WizardImageStretch)
        if version &gt;= (4, 1, 8):
            flags.append(Flags.AppendDefaultDirName)
            flags.append(Flags.AppendDefaultGroupName)
        if version &gt;= (4, 2, 2):
            flags.append(Flags.EncryptionUsed)
        if version &gt;= (5, 0, 4) and version &lt; (5, 6, 1):
            flags.append(Flags.ChangesEnvironment)
        if version &gt;= (5, 1, 7) and version.ascii:
            flags.append(Flags.ShowUndisplayableLanguages)
        if version &gt;= (5, 1, 13):
            flags.append(Flags.SetupLogging)
        if version &gt;= (5, 2, 1):
            flags.append(Flags.SignedUninstaller)
        if version &gt;= (5, 3, 8):
            flags.append(Flags.UsePreviousLanguage)
        if version &gt;= (5, 3, 9):
            flags.append(Flags.DisableWelcomePage)
        if version &gt;= (5, 5, 0):
            flags.append(Flags.CloseApplications)
            flags.append(Flags.RestartApplications)
            flags.append(Flags.AllowNetworkDrive)
        if version &gt;= (5, 5, 7):
            flags.append(Flags.ForceCloseApplications)
        if version &gt;= (6, 0, 0):
            flags.append(Flags.AppNameHasConsts)
            flags.append(Flags.UsePreviousPrivileges)
            flags.append(Flags.WizardResizable)
        if version &gt;= (6, 3, 0):
            flags.append(Flags.UninstallLogging)

        flagsize, _r = divmod(len(flags), 8)
        flagsize += int(bool(_r))
        bytecheck = bytes(reader.peek(flagsize + 1 + 4 + 1))

        if bytecheck[0] == 0:
            if bytecheck[~0] != 0 or bytecheck[~3:~0] == B&#39;\0\0\0&#39;:
                reader.u8()

        for flag in flags:
            if reader.read_bit():
                self.Flags |= flag

        if version &lt; (3, 0, 4):
            self.PrivilegesRequired = PrivilegesRequired.Admin if (
                self.Flags &amp; Flags.AdminPrivilegesRequired
            ) else PrivilegesRequired.Nothing

        if version &lt; (4, 0, 10):
            self.ShowLanguageDialog = AutoBool.From(
                self.Flags &amp; Flags.ShowLanguageDialog)
            self.LanguageDetection = LanguageDetection.Locale if (
                self.Flags &amp; Flags.DetectLanguageUsingLocale
            ) else LanguageDetection.UI

        if version &lt; (4, 1, 5):
            self.CompressionMethod = CompressionMethod.BZip2 if (
                self.Flags &amp; Flags.BzipUsed
            ) else CompressionMethod.Flate

        if version &lt; (5, 3, 3):
            self.DisableDirPage = AutoBool.From(self.Flags &amp; Flags.DisableDirPage)
            self.DisableProgramGroupPage = AutoBool.From(self.Flags &amp; Flags.DisableProgramGroupPage)

        if version &lt; (1, 3, 0):
            def _read_ascii(n: int):
                return codecs.decode(reader.read(_license_len), &#39;cp1252&#39;)
            self._license = _read_ascii(_license_len)
            self.InfoHead = _read_ascii(_infhead_len)
            self.InfoTail = _read_ascii(_inftail_len)

        reader.byte_align()

        if flagsize == 3:
            reader.u8()

    def get_license(self):
        return self._license

    def recode_strings(self, codec: str):
        for coded_string_attribute in [
            &#39;AppComment&#39;,
            &#39;AppContact&#39;,
            &#39;AppCopyright&#39;,
            &#39;AppId&#39;,
            &#39;AppModifyPath&#39;,
            &#39;AppMutex&#39;,
            &#39;AppName&#39;,
            &#39;AppPublisher&#39;,
            &#39;AppPublisherUrl&#39;,
            &#39;AppReadmeFile&#39;,
            &#39;AppSupportPhone&#39;,
            &#39;AppSupportUrl&#39;,
            &#39;AppUpdatesUrl&#39;,
            &#39;AppVersion&#39;,
            &#39;AppVersionedName&#39;,
            &#39;BaseFilename&#39;,
            &#39;ChangesAssociations&#39;,
            &#39;ChangesEnvironment&#39;,
            &#39;CloseApplicationsFilter&#39;,
            &#39;CreateUninstallRegistryKey&#39;,
            &#39;DefaultDirName&#39;,
            &#39;DefaultGroupName&#39;,
            &#39;DefaultOrganisation&#39;,
            &#39;DefaultSerial&#39;,
            &#39;DefaultUsername&#39;,
            &#39;SetupMutex&#39;,
            &#39;Uninstallable&#39;,
            &#39;UninstallFilesDir&#39;,
            &#39;UninstallIcon&#39;,
            &#39;UninstallName&#39;,
        ]:
            try:
                value: bytes = getattr(self, coded_string_attribute)
            except AttributeError:
                continue
            if not isinstance(value, (bytes, bytearray, memoryview)):
                raise RuntimeError(F&#39;Attempting to decode {coded_string_attribute} which was already decoded.&#39;)
            setattr(self, coded_string_attribute, codecs.decode(value, codec))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupHeader.get_license"><code class="name flex">
<span>def <span class="ident">get_license</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1093-L1094" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_license(self):
    return self._license</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupHeader.recode_strings"><code class="name flex">
<span>def <span class="ident">recode_strings</span></span>(<span>self, codec)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1096-L1135" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def recode_strings(self, codec: str):
    for coded_string_attribute in [
        &#39;AppComment&#39;,
        &#39;AppContact&#39;,
        &#39;AppCopyright&#39;,
        &#39;AppId&#39;,
        &#39;AppModifyPath&#39;,
        &#39;AppMutex&#39;,
        &#39;AppName&#39;,
        &#39;AppPublisher&#39;,
        &#39;AppPublisherUrl&#39;,
        &#39;AppReadmeFile&#39;,
        &#39;AppSupportPhone&#39;,
        &#39;AppSupportUrl&#39;,
        &#39;AppUpdatesUrl&#39;,
        &#39;AppVersion&#39;,
        &#39;AppVersionedName&#39;,
        &#39;BaseFilename&#39;,
        &#39;ChangesAssociations&#39;,
        &#39;ChangesEnvironment&#39;,
        &#39;CloseApplicationsFilter&#39;,
        &#39;CreateUninstallRegistryKey&#39;,
        &#39;DefaultDirName&#39;,
        &#39;DefaultGroupName&#39;,
        &#39;DefaultOrganisation&#39;,
        &#39;DefaultSerial&#39;,
        &#39;DefaultUsername&#39;,
        &#39;SetupMutex&#39;,
        &#39;Uninstallable&#39;,
        &#39;UninstallFilesDir&#39;,
        &#39;UninstallIcon&#39;,
        &#39;UninstallName&#39;,
    ]:
        try:
            value: bytes = getattr(self, coded_string_attribute)
        except AttributeError:
            continue
        if not isinstance(value, (bytes, bytearray, memoryview)):
            raise RuntimeError(F&#39;Attempting to decode {coded_string_attribute} which was already decoded.&#39;)
        setattr(self, coded_string_attribute, codecs.decode(value, codec))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.Version"><code class="flex name class">
<span>class <span class="ident">Version</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1138-L1144" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Version(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Build = reader.u16() if version &gt;= (1, 3, 19) else 0
        self.Minor = reader.u8()
        self.Major = reader.u8()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.WindowsVersion"><code class="flex name class">
<span>class <span class="ident">WindowsVersion</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1147-L1156" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WindowsVersion(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.OS = Version(reader, version)
        self.NT = Version(reader, version)
        (
            self.ServicePackMinor,
            self.ServicePackMajor,
        ) = reader.read_struct(&#39;BB&#39;) if version &gt;= (1, 3, 19) else (0, 0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.WinVerRange"><code class="flex name class">
<span>class <span class="ident">WinVerRange</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1159-L1164" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WinVerRange(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Min = WindowsVersion(reader, version)
        self.Max = WindowsVersion(reader, version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.LanguageId"><code class="flex name class">
<span>class <span class="ident">LanguageId</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1167-L1170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LanguageId(JsonStruct):
    def __init__(self, reader: StructReader[memoryview]):
        self.Value = reader.i32()
        self.Name = LCID.get(self.Value, None)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupLanguage"><code class="flex name class">
<span>class <span class="ident">SetupLanguage</span></span>
<span>(</span><span>reader, version, _)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1173-L1220" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupLanguage(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, _: TSetup):
        super().__init__(reader, version)
        read_string = self._read_string

        self.Name = read_string()
        LanguageName = reader.read_length_prefixed()

        self.DialogFont = read_string()
        self.TitleFont = read_string()
        self.WelcomeFont = read_string()
        self.CopyrightFont = read_string()
        self.Data = reader.read_length_prefixed()

        if version &gt;= (4, 0, 1):
            self.LicenseText = reader.read_length_prefixed_ascii()
            self.InfoBefore = reader.read_length_prefixed_ascii()
            self.InfoAfter = reader.read_length_prefixed_ascii()

        self.LanguageId = LanguageId(reader)

        if version &lt; (4, 2, 2):
            self.Codepage = DEFAULT_CODEPAGE.get(self.LanguageId.Value, &#39;cp1252&#39;)
        elif version.ascii:
            cp = reader.u32() or 1252
            self.Codepage = F&#39;cp{cp}&#39;
        else:
            if version &lt; (5, 3, 0):
                reader.u32()
            self.Codepage = &#39;utf-16le&#39;

        if version &gt;= (4, 2, 2):
            self.LanguageName = codecs.decode(LanguageName, &#39;utf-16le&#39;)
        else:
            self.LanguageName = codecs.decode(LanguageName, self.Codepage)

        self.DialogFontSize = reader.u32()

        if version &lt; (4, 1, 0):
            self.DialogFontStandardHeight = reader.u32()

        self.TitleFontSize = reader.u32()
        self.WelcomeFontSize = reader.u32()
        self.CopyrightFontSize = reader.u32()

        if version &gt;= (5, 2, 3):
            self.RightToLeft = reader.u8()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupMessage"><code class="flex name class">
<span>class <span class="ident">SetupMessage</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1223-L1238" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupMessage(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        self.EncodedName = self._read_string()
        value = reader.read_length_prefixed()
        language = reader.i32()
        try:
            codec = parent.Languages[language].Codepage
        except IndexError:
            pass
        try:
            self.Value = codecs.decode(value, codec)
        except LookupError:
            # TODO: This is a fallback
            self.Value = codecs.decode(value, &#39;latin1&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupType"><code class="flex name class">
<span>class <span class="ident">SetupType</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1241-L1261" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupType(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        self.Name = read_string()
        self.Description = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        self.WindowsVersion = WinVerRange(reader, version)
        self.CustsomTypeCode = reader.u8()
        if version &gt;= (4, 0, 3):
            self.SetupType = SetupTypeEnum(reader.u8())
        else:
            self.SetupType = SetupTypeEnum.User
        if version &gt;= (4, 0, 0):
            self.Size = reader.u64()
        else:
            self.Size = reader.u32()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupComponent"><code class="flex name class">
<span>class <span class="ident">SetupComponent</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1264-L1292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupComponent(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        self.Name = read_string()
        self.Description = read_string()
        self.Types = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        if version &gt;= (4, 0, 0):
            self.ExtraDiskSpace = reader.u64()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 3):
            self.Level = reader.u32()
        else:
            self.Level = 0
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 4):
            self.Used = bool(reader.u8())
        else:
            self.Used = True
        if True:
            self.WindowsVersion = WinVerRange(reader, version)
            self.Flags = SetupFlags(reader.u8())
        if version &gt;= (4, 0, 0):
            self.Size = reader.u64()
        elif version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Size = reader.u32()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTaskFlags"><code class="flex name class">
<span>class <span class="ident">SetupTaskFlags</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1295-L1301" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupTaskFlags(enum.IntFlag):
    Empty            = 0           # noqa
    Exclusive        = enum.auto() # noqa
    Unchecked        = enum.auto() # noqa
    Restart          = enum.auto() # noqa
    CheckedOne       = enum.auto() # noqa
    DontInheritCheck = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupTaskFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTaskFlags.Exclusive"><code class="name">var <span class="ident">Exclusive</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTaskFlags.Unchecked"><code class="name">var <span class="ident">Unchecked</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTaskFlags.Restart"><code class="name">var <span class="ident">Restart</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTaskFlags.CheckedOne"><code class="name">var <span class="ident">CheckedOne</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTaskFlags.DontInheritCheck"><code class="name">var <span class="ident">DontInheritCheck</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupTask"><code class="flex name class">
<span>class <span class="ident">SetupTask</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1304-L1345" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupTask(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        self.Name = read_string()
        self.Description = read_string()
        self.GroupDescription = read_string()
        self.Components = read_string()

        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 3):
            self.Level = reader.u32()
        else:
            self.Level = 0
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 4):
            self.Used = bool(reader.u8())
        else:
            self.Used = True
        if True:
            self.WindowsVersion = WinVerRange(reader, version)

        self.Flags = SetupTaskFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if True:
            flagbit(SetupTaskFlags.Exclusive)
            flagbit(SetupTaskFlags.Unchecked)
        if version &gt;= (2, 0, 5):
            flagbit(SetupTaskFlags.Restart)
        if version &gt;= (2, 0, 6):
            flagbit(SetupTaskFlags.CheckedOne)
        if version &gt;= (4, 2, 3):
            flagbit(SetupTaskFlags.DontInheritCheck)

        reader.byte_align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupCondition"><code class="flex name class">
<span>class <span class="ident">SetupCondition</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1348-L1365" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupCondition(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 8):
            self.Components = read_string()
        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 17):
            self.Tasks = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        else:
            self.Check = None
        if version &gt;= (4, 1, 0):
            self.AfterInstall = read_string()
            self.BeforeInstall = read_string()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDirectoryFlags"><code class="flex name class">
<span>class <span class="ident">SetupDirectoryFlags</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1368-L1374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDirectoryFlags(enum.IntFlag):
    Empty                = 0           # noqa
    NeverUninstall       = enum.auto() # noqa
    DeleteAfterInstall   = enum.auto() # noqa
    AlwaysUninstall      = enum.auto() # noqa
    SetNtfsCompression   = enum.auto() # noqa
    UnsetNtfsCompression = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupDirectoryFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDirectoryFlags.NeverUninstall"><code class="name">var <span class="ident">NeverUninstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDirectoryFlags.DeleteAfterInstall"><code class="name">var <span class="ident">DeleteAfterInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDirectoryFlags.AlwaysUninstall"><code class="name">var <span class="ident">AlwaysUninstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDirectoryFlags.SetNtfsCompression"><code class="name">var <span class="ident">SetNtfsCompression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDirectoryFlags.UnsetNtfsCompression"><code class="name">var <span class="ident">UnsetNtfsCompression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDirectory"><code class="flex name class">
<span>class <span class="ident">SetupDirectory</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1377-L1408" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDirectory(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        if version &lt; (1, 3, 0):
            self.UncompressedSize = reader.u32()
        if True:
            self.Name = read_string()
            self.Condition = SetupCondition(reader, version, parent)

        if (4, 0, 11) &lt;= version &lt; (4, 1, 0):
            self.Permissions = read_string()
        if version &gt;= (2, 0, 11):
            self.Attributes = reader.u32()

        self.WindowsVersion = WinVerRange(reader, version)

        if version &gt;= (4, 1, 0):
            self.Permissions = reader.u16()

        self.Flags = SetupDirectoryFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0
        flagbit(SetupDirectoryFlags.NeverUninstall)
        flagbit(SetupDirectoryFlags.DeleteAfterInstall)
        flagbit(SetupDirectoryFlags.AlwaysUninstall)
        flagbit(SetupDirectoryFlags.SetNtfsCompression)
        flagbit(SetupDirectoryFlags.UnsetNtfsCompression)
        reader.byte_align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupPermission"><code class="flex name class">
<span>class <span class="ident">SetupPermission</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1411-L1415" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupPermission(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        self.Permission = reader.read_length_prefixed()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags"><code class="flex name class">
<span>class <span class="ident">SetupFileFlags</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1418-L1452" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupFileFlags(enum.IntFlag):
    Empty                              = 0           # noqa
    ConfirmOverwrite                   = enum.auto() # noqa
    NeverUninstall                     = enum.auto() # noqa
    RestartReplace                     = enum.auto() # noqa
    DeleteAfterInstall                 = enum.auto() # noqa
    RegisterServer                     = enum.auto() # noqa
    RegisterTypeLib                    = enum.auto() # noqa
    SharedFile                         = enum.auto() # noqa
    IsReadmeFile                       = enum.auto() # noqa
    CompareTimeStamp                   = enum.auto() # noqa
    FontIsNotTrueType                  = enum.auto() # noqa
    SkipIfSourceDoesntExist            = enum.auto() # noqa
    OverwriteReadOnly                  = enum.auto() # noqa
    OverwriteSameVersion               = enum.auto() # noqa
    CustomDestName                     = enum.auto() # noqa
    OnlyIfDestFileExists               = enum.auto() # noqa
    NoRegError                         = enum.auto() # noqa
    UninsRestartDelete                 = enum.auto() # noqa
    OnlyIfDoesntExist                  = enum.auto() # noqa
    IgnoreVersion                      = enum.auto() # noqa
    PromptIfOlder                      = enum.auto() # noqa
    DontCopy                           = enum.auto() # noqa
    UninsRemoveReadOnly                = enum.auto() # noqa
    RecurseSubDirsExternal             = enum.auto() # noqa
    ReplaceSameVersionIfContentsDiffer = enum.auto() # noqa
    DontVerifyChecksum                 = enum.auto() # noqa
    UninsNoSharedFilePrompt            = enum.auto() # noqa
    CreateAllSubDirs                   = enum.auto() # noqa
    Bits32                             = enum.auto() # noqa
    Bits64                             = enum.auto() # noqa
    ExternalSizePreset                 = enum.auto() # noqa
    SetNtfsCompression                 = enum.auto() # noqa
    UnsetNtfsCompression               = enum.auto() # noqa
    GacInstall                         = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.ConfirmOverwrite"><code class="name">var <span class="ident">ConfirmOverwrite</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.NeverUninstall"><code class="name">var <span class="ident">NeverUninstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.RestartReplace"><code class="name">var <span class="ident">RestartReplace</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.DeleteAfterInstall"><code class="name">var <span class="ident">DeleteAfterInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.RegisterServer"><code class="name">var <span class="ident">RegisterServer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.RegisterTypeLib"><code class="name">var <span class="ident">RegisterTypeLib</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.SharedFile"><code class="name">var <span class="ident">SharedFile</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.IsReadmeFile"><code class="name">var <span class="ident">IsReadmeFile</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.CompareTimeStamp"><code class="name">var <span class="ident">CompareTimeStamp</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.FontIsNotTrueType"><code class="name">var <span class="ident">FontIsNotTrueType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.SkipIfSourceDoesntExist"><code class="name">var <span class="ident">SkipIfSourceDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.OverwriteReadOnly"><code class="name">var <span class="ident">OverwriteReadOnly</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.OverwriteSameVersion"><code class="name">var <span class="ident">OverwriteSameVersion</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.CustomDestName"><code class="name">var <span class="ident">CustomDestName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.OnlyIfDestFileExists"><code class="name">var <span class="ident">OnlyIfDestFileExists</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.NoRegError"><code class="name">var <span class="ident">NoRegError</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.UninsRestartDelete"><code class="name">var <span class="ident">UninsRestartDelete</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.OnlyIfDoesntExist"><code class="name">var <span class="ident">OnlyIfDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.IgnoreVersion"><code class="name">var <span class="ident">IgnoreVersion</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.PromptIfOlder"><code class="name">var <span class="ident">PromptIfOlder</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.DontCopy"><code class="name">var <span class="ident">DontCopy</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.UninsRemoveReadOnly"><code class="name">var <span class="ident">UninsRemoveReadOnly</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.RecurseSubDirsExternal"><code class="name">var <span class="ident">RecurseSubDirsExternal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.ReplaceSameVersionIfContentsDiffer"><code class="name">var <span class="ident">ReplaceSameVersionIfContentsDiffer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.DontVerifyChecksum"><code class="name">var <span class="ident">DontVerifyChecksum</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.UninsNoSharedFilePrompt"><code class="name">var <span class="ident">UninsNoSharedFilePrompt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.CreateAllSubDirs"><code class="name">var <span class="ident">CreateAllSubDirs</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.Bits32"><code class="name">var <span class="ident">Bits32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.Bits64"><code class="name">var <span class="ident">Bits64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.ExternalSizePreset"><code class="name">var <span class="ident">ExternalSizePreset</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.SetNtfsCompression"><code class="name">var <span class="ident">SetNtfsCompression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.UnsetNtfsCompression"><code class="name">var <span class="ident">UnsetNtfsCompression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileFlags.GacInstall"><code class="name">var <span class="ident">GacInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileType"><code class="flex name class">
<span>class <span class="ident">SetupFileType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1455-L1458" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupFileType(enum.IntEnum):
    UserFile = 0
    UninstExe = 1
    RegSvrExe = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupFileType.UserFile"><code class="name">var <span class="ident">UserFile</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileType.UninstExe"><code class="name">var <span class="ident">UninstExe</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileType.RegSvrExe"><code class="name">var <span class="ident">RegSvrExe</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileCopyMode"><code class="flex name class">
<span>class <span class="ident">SetupFileCopyMode</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1461-L1465" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupFileCopyMode(enum.IntEnum):
    Normal                  = 0           # noqa
    IfDoesntExist           = enum.auto() # noqa
    AlwaysOverwrite         = enum.auto() # noqa
    AlwaysSkipIfSameOrOlder = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupFileCopyMode.Normal"><code class="name">var <span class="ident">Normal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileCopyMode.IfDoesntExist"><code class="name">var <span class="ident">IfDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileCopyMode.AlwaysOverwrite"><code class="name">var <span class="ident">AlwaysOverwrite</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFileCopyMode.AlwaysSkipIfSameOrOlder"><code class="name">var <span class="ident">AlwaysSkipIfSameOrOlder</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupFile"><code class="flex name class">
<span>class <span class="ident">SetupFile</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1468-L1571" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupFile(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        if version &lt; (1, 3, 0):
            self.UncompressedSize = reader.u32()
        if True:
            self.Source = read_string()
            self.Destination = read_string()
            self.InstallFontName = read_string()
        if version &gt;= (5, 2, 5):
            self.StrongAssemblyName = read_string()

        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)

        self.Location = reader.u32()
        self.Attributes = reader.u32()
        self.ExternalSize = reader.u64() if version &gt;= (4, 0, 0) else reader.u32()

        self.Flags = SetupFileFlags.Empty

        if version &lt; (3, 0, 5):
            copy = _enum(SetupFileCopyMode, reader.u8(), SetupFileCopyMode.Normal)
            if copy == SetupFileCopyMode.AlwaysSkipIfSameOrOlder:
                pass
            elif copy == SetupFileCopyMode.Normal:
                self.Flags |= SetupFileFlags.PromptIfOlder
            elif copy == SetupFileCopyMode.IfDoesntExist:
                self.Flags |= SetupFileFlags.OnlyIfDoesntExist | SetupFileFlags.PromptIfOlder
            elif copy == SetupFileCopyMode.AlwaysOverwrite:
                self.Flags |= SetupFileFlags.IgnoreVersion | SetupFileFlags.PromptIfOlder

        if version &gt;= (4, 1, 0):
            self.Permissions = reader.u16()

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        flagstart = reader.tell()

        if True:
            flagbit(SetupFileFlags.ConfirmOverwrite)
            flagbit(SetupFileFlags.NeverUninstall)
            flagbit(SetupFileFlags.RestartReplace)
            flagbit(SetupFileFlags.DeleteAfterInstall)
        if version.bits &gt; 16:
            flagbit(SetupFileFlags.RegisterServer)
            flagbit(SetupFileFlags.RegisterTypeLib)
            flagbit(SetupFileFlags.SharedFile)
        if version &lt; (2, 0, 0) and not version.isx:
            flagbit(SetupFileFlags.IsReadmeFile)
        if True:
            flagbit(SetupFileFlags.CompareTimeStamp)
            flagbit(SetupFileFlags.FontIsNotTrueType)
        if version &gt;= (1, 2, 5):
            flagbit(SetupFileFlags.SkipIfSourceDoesntExist)
        if version &gt;= (1, 2, 6):
            flagbit(SetupFileFlags.OverwriteReadOnly)
        if version &gt;= (1, 3, 21):
            flagbit(SetupFileFlags.OverwriteSameVersion)
            flagbit(SetupFileFlags.CustomDestName)
        if version &gt;= (1, 3, 25):
            flagbit(SetupFileFlags.OnlyIfDestFileExists)
        if version &gt;= (2, 0, 5):
            flagbit(SetupFileFlags.NoRegError)
        if version &gt;= (3, 0, 1):
            flagbit(SetupFileFlags.UninsRestartDelete)
        if version &gt;= (3, 0, 5):
            flagbit(SetupFileFlags.OnlyIfDoesntExist)
            flagbit(SetupFileFlags.IgnoreVersion)
            flagbit(SetupFileFlags.PromptIfOlder)
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 6, 1):
            flagbit(SetupFileFlags.DontCopy)
        if version &gt;= (4, 0, 5):
            flagbit(SetupFileFlags.UninsRemoveReadOnly)
        if version &gt;= (4, 1, 8):
            flagbit(SetupFileFlags.RecurseSubDirsExternal)
        if version &gt;= (4, 2, 1):
            flagbit(SetupFileFlags.ReplaceSameVersionIfContentsDiffer)
        if version &gt;= (4, 2, 5):
            flagbit(SetupFileFlags.DontVerifyChecksum)
        if version &gt;= (5, 0, 3):
            flagbit(SetupFileFlags.UninsNoSharedFilePrompt)
        if version &gt;= (5, 1, 0):
            flagbit(SetupFileFlags.CreateAllSubDirs)
        if version &gt;= (5, 1, 2):
            flagbit(SetupFileFlags.Bits32)
            flagbit(SetupFileFlags.Bits64)
        if version &gt;= (5, 2, 0):
            flagbit(SetupFileFlags.ExternalSizePreset)
            flagbit(SetupFileFlags.SetNtfsCompression)
            flagbit(SetupFileFlags.UnsetNtfsCompression)
        if version &gt;= (5, 2, 5):
            flagbit(SetupFileFlags.GacInstall)

        reader.byte_align()

        if reader.tell() - flagstart == 3:
            reader.u8()

        self.Type = SetupFileType(reader.u8())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconCloseSetting"><code class="flex name class">
<span>class <span class="ident">SetupIconCloseSetting</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1574-L1577" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupIconCloseSetting(enum.IntEnum):
    NoSetting       = 0           # noqa
    CloseOnExit     = enum.auto() # noqa
    DontCloseOnExit = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupIconCloseSetting.NoSetting"><code class="name">var <span class="ident">NoSetting</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconCloseSetting.CloseOnExit"><code class="name">var <span class="ident">CloseOnExit</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconCloseSetting.DontCloseOnExit"><code class="name">var <span class="ident">DontCloseOnExit</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconFlags"><code class="flex name class">
<span>class <span class="ident">SetupIconFlags</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1580-L1589" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupIconFlags(enum.IntFlag):
    Empty                              = 0           # noqa
    NeverUninstall                     = enum.auto() # noqa
    RunMinimized                       = enum.auto() # noqa
    CreateOnlyIfFileExists             = enum.auto() # noqa
    UseAppPaths                        = enum.auto() # noqa
    FolderShortcut                     = enum.auto() # noqa
    ExcludeFromShowInNewInstall        = enum.auto() # noqa
    PreventPinning                     = enum.auto() # noqa
    HasAppUserModelToastActivatorCLSID = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupIconFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconFlags.NeverUninstall"><code class="name">var <span class="ident">NeverUninstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconFlags.RunMinimized"><code class="name">var <span class="ident">RunMinimized</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconFlags.CreateOnlyIfFileExists"><code class="name">var <span class="ident">CreateOnlyIfFileExists</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconFlags.UseAppPaths"><code class="name">var <span class="ident">UseAppPaths</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconFlags.FolderShortcut"><code class="name">var <span class="ident">FolderShortcut</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconFlags.ExcludeFromShowInNewInstall"><code class="name">var <span class="ident">ExcludeFromShowInNewInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconFlags.PreventPinning"><code class="name">var <span class="ident">PreventPinning</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIconFlags.HasAppUserModelToastActivatorCLSID"><code class="name">var <span class="ident">HasAppUserModelToastActivatorCLSID</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIcon"><code class="flex name class">
<span>class <span class="ident">SetupIcon</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1592-L1649" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupIcon(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u32()

        self.Name = self._read_string()
        self.FileName = self._read_string()
        self.Parameters = self._read_string()
        self.WorkingDir = self._read_string()
        self.IconFile = self._read_string()
        self.Comment = self._read_string()

        self.Condition = SetupCondition(reader, version, parent)

        if version &gt;= (5, 3, 5):
            self.AppUserModelId = self._read_string()
        if version &gt;= (6, 1, 0):
            self.AppUserModelToastActivatorCLSID = reader.read_guid()

        self.WindowsVersion = WinVerRange(reader, version)
        self.IconIndex = reader.i32()

        if version &gt;= (1, 3, 24):
            self.ShowCommand = reader.i32()
        else:
            self.ShowCommand = 1

        if version &gt;= (1, 3, 15):
            self.CloseOnExit = _enum(SetupIconCloseSetting, reader.u8(), SetupIconCloseSetting.NoSetting)
        else:
            self.CloseOnExit = SetupIconCloseSetting.NoSetting

        self.HotKey = reader.u16() if version &gt;= (2, 0, 7) else 0

        self.Flags = SetupIconFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0
        if True:
            flagbit(SetupIconFlags.NeverUninstall)
        if version &lt; (1, 3, 26):
            flagbit(SetupIconFlags.RunMinimized)
        if True:
            flagbit(SetupIconFlags.CreateOnlyIfFileExists)
        if version.bits &gt; 16:
            flagbit(SetupIconFlags.UseAppPaths)
        if version &gt;= (5, 0, 3) and version &lt; (6, 3, 0):
            flagbit(SetupIconFlags.FolderShortcut)
        if version &gt;= (5, 4, 2):
            flagbit(SetupIconFlags.ExcludeFromShowInNewInstall)
        if version &gt;= (5, 5, 0):
            flagbit(SetupIconFlags.PreventPinning)
        if version &gt;= (6, 1, 0):
            flagbit(SetupIconFlags.HasAppUserModelToastActivatorCLSID)
        reader.byte_align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIniFlags"><code class="flex name class">
<span>class <span class="ident">SetupIniFlags</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1652-L1658" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupIniFlags(enum.IntFlag):
    Empty                     = 0           # noqa
    CreateKeyIfDoesntExist    = enum.auto() # noqa
    UninsDeleteEntry          = enum.auto() # noqa
    UninsDeleteEntireSection  = enum.auto() # noqa
    UninsDeleteSectionIfEmpty = enum.auto() # noqa
    HasValue                  = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupIniFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIniFlags.CreateKeyIfDoesntExist"><code class="name">var <span class="ident">CreateKeyIfDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIniFlags.UninsDeleteEntry"><code class="name">var <span class="ident">UninsDeleteEntry</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIniFlags.UninsDeleteEntireSection"><code class="name">var <span class="ident">UninsDeleteEntireSection</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIniFlags.UninsDeleteSectionIfEmpty"><code class="name">var <span class="ident">UninsDeleteSectionIfEmpty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIniFlags.HasValue"><code class="name">var <span class="ident">HasValue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupIniEntry"><code class="flex name class">
<span>class <span class="ident">SetupIniEntry</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1661-L1678" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupIniEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u8()

        if not (IniFile := self._read_string()):
            IniFile = &#39;{windows}/WIN.INI&#39;
        self.IniFile = IniFile

        self.Section = self._read_string()
        self.Key = self._read_string()
        self.Codepage = self._read_string()
        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.Flags = SetupIniFlags(reader.u8())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryType"><code class="flex name class">
<span>class <span class="ident">SetupRegistryType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1681-L1688" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRegistryType(enum.IntEnum):
    Unset        = 0           # noqa
    String       = enum.auto() # noqa
    ExpandString = enum.auto() # noqa
    DWord        = enum.auto() # noqa
    Binary       = enum.auto() # noqa
    MultiString  = enum.auto() # noqa
    QWord        = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryType.Unset"><code class="name">var <span class="ident">Unset</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryType.String"><code class="name">var <span class="ident">String</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryType.ExpandString"><code class="name">var <span class="ident">ExpandString</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryType.DWord"><code class="name">var <span class="ident">DWord</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryType.Binary"><code class="name">var <span class="ident">Binary</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryType.MultiString"><code class="name">var <span class="ident">MultiString</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryType.QWord"><code class="name">var <span class="ident">QWord</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags"><code class="flex name class">
<span>class <span class="ident">SetupRegistryFlags</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1691-L1704" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRegistryFlags(enum.IntFlag):
    Empty                       = 0           # noqa
    CreateValueIfDoesntExist    = enum.auto() # noqa
    UninsDeleteValue            = enum.auto() # noqa
    UninsClearValue             = enum.auto() # noqa
    UninsDeleteEntireKey        = enum.auto() # noqa
    UninsDeleteEntireKeyIfEmpty = enum.auto() # noqa
    PreserveStringType          = enum.auto() # noqa
    DeleteKey                   = enum.auto() # noqa
    DeleteValue                 = enum.auto() # noqa
    NoError                     = enum.auto() # noqa
    DontCreateKey               = enum.auto() # noqa
    Bits32                      = enum.auto() # noqa
    Bits64                      = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.CreateValueIfDoesntExist"><code class="name">var <span class="ident">CreateValueIfDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.UninsDeleteValue"><code class="name">var <span class="ident">UninsDeleteValue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.UninsClearValue"><code class="name">var <span class="ident">UninsClearValue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.UninsDeleteEntireKey"><code class="name">var <span class="ident">UninsDeleteEntireKey</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.UninsDeleteEntireKeyIfEmpty"><code class="name">var <span class="ident">UninsDeleteEntireKeyIfEmpty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.PreserveStringType"><code class="name">var <span class="ident">PreserveStringType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.DeleteKey"><code class="name">var <span class="ident">DeleteKey</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.DeleteValue"><code class="name">var <span class="ident">DeleteValue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.NoError"><code class="name">var <span class="ident">NoError</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.DontCreateKey"><code class="name">var <span class="ident">DontCreateKey</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.Bits32"><code class="name">var <span class="ident">Bits32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryFlags.Bits64"><code class="name">var <span class="ident">Bits64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRegistryEntry"><code class="flex name class">
<span>class <span class="ident">SetupRegistryEntry</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1707-L1755" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRegistryEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u32()

        if True:
            self.Key = self._read_string()
        if version.bits &gt; 16:
            self.Name = self._read_string()
        if True:
            self.Value = reader.read_length_prefixed()
            self.Condition = SetupCondition(reader, version, parent)
        if (4, 0, 11) &lt;= version &lt; (4, 1, 0):
            self.Permissions = reader.read_length_prefixed()

        self.WindowsVersion = WinVerRange(reader, version)
        self.Hive = reader.u32() &amp; 0x7FFFFFFF if version.bits &gt; 16 else None
        self.Permissions = reader.u16() if version &gt;= (4, 1, 0) else None
        self.Type = SetupRegistryType(reader.u8())

        self.Flags = SetupRegistryFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if version.bits &gt; 16:
            flagbit(SetupRegistryFlags.CreateValueIfDoesntExist)
            flagbit(SetupRegistryFlags.UninsDeleteValue)
        if True:
            flagbit(SetupRegistryFlags.UninsClearValue)
            flagbit(SetupRegistryFlags.UninsDeleteEntireKey)
            flagbit(SetupRegistryFlags.UninsDeleteEntireKeyIfEmpty)
        if version &gt;= (1, 2, 6):
            flagbit(SetupRegistryFlags.PreserveStringType)
        if version &gt;= (1, 3, 9):
            flagbit(SetupRegistryFlags.DeleteKey)
            flagbit(SetupRegistryFlags.DeleteValue)
        if version &gt;= (1, 3, 12):
            flagbit(SetupRegistryFlags.NoError)
        if version &gt;= (1, 3, 16):
            flagbit(SetupRegistryFlags.DontCreateKey)
        if version &gt;= (5, 1, 0):
            flagbit(SetupRegistryFlags.Bits32)
            flagbit(SetupRegistryFlags.Bits64)

        reader.byte_align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDeleteType"><code class="flex name class">
<span>class <span class="ident">SetupDeleteType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1758-L1761" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDeleteType(enum.IntEnum):
    Files           = 0           # noqa
    FilesAndSubdirs = enum.auto() # noqa
    DirIfEmpty      = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupDeleteType.Files"><code class="name">var <span class="ident">Files</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDeleteType.FilesAndSubdirs"><code class="name">var <span class="ident">FilesAndSubdirs</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDeleteType.DirIfEmpty"><code class="name">var <span class="ident">DirIfEmpty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDeleteEntry"><code class="flex name class">
<span>class <span class="ident">SetupDeleteEntry</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1764-L1773" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDeleteEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        if version &lt; (1, 3, 0):
            reader.u32()
        self.Name = self._read_string()
        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.Type = SetupDeleteType(reader.u8())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunWait"><code class="flex name class">
<span>class <span class="ident">SetupRunWait</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1776-L1779" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRunWait(enum.IntEnum):
    UntilTerminated = 0 # noqa
    NoWait          = 1 # noqa
    UntilIdle       = 2 # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupRunWait.UntilTerminated"><code class="name">var <span class="ident">UntilTerminated</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunWait.NoWait"><code class="name">var <span class="ident">NoWait</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunWait.UntilIdle"><code class="name">var <span class="ident">UntilIdle</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags"><code class="flex name class">
<span>class <span class="ident">SetupRunFlags</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1782-L1795" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRunFlags(enum.IntFlag):
    Empty             = 0           # noqa
    ShellExec         = enum.auto() # noqa
    SkipIfDoesntExist = enum.auto() # noqa
    PostInstall       = enum.auto() # noqa
    Unchecked         = enum.auto() # noqa
    SkipIfSilent      = enum.auto() # noqa
    SkipIfNotSilent   = enum.auto() # noqa
    HideWizard        = enum.auto() # noqa
    Bits32            = enum.auto() # noqa
    Bits64            = enum.auto() # noqa
    RunAsOriginalUser = enum.auto() # noqa
    DontLogParameters = enum.auto() # noqa
    LogOutput         = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.ShellExec"><code class="name">var <span class="ident">ShellExec</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.SkipIfDoesntExist"><code class="name">var <span class="ident">SkipIfDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.PostInstall"><code class="name">var <span class="ident">PostInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.Unchecked"><code class="name">var <span class="ident">Unchecked</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.SkipIfSilent"><code class="name">var <span class="ident">SkipIfSilent</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.SkipIfNotSilent"><code class="name">var <span class="ident">SkipIfNotSilent</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.HideWizard"><code class="name">var <span class="ident">HideWizard</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.Bits32"><code class="name">var <span class="ident">Bits32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.Bits64"><code class="name">var <span class="ident">Bits64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.RunAsOriginalUser"><code class="name">var <span class="ident">RunAsOriginalUser</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.DontLogParameters"><code class="name">var <span class="ident">DontLogParameters</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunFlags.LogOutput"><code class="name">var <span class="ident">LogOutput</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupRunEntry"><code class="flex name class">
<span>class <span class="ident">SetupRunEntry</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1798-L1848" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRunEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        if version &lt; (1, 3, 0):
            reader.u8()
        self.Name = self._read_string()
        self.Parameters = self._read_string()
        self.WorkingDir = self._read_string()

        if version &gt;= (1, 3, 9):
            self.RunOnceId = self._read_string()
        if version &gt;= (2, 0, 2):
            self.StatusMessage = self._read_string()
        if version &gt;= (5, 1, 13):
            self.Verb = self._read_string()
        if version &gt;= (2, 0, 0) or version.isx:
            self.Description = self._read_string()

        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.ShowCommand = reader.u32() if version &gt;= (1, 3, 24) else 0
        self.Wait = SetupRunWait(reader.u8())

        self.Flags = SetupRunFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if version &gt;= (1, 2, 3):
            flagbit(SetupRunFlags.ShellExec)
        if version &gt;= (1, 3, 9) or version.isx and version &gt;= (1, 3, 8):
            flagbit(SetupRunFlags.SkipIfDoesntExist)
        if version &gt;= (2, 0, 0):
            flagbit(SetupRunFlags.PostInstall)
            flagbit(SetupRunFlags.Unchecked)
            flagbit(SetupRunFlags.SkipIfSilent)
            flagbit(SetupRunFlags.SkipIfNotSilent)
        if version &gt;= (2, 0, 8):
            flagbit(SetupRunFlags.HideWizard)
        if version &gt;= (5, 1, 10):
            flagbit(SetupRunFlags.Bits32)
            flagbit(SetupRunFlags.Bits64)
        if version &gt;= (5, 2, 0):
            flagbit(SetupRunFlags.RunAsOriginalUser)
        if version &gt;= (6, 1, 0):
            flagbit(SetupRunFlags.DontLogParameters)
        if version &gt;= (6, 3, 0):
            flagbit(SetupRunFlags.LogOutput)

        reader.byte_align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.TSetup"><code class="flex name class">
<span>class <span class="ident">TSetup</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1851-L1921" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TSetup(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Header = h = SetupHeader(reader, version)

        def _array(count: int, parser: Type[_T]) -&gt; List[_T]:
            return [parser(reader, version, self) for _ in range(count)]

        self.Languages = _array(h.LanguageCount, SetupLanguage)
        _default_codec = &#39;cp1252&#39;

        if version.unicode:
            self.Codec = &#39;utf-16le&#39;
        elif not self.Languages:
            self.Codec = _default_codec
        else:
            self.Codec = self.Languages[0].Codepage
            if any(language.Codepage == _default_codec for language in self.Languages):
                self.Codec = _default_codec

        if version.ascii:
            h.recode_strings(self.Codec)
        else:
            h.recode_strings(&#39;latin1&#39;)

        if version &lt; (4, 0, 0):
            self._load_wizard_and_decompressor(reader, version)

        self.Messages               = _array(h.MessageCount,         SetupMessage)       # noqa
        self.Permissions            = _array(h.PermissionCount,      SetupPermission)    # noqa
        self.Types                  = _array(h.TypeCount,            SetupType)          # noqa
        self.Components             = _array(h.ComponentCount,       SetupComponent)     # noqa
        self.Tasks                  = _array(h.TaskCount,            SetupTask)          # noqa
        self.Directories            = _array(h.DirectoryCount,       SetupDirectory)     # noqa
        self.Files                  = _array(h.FileCount,            SetupFile)          # noqa

        self.DecompressDLL = None
        self.DecryptionDLL = None

        self.Icons                  = _array(h.IconCount,            SetupIcon)          # noqa
        self.IniEntries             = _array(h.IniEntryCount,        SetupIniEntry)      # noqa
        self.RegistryEntries        = _array(h.RegistryCount,        SetupRegistryEntry) # noqa
        self.DeleteEntries          = _array(h.DeleteCount,          SetupDeleteEntry)   # noqa
        self.UninstallDeleteEntries = _array(h.UninstallDeleteCount, SetupDeleteEntry)   # noqa
        self.RunEntries             = _array(h.RunCount,             SetupRunEntry)      # noqa
        self.UninstallRunEntries    = _array(h.UninstallRunCount,    SetupRunEntry)      # noqa

        if version &gt;= (4, 0, 0):
            self._load_wizard_and_decompressor(reader, version)

    def _load_wizard_and_decompressor(self, reader: StructReader[memoryview], version: InnoVersion):
        if True:
            self.WizardImagesLarge = self._load_wizard_images(reader, version)
        if version &gt;= (2, 0, 0) or version.isx:
            self.WizardImagesSmall = self._load_wizard_images(reader, version)
        method = self.Header.CompressionMethod
        crypto = self.Header.Flags &amp; Flags.EncryptionUsed and version &lt; (6, 4, 0)
        hasDLL = (
            method == CompressionMethod.BZip2
            or method == CompressionMethod.LZMA1 and version == (4, 1, 5)
            or method == CompressionMethod.Flate and version &gt;= (4, 2, 6))
        self.DecompressDLL = reader.read_length_prefixed() if hasDLL else None
        self.DecryptionDLL = reader.read_length_prefixed() if crypto else None

    def _load_wizard_images(self, reader: StructReader[memoryview], version: InnoVersion):
        count = reader.u32() if version &gt;= (5, 6, 0) else 1
        img = [reader.read_length_prefixed() for _ in range(count)]
        if version &lt; (5, 6, 0) and img and not img[0]:
            img.clear()
        return img</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags"><code class="flex name class">
<span>class <span class="ident">SetupDataEntryFlags</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1924-L1937" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDataEntryFlags(enum.IntFlag):
    Empty                    = 0           # noqa    
    VersionInfoValid         = enum.auto() # noqa
    VersionInfoNotValid      = enum.auto() # noqa
    BZipped                  = enum.auto() # noqa
    TimeStampInUTC           = enum.auto() # noqa
    IsUninstallerExe         = enum.auto() # noqa
    CallInstructionOptimized = enum.auto() # noqa
    Touch                    = enum.auto() # noqa
    ChunkEncrypted           = enum.auto() # noqa
    ChunkCompressed          = enum.auto() # noqa
    SolidBreak               = enum.auto() # noqa
    Sign                     = enum.auto() # noqa
    SignOnce                 = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.VersionInfoValid"><code class="name">var <span class="ident">VersionInfoValid</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.VersionInfoNotValid"><code class="name">var <span class="ident">VersionInfoNotValid</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.BZipped"><code class="name">var <span class="ident">BZipped</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.TimeStampInUTC"><code class="name">var <span class="ident">TimeStampInUTC</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.IsUninstallerExe"><code class="name">var <span class="ident">IsUninstallerExe</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.CallInstructionOptimized"><code class="name">var <span class="ident">CallInstructionOptimized</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.Touch"><code class="name">var <span class="ident">Touch</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.ChunkEncrypted"><code class="name">var <span class="ident">ChunkEncrypted</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.ChunkCompressed"><code class="name">var <span class="ident">ChunkCompressed</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.SolidBreak"><code class="name">var <span class="ident">SolidBreak</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.Sign"><code class="name">var <span class="ident">Sign</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntryFlags.SignOnce"><code class="name">var <span class="ident">SignOnce</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupSignMode"><code class="flex name class">
<span>class <span class="ident">SetupSignMode</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1940-L1944" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupSignMode(enum.IntEnum):
    NoSetting  = 0  # noqa
    Yes        = 1  # noqa
    Once       = 2  # noqa
    Check      = 3  # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.SetupSignMode.NoSetting"><code class="name">var <span class="ident">NoSetting</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupSignMode.Yes"><code class="name">var <span class="ident">Yes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupSignMode.Once"><code class="name">var <span class="ident">Once</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupSignMode.Check"><code class="name">var <span class="ident">Check</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.SetupDataEntry"><code class="flex name class">
<span>class <span class="ident">SetupDataEntry</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L1947-L2020" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDataEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.FirstSlice = reader.u32()
        self.LastSlice = reader.u32()
        self.ChunkOffset = reader.u32()
        if version &gt;= (4, 0, 1):
            self.Offset = reader.u64()
        self.FileSize = reader.u64()
        self.ChunkSize = reader.u64()

        if version &gt;= (6, 4, 0):
            self.ChecksumType = CheckSumType.SHA256
            self.Checksum = bytes(reader.read(32))
        elif version &gt;= (5, 3, 9):
            self.ChecksumType = CheckSumType.SHA1
            self.Checksum = bytes(reader.read(20))
        elif version &gt;= (4, 2, 0):
            self.ChecksumType = CheckSumType.MD5
            self.Checksum = bytes(reader.read(16))
        elif version &gt;= (4, 0, 1):
            self.ChecksumType = CheckSumType.CRC32
            self.Checksum = reader.u32()
        else:
            self.ChecksumType = CheckSumType.Adler32
            self.Checksum = reader.u32()

        ft = reader.u64()
        ts = datetime.fromtimestamp(
            (ft - _FILE_TIME_1970_01_01) / 10000000, timezone.utc)
        self.FileTime = ts

        self.FileVersionMs = reader.u32()
        self.FileVersionLs = reader.u32()

        self.Flags = 0

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        flagbit(SetupDataEntryFlags.VersionInfoNotValid)
        flagbit(SetupDataEntryFlags.VersionInfoValid)

        if version &lt; (4, 0, 1):
            flagbit(SetupDataEntryFlags.BZipped)
        if version &gt;= (4, 0, 10):
            flagbit(SetupDataEntryFlags.TimeStampInUTC)
        if version &gt;= (4, 1, 0):
            flagbit(SetupDataEntryFlags.IsUninstallerExe)
        if version &gt;= (4, 1, 8):
            flagbit(SetupDataEntryFlags.CallInstructionOptimized)
        if version &gt;= (4, 2, 0):
            flagbit(SetupDataEntryFlags.Touch)
        if version &gt;= (4, 2, 2):
            flagbit(SetupDataEntryFlags.ChunkEncrypted)
        if version &gt;= (4, 2, 5):
            flagbit(SetupDataEntryFlags.ChunkCompressed)
        if version &gt;= (5, 1, 13):
            flagbit(SetupDataEntryFlags.SolidBreak)
        if version &gt;= (5, 5, 7) and version &lt; (6, 3, 0):
            flagbit(SetupDataEntryFlags.Sign)
            flagbit(SetupDataEntryFlags.SignOnce)

        reader.byte_align()

        if version &gt;= (6, 3, 0):
            self.SignMode = SetupSignMode(reader.u8())
        elif self.Flags &amp; SetupDataEntryFlags.SignOnce:
            self.SignMode = SetupSignMode.Once
        elif self.Flags &amp; SetupDataEntryFlags.Sign:
            self.SignMode = SetupSignMode.Yes
        else:
            self.SignMode = SetupSignMode.NoSetting</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.TData"><code class="flex name class">
<span>class <span class="ident">TData</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L2023-L2029" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TData(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.DataEntries: list[SetupDataEntry] = []
        while not reader.eof:
            self.DataEntries.append(SetupDataEntry(reader, version))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoParseResult"><code class="flex name class">
<span>class <span class="ident">InnoParseResult</span></span>
<span>(</span><span>version, streams, files, encrypted_file, warnings, failures, stream0, stream1)</span>
</code></dt>
<dd>
<section class="desc"><p>InnoParseResult(version, streams, files, encrypted_file, warnings, failures, stream0, stream1)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L2032-L2043" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: List[InnoStream]
    files: List[InnoFile]
    encrypted_file: Optional[InnoFile]
    warnings: int
    failures: List[str]
    stream0: TSetup
    stream1: TData

    def ok(self):
        return self.warnings == 0 and not self.failures</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InnoParseResult.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoParseResult.streams"><code class="name">var <span class="ident">streams</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoParseResult.files"><code class="name">var <span class="ident">files</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoParseResult.encrypted_file"><code class="name">var <span class="ident">encrypted_file</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoParseResult.warnings"><code class="name">var <span class="ident">warnings</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 4</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoParseResult.failures"><code class="name">var <span class="ident">failures</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 5</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoParseResult.stream0"><code class="name">var <span class="ident">stream0</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 6</p></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.InnoParseResult.stream1"><code class="name">var <span class="ident">stream1</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 7</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.InnoParseResult.ok"><code class="name flex">
<span>def <span class="ident">ok</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L2042-L2043" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ok(self):
    return self.warnings == 0 and not self.failures</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtinno.xtinno"><code class="flex name class">
<span>class <span class="ident">xtinno</span></span>
<span>(</span><span>*paths, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False, path=b'path', date=b'date', pwd=b'')</span>
</code></dt>
<dd>
<section class="desc"><p>Extract files from InnoSetup archives.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L2046-L2662" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class xtinno(ArchiveUnit):
    &#34;&#34;&#34;
    Extract files from InnoSetup archives.
    &#34;&#34;&#34;
    _STREAM_NAMES = &#39;meta/TSetup&#39;, &#39;meta/TData&#39;, &#39;embedded/uninstaller.exe&#39;
    _ISCRIPT_NAME = &#39;embedded/script&#39;
    _LICENSE_NAME = &#39;embedded/license.rtf&#39;
    _OFFSETS_PATH = &#39;RCDATA/11111/0&#39;
    _CHUNK_PREFIX = b&#39;zlb\x1a&#39;
    _MAX_ATTEMPTS = 200_000

    def unpack(self, data: bytearray):
        try:
            file_metadata = one(data | perc(self._OFFSETS_PATH))
        except Exception as E:
            raise ValueError(F&#39;Could not find TSetupOffsets PE resource at {self._OFFSETS_PATH}&#39;) from E

        meta = TSetupOffsets(file_metadata)
        view = memoryview(data)
        base = meta.base
        inno = StructReader(view[base:base + meta.total_size])

        self._decompressed = {}
        password = self.args.pwd or None

        blobsize = meta.setup0 - meta.setup1
        inno.seek(meta.setup1)
        blobs = StructReader(inno.read(blobsize))

        header = bytes(inno.read(16))

        try:
            version = InnoVersion.ParseLegacy(header)
        except ValueError:
            header += bytes(inno.read(64 - 16))
            try:
                version = InnoVersion.Parse(header)
            except ValueError:
                name, _, _rest = header.partition(b&#39;\0&#39;)
                method = &#39;broken&#39;
                if any(_rest):
                    header = name.hex()
                else:
                    header = name.decode(&#39;latin1&#39;)
                if self.leniency &lt; 1:
                    raise ValueError(F&#39;unable to parse header identifier &#34;{header}&#34;&#39;)
                version = _DEFAULT_INNO_VERSION
            else:
                header, _, _ = header.partition(B&#39;\0&#39;)
                header = header.decode(&#39;latin1&#39;)
                method = &#39;modern&#39;
        else:
            header, _, _ = header.partition(B&#39;\x1A&#39;)
            header = header.decode(&#39;latin1&#39;)
            method = &#39;legacy&#39;

        self.log_info(F&#39;inno {version!s} via {method} header: {header}&#39;)

        class _notok(object):
            def __init__(self, e: Exception):
                self.failures = [str(e)]

            def ok(self):
                return False

        def _parse(v: InnoVersion):
            try:
                inno.seekset(inno_start)
                if v.legacy:
                    inno.seekrel(-48)
                r = self._try_parse_as(inno, blobs, v, password)
            except Exception as e:
                self.log_info(F&#39;exception while parsing as {v!s}: {exception_to_string(e)}&#39;)
                return _notok(e)
            else:
                results[v] = r
                return r

        inno_start = inno.tell()
        best_parse = None
        best_score = 0
        success = False
        results: dict[InnoVersion, InnoParseResult] = {}

        if not version.is_ambiguous():
            index = _VERSIONS.index(version)
        else:
            try:
                index = max(k for k, v in enumerate(_VERSIONS) if v &lt;= version)
            except Exception:
                index = 0

        upper = index + 1
        lower = index

        while lower &gt; 0 and _IS_AMBIGUOUS[_VERSIONS[lower - 1]]:
            lower -= 1

        versions = [version] + _VERSIONS[lower:index] + _VERSIONS[upper:] + _VERSIONS[:lower]

        for v in versions:
            result = _parse(v)
            if success := result.ok():
                break
            if not result.failures and (best_parse is None or result.warnings &lt; best_score):
                best_score = best_score
                best_parse = result

        if not success:
            if best_parse is not None:
                result = best_parse
                self.log_warn(F&#39;using parse result for {result.version!s} with {result.warnings} warnings&#39;)
            else:
                result = min(results.values(), key=lambda result: len(result.failures))
                self.log_warn(F&#39;using parse result for {result.version!s} with {len(result.failures)} failures&#39;)
                for k, failure in enumerate(result.failures, 1):
                    self.log_info(F&#39;failure {k}: {failure}&#39;)

        version = result.version
        codec = result.stream0.Codec
        stream0 = result.stream0
        stream1 = result.stream1
        files = result.files
        streams = result.streams
        encrypted_file = result.encrypted_file

        if version.unicode:
            codec = &#39;latin1&#39;
        self.log_info(
            F&#39;inno {version!s} &#39;
            F&#39;compression:{stream0.Header.CompressionMethod.name} &#39;
            F&#39;codepage:{codec} &#39;
            F&#39;password:{stream0.Header.PasswordType.name} &#39;
        )

        if (script := stream0.Header.CompiledCode) and encrypted_file:
            assert password is None, (
                F&#39;An encrypted test file was chosen even though a password was provided: {password!r}&#39;)
            self.log_info(F&#39;guessing password using encrypted file: {encrypted_file.path}&#39;)
            try:
                def _pwd(s: str):
                    if not s:
                        return False
                    if re.search(r&#39;\{\w+\}&#39;, s):
                        return False
                    if re.search(R&#39;^\w{2,12}://&#39;, s):
                        return False
                    return True
                from refinery.units.formats.ifpsstr import ifpsstr
                from itertools import combinations
                strings = script | ifpsstr(codec) | {str}
                strings = [s for s in strings if _pwd(s)]
                total = 0
                for k in range(1, 10):
                    self.log_info(F&#39;checking combinations of {k} strings as potential password&#39;)
                    if total &gt; self._MAX_ATTEMPTS:
                        break
                    for parts in combinations(strings, k):
                        if total &gt; self._MAX_ATTEMPTS:
                            break
                        string = &#39;&#39;.join(parts)
                        tests = [string]
                        try:
                            tests.append(bytes.fromhex(string))
                        except Exception:
                            pass
                        try:
                            tests.append(base64.b64decode(string).decode(codec))
                        except Exception:
                            pass
                        for pwd in tests:
                            try:
                                plaintext = self._read_file(encrypted_file, password=pwd)
                                if not encrypted_file.check(plaintext):
                                    continue
                                password = pwd
                                btw = F&#39; (combination of {k} parts)&#39; if k &gt; 1 else &#39;&#39;
                                self.log_info(F&#39;found password{btw}: {pwd}&#39;)
                                break
                            except Exception:
                                continue
                            finally:
                                total += 1
                        if password is not None:
                            break
            except Exception as e:
                self.log_info(F&#39;failed to extract strings from IFPS: {exception_to_string(e)}&#39;)

        if encrypted_file and password is None:
            self.log_warn(&#39;some files are password-protected and automatic password search failed&#39;)

        yield self._pack(streams[0].name, None, streams[0].data)
        with BytesAsStringEncoder as encoder:
            yield self._pack(F&#39;{streams[0].name}.json&#39;, None,
                encoder.dumps(stream0.json()).encode(self.codec))

        yield self._pack(streams[1].name, None, streams[1].data)
        with BytesAsStringEncoder as encoder:
            yield self._pack(F&#39;{streams[1].name}.json&#39;, None,
                encoder.dumps(stream1.json()).encode(self.codec))

        yield self._pack(
            streams[2].name, None, lambda s=streams[2]: self._read_stream(s))

        if license := stream0.Header.get_license():
            yield self._pack(self._LICENSE_NAME, None, license.encode(self.codec))

        if script:
            from refinery.units.formats.ifps import ifps
            yield self._pack(F&#39;{self._ISCRIPT_NAME}.ps&#39;, None, script | ifps(codec) | bytes)
            yield self._pack(F&#39;{self._ISCRIPT_NAME}.bin&#39;, None, script)

        if dll := stream0.DecompressDLL:
            yield self._pack(F&#39;embedded/decompress.{magic(dll).extension}&#39;, None, dll)

        if dll := stream0.DecryptionDLL:
            yield self._pack(F&#39;embedded/decryption.{magic(dll).extension}&#39;, None, dll)

        for size, images in (
            (&#39;small&#39;, stream0.WizardImagesSmall),
            (&#39;large&#39;, stream0.WizardImagesLarge),
        ):
            _formatting = len(str(len(images) + 1))
            for k, img in enumerate(images, 1):
                yield self._pack(F&#39;embedded/images/{size}{k:0{_formatting}d}.{magic(img).extension}&#39;, None, img)

        for file in files:
            if file.dupe:
                continue
            yield self._pack(
                file.path,
                file.date,
                lambda f=file: self._read_file_and_check(f, password=password),
                tags=[t.name for t in SetupFileFlags if t &amp; file.tags],
            )

    def _try_parse_as(
        self,
        inno: StructReader,
        blobs: StructReader,
        version: InnoVersion,
        password: Optional[str] = None,
        max_failures: int = 5
    ):
        streams: List[InnoStream] = []
        files: List[InnoFile] = []
        encrypted_file = None
        warnings = 0

        for name in self._STREAM_NAMES:
            stream = InnoStream(StreamHeader(inno, name, version))
            streams.append(stream)
            to_read = stream.header.StoredSize
            while to_read &gt; 4:
                block = CrcCompressedBlock(inno, min(to_read - 4, 0x1000))
                stream.blocks.append(block)
                to_read -= len(block)

        self.log_debug(F&#39;{version!s} parsing stream 1 (TData)&#39;)
        stream1 = TData(memoryview(self._read_stream(streams[1])), version)

        for meta in stream1.DataEntries:
            file = InnoFile(blobs, version, meta)
            files.append(file)
            if password or not file.encrypted or not file.size:
                continue
            if encrypted_file is None or file.size &lt; encrypted_file.size:
                encrypted_file = file

        self.log_debug(F&#39;{version!s} parsing stream 0 (TSetup)&#39;)
        stream0 = TSetup(memoryview(self._read_stream(streams[0])), version)
        path_dedup: dict[str, list[SetupFile]] = {}

        for file in files:
            file.compression_method = stream0.Header.CompressionMethod
            file.password_hash = stream0.Header.PasswordHash
            file.password_type = stream0.Header.PasswordType
            file.password_salt = stream0.Header.PasswordSalt

        for sf in stream0.Files:
            sf: SetupFile
            location = sf.Location
            if location == 0xFFFFFFFF or sf.Type != SetupFileType.UserFile or sf.Source:
                msg = F&#39;skipping file: offset=0x{location:08X} type={sf.Type.name}&#39;
                if sf.Source:
                    msg = F&#39;{msg} src={sf.Source}&#39;
                self.log_debug(msg)
                continue
            if location &gt;= len(files):
                self.log_warn(F&#39;parsed {len(file)} entries, ignoring invalid setup reference to entry {location + 1}&#39;)
                continue
            path = sf.Destination.replace(&#39;\\&#39;, &#39;/&#39;)
            if condition := sf.Condition.Check:
                condition = condition.replace(&#39; &#39;, &#39;-&#39;)
                path = F&#39;{condition}/{path}&#39;
            path = F&#39;data/{path}&#39;
            path_dedup.setdefault(path, []).append(sf)
            files[location].setup = sf
            files[location].path = path

        for path, infos in path_dedup.items():
            if len(infos) == 1:
                files[infos[0].Location].path = path
                continue
            bycheck = {}
            for info in infos:
                file = files[info.Location]
                if not file.checksum_type.strong():
                    bycheck.clear()
                    break
                dkey = (file.checksum, file.size)
                if dkey in bycheck:
                    self.log_debug(F&#39;skipping exact duplicate: {path}&#39;)
                    file.dupe = True
                    continue
                bycheck[dkey] = info
            if bycheck:
                if len(bycheck) == 1:
                    file.path = path
                    continue
                infos = list(bycheck.values())
            for k, info in enumerate(infos):
                files[info.Location].path = F&#39;{path}[{k}]&#39;

        _width = len(str(len(files)))

        for k, file in enumerate(files):
            if file.dupe:
                continue
            if not file.path:
                self.log_debug(F&#39;file {k} does not have a path&#39;)
                file.path = F&#39;raw/FileData{k:0{_width}d}&#39;

        warnings = sum(1 for file in files if file.setup is None)
        failures = []
        nonempty = [f for f in files if f.size &gt; 0]

        self._decompressed.clear()

        for file in nonempty:
            if len(failures) &gt;= max_failures:
                break
            if file.setup is None:
                failures.append(F&#39;file {file.path} had no associated metadata&#39;)
                continue
            if file.chunk_length &lt; 0x10000:
                try:
                    data = self._read_file(file)
                except InvalidPassword:
                    continue
                except Exception as e:
                    failures.append(F&#39;extraction error for {file.path}: {e!s}&#39;)
                    continue
                if file.check(data) != file.checksum:
                    failures.append(F&#39;invalid checksum for {file.path}&#39;)

        return InnoParseResult(
            version,
            streams,
            files,
            encrypted_file,
            warnings,
            failures,
            stream0,
            stream1,
        )

    def _read_stream(self, stream: InnoStream):
        if stream.data is not None:
            return stream.data
        result = bytearray()
        it = iter(stream.blocks)
        if stream.compression == StreamCompressionMethod.Store:
            class _dummy(self):
                def decompress(self, b):
                    return b
            dec = _dummy()
        elif stream.compression == StreamCompressionMethod.LZMA1:
            import lzma
            first = next(it).BlockData
            prop, first = first[:5], first[5:]
            filter = parse_lzma_properties(prop, 1)
            dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[filter])
            result.extend(dec.decompress(first))
        elif stream.compression == StreamCompressionMethod.Flate:
            import zlib
            dec = zlib.decompressobj()
        for block in it:
            result.extend(dec.decompress(block.BlockData))
        stream.data = result
        return result

    def _read_chunk(self, file: InnoFile, password: Optional[str] = None):
        reader = file.reader
        offset = file.chunk_offset
        length = file.chunk_length
        method = file.compression

        if offset + length &gt; len(reader):
            span = F&#39;0x{offset:X}-0x{offset + length:X}&#39;
            raise LookupError(
                F&#39;File data spans 0x{len(file.reader):X} bytes, but the file {file.path} is located at {span}.&#39;)

        reader.seek(offset)
        prefix = reader.read(4)

        if prefix != self._CHUNK_PREFIX:
            raise ValueError(F&#39;Error reading chunk at offset 0x{offset:X}; invalid magic {prefix.hex()}.&#39;)

        if file.encrypted:
            if file.password_type == PasswordType.Nothing:
                raise RuntimeError(F&#39;File {file.path} is encrypted, but no password type was set.&#39;)
            if password is None:
                raise InvalidPassword
            if file.password_type == PasswordType.XChaCha20:
                salt, iterations, nonce = struct.unpack(&#39;=16sI24s&#39;, file.password_salt)
                key = password.encode(&#39;utf8&#39;) | pbkdf2(32, salt, iterations, &#39;SHA256&#39;) | bytes
                test_nonce = list(struct.unpack(&#39;6I&#39;, nonce))
                test_nonce[2] = ~test_nonce[2]
                test_nonce = struct.pack(&#39;6I&#39;, test_nonce)
                if B&#39;\0\0\0\0&#39; | xchacha(key, nonce=test_nonce) | bytes != file.password_hash:
                    raise InvalidPassword(password)
                decryptor = xchacha(key, nonce=nonce)
            else:
                password_bytes = password.encode(
                    &#39;utf-16le&#39; if file.unicode else &#39;utf8&#39;)
                algorithm = {
                    PasswordType.SHA1: sha1,
                    PasswordType.MD5 : md5,
                }[file.password_type]
                hash = algorithm(b&#39;PasswordCheckHash&#39; + file.password_salt)
                hash.update(password_bytes)
                if hash.digest() != file.password_hash:
                    raise InvalidPassword(password)
                hash = algorithm(reader.read(8))
                hash.update(password_bytes)
                decryptor = rc4(hash.digest(), discard=1000)

        data = reader.read_exactly(length)

        if file.encrypted:
            data = data | decryptor | bytearray

        if method is None:
            return chunk

        try:
            if method == CompressionMethod.Store:
                chunk = data
            elif method == CompressionMethod.LZMA1:
                props = parse_lzma_properties(data[0:5], 1)
                dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[props])
                chunk = dec.decompress(data[5:])
            elif method == CompressionMethod.LZMA2:
                props = parse_lzma_properties(data[0:1], 2)
                dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[props])
                chunk = dec.decompress(data[1:])
            elif method == CompressionMethod.BZip2:
                chunk = bz2.decompress(data)
            elif method == CompressionMethod.Flate:
                chunk = zlib.decompress(data)
        except Exception as E:
            if not file.encrypted:
                raise
            raise InvalidPassword(password) from E

        return chunk

    def _read_file(
        self,
        file: InnoFile,
        password: Optional[str] = None,
    ):
        offset = file.chunk_offset
        length = file.chunk_length

        try:
            chunk = self._decompressed[offset, length]
        except KeyError:
            chunk = self._decompressed[offset, length] = self._read_chunk(file, password)

        view = memoryview(chunk)
        data = view[file.offset:file.offset + file.size]

        if file.filtered:
            if file.version &gt;= (5, 2, 0):
                flip = (file.version &gt;= (5, 3, 9))
                data = self._filter_new(data, flip_high_byte=flip)
            else:
                data = self._filter_old(data)

        return data

    def _read_file_and_check(
        self,
        file: InnoFile,
        password: Optional[str] = None,
    ):
        data = self._read_file(file, password)

        if not self.leniency and (cs := file.check(data)) is not None and cs != file.checksum:
            if isinstance(cs, int):
                computed = F&#39;{cs:08X}&#39;
                expected = F&#39;{file.checksum:08X}&#39;
            else:
                computed = cs.hex().upper()
                expected = file.checksum.hex().upper()
            raise ValueError(F&#39;checksum error; computed:{computed} expected:{expected} [ignore this check with -L]&#39;)

        return data

    @ArchiveUnit.Requires(&#39;numpy&#39;, &#39;speed&#39;, &#39;default&#39;, &#39;extended&#39;)
    def _numpy():
        import numpy
        return numpy

    def _filter_new(self, data: ByteStr, flip_high_byte=False):
        try:
            np = self._numpy
        except ImportError:
            return self._filter_new_fallback(data, flip_high_byte)
        u08 = np.uint8
        u32 = np.uint32
        ab0 = bytearray()
        ab1 = bytearray()
        ab2 = bytearray()
        ab3 = bytearray()
        positions = []
        if isinstance(data, bytearray):
            out = data
        else:
            out = bytearray(data)
        mem = memoryview(out)
        for k in range(0, len(mem), 0x10000):
            for match in re.finditer(B&#39;(?s)[\xE8\xE9]....&#39;, mem[k:k + 0x10000], flags=re.DOTALL):
                a = match.start() + k
                top = mem[a + 4]
                if top != 0x00 and top != 0xFF:
                    continue
                ab0.append(mem[a + 1])
                ab1.append(mem[a + 2])
                ab2.append(mem[a + 3])
                ab3.append(top)
                positions.append(a + 5)
        ab0 = np.frombuffer(ab0, dtype=u08)
        ab1 = np.frombuffer(ab1, dtype=u08)
        low = np.frombuffer(ab2, dtype=u08).astype(u32)
        msb = np.frombuffer(ab3, dtype=u08)
        sub = np.fromiter(positions, dtype=u32)
        low &lt;&lt;= 8
        low += ab1
        low &lt;&lt;= 8
        low += ab0
        low -= sub
        low &amp;= 0xFFFFFF
        if flip_high_byte:
            flips = low &gt;&gt; 23
            keeps = 1 - flips
            keeps *= msb
            msb ^= 0xFF
            msb *= flips
            msb += keeps
        low += (msb.astype(u32) &lt;&lt; 24)
        addresses = low.tobytes()
        for k, offset in enumerate(positions):
            out[offset - 4:offset] = addresses[k * 4:(k + 1) * 4]
        return out

    def _filter_new_fallback(self, data: ByteStr, flip_high_byte=False):
        block_size = 0x10000
        out = bytearray(data)
        i = 0
        while len(data) - i &gt;= 5:
            c = out[i]
            block_size_left = block_size - (i % block_size)
            i += 1
            if (c == 0xE8 or c == 0xE9) and block_size_left &gt;= 5:
                address = out[i:i + 4]
                i += 4
                if address[3] == 0 or address[3] == 0xFF:
                    rel = address[0] | address[1] &lt;&lt; 8 | address[2] &lt;&lt; 16
                    rel -= i &amp; 0xFFFFFF
                    out[i - 4] = rel &amp; 0xFF
                    out[i - 3] = (rel &gt;&gt; 8) &amp; 0xFF
                    out[i - 2] = (rel &gt;&gt; 16) &amp; 0xFF
                    if flip_high_byte and (rel &amp; 0x800000) != 0:
                        out[i - 1] = (~out[i - 1]) &amp; 0xFF
        return out

    @staticmethod
    def _filter_old(data: ByteStr):
        if not isinstance(data, bytearray):
            data = bytearray(data)
        addr_bytes_left = 0
        addr_offset = 5
        addr = 0
        for i, c in enumerate(data):
            if addr_bytes_left == 0:
                if c == 0xE8 or c == 0xE9:
                    addr = (~addr_offset + 1) &amp; 0xFFFFFFFF
                    addr_bytes_left = 4
            else:
                addr = (addr + c) &amp; 0xFFFFFFFF
                c = addr &amp; 0xFF
                addr = addr &gt;&gt; 8
                addr_bytes_left -= 1
            data[i] = c
        return data

    @classmethod
    def handles(self, data):
        if data[:2] != B&#39;MZ&#39;:
            return False
        if re.search(re.escape(self._CHUNK_PREFIX), data) is None:
            return False
        return bool(
            re.search(BR&#39;Inno Setup Setup Data \(\d+\.\d+\.&#39;, data))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.ArchiveUnit" href="index.html#refinery.units.formats.archive.ArchiveUnit">ArchiveUnit</a></li>
<li><a title="refinery.units.formats.PathExtractorUnit" href="../index.html#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></li>
<li><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.xtinno.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtinno.xtinno.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtinno.xtinno.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/archive/xtinno.py#L2057-L2280" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self, data: bytearray):
    try:
        file_metadata = one(data | perc(self._OFFSETS_PATH))
    except Exception as E:
        raise ValueError(F&#39;Could not find TSetupOffsets PE resource at {self._OFFSETS_PATH}&#39;) from E

    meta = TSetupOffsets(file_metadata)
    view = memoryview(data)
    base = meta.base
    inno = StructReader(view[base:base + meta.total_size])

    self._decompressed = {}
    password = self.args.pwd or None

    blobsize = meta.setup0 - meta.setup1
    inno.seek(meta.setup1)
    blobs = StructReader(inno.read(blobsize))

    header = bytes(inno.read(16))

    try:
        version = InnoVersion.ParseLegacy(header)
    except ValueError:
        header += bytes(inno.read(64 - 16))
        try:
            version = InnoVersion.Parse(header)
        except ValueError:
            name, _, _rest = header.partition(b&#39;\0&#39;)
            method = &#39;broken&#39;
            if any(_rest):
                header = name.hex()
            else:
                header = name.decode(&#39;latin1&#39;)
            if self.leniency &lt; 1:
                raise ValueError(F&#39;unable to parse header identifier &#34;{header}&#34;&#39;)
            version = _DEFAULT_INNO_VERSION
        else:
            header, _, _ = header.partition(B&#39;\0&#39;)
            header = header.decode(&#39;latin1&#39;)
            method = &#39;modern&#39;
    else:
        header, _, _ = header.partition(B&#39;\x1A&#39;)
        header = header.decode(&#39;latin1&#39;)
        method = &#39;legacy&#39;

    self.log_info(F&#39;inno {version!s} via {method} header: {header}&#39;)

    class _notok(object):
        def __init__(self, e: Exception):
            self.failures = [str(e)]

        def ok(self):
            return False

    def _parse(v: InnoVersion):
        try:
            inno.seekset(inno_start)
            if v.legacy:
                inno.seekrel(-48)
            r = self._try_parse_as(inno, blobs, v, password)
        except Exception as e:
            self.log_info(F&#39;exception while parsing as {v!s}: {exception_to_string(e)}&#39;)
            return _notok(e)
        else:
            results[v] = r
            return r

    inno_start = inno.tell()
    best_parse = None
    best_score = 0
    success = False
    results: dict[InnoVersion, InnoParseResult] = {}

    if not version.is_ambiguous():
        index = _VERSIONS.index(version)
    else:
        try:
            index = max(k for k, v in enumerate(_VERSIONS) if v &lt;= version)
        except Exception:
            index = 0

    upper = index + 1
    lower = index

    while lower &gt; 0 and _IS_AMBIGUOUS[_VERSIONS[lower - 1]]:
        lower -= 1

    versions = [version] + _VERSIONS[lower:index] + _VERSIONS[upper:] + _VERSIONS[:lower]

    for v in versions:
        result = _parse(v)
        if success := result.ok():
            break
        if not result.failures and (best_parse is None or result.warnings &lt; best_score):
            best_score = best_score
            best_parse = result

    if not success:
        if best_parse is not None:
            result = best_parse
            self.log_warn(F&#39;using parse result for {result.version!s} with {result.warnings} warnings&#39;)
        else:
            result = min(results.values(), key=lambda result: len(result.failures))
            self.log_warn(F&#39;using parse result for {result.version!s} with {len(result.failures)} failures&#39;)
            for k, failure in enumerate(result.failures, 1):
                self.log_info(F&#39;failure {k}: {failure}&#39;)

    version = result.version
    codec = result.stream0.Codec
    stream0 = result.stream0
    stream1 = result.stream1
    files = result.files
    streams = result.streams
    encrypted_file = result.encrypted_file

    if version.unicode:
        codec = &#39;latin1&#39;
    self.log_info(
        F&#39;inno {version!s} &#39;
        F&#39;compression:{stream0.Header.CompressionMethod.name} &#39;
        F&#39;codepage:{codec} &#39;
        F&#39;password:{stream0.Header.PasswordType.name} &#39;
    )

    if (script := stream0.Header.CompiledCode) and encrypted_file:
        assert password is None, (
            F&#39;An encrypted test file was chosen even though a password was provided: {password!r}&#39;)
        self.log_info(F&#39;guessing password using encrypted file: {encrypted_file.path}&#39;)
        try:
            def _pwd(s: str):
                if not s:
                    return False
                if re.search(r&#39;\{\w+\}&#39;, s):
                    return False
                if re.search(R&#39;^\w{2,12}://&#39;, s):
                    return False
                return True
            from refinery.units.formats.ifpsstr import ifpsstr
            from itertools import combinations
            strings = script | ifpsstr(codec) | {str}
            strings = [s for s in strings if _pwd(s)]
            total = 0
            for k in range(1, 10):
                self.log_info(F&#39;checking combinations of {k} strings as potential password&#39;)
                if total &gt; self._MAX_ATTEMPTS:
                    break
                for parts in combinations(strings, k):
                    if total &gt; self._MAX_ATTEMPTS:
                        break
                    string = &#39;&#39;.join(parts)
                    tests = [string]
                    try:
                        tests.append(bytes.fromhex(string))
                    except Exception:
                        pass
                    try:
                        tests.append(base64.b64decode(string).decode(codec))
                    except Exception:
                        pass
                    for pwd in tests:
                        try:
                            plaintext = self._read_file(encrypted_file, password=pwd)
                            if not encrypted_file.check(plaintext):
                                continue
                            password = pwd
                            btw = F&#39; (combination of {k} parts)&#39; if k &gt; 1 else &#39;&#39;
                            self.log_info(F&#39;found password{btw}: {pwd}&#39;)
                            break
                        except Exception:
                            continue
                        finally:
                            total += 1
                    if password is not None:
                        break
        except Exception as e:
            self.log_info(F&#39;failed to extract strings from IFPS: {exception_to_string(e)}&#39;)

    if encrypted_file and password is None:
        self.log_warn(&#39;some files are password-protected and automatic password search failed&#39;)

    yield self._pack(streams[0].name, None, streams[0].data)
    with BytesAsStringEncoder as encoder:
        yield self._pack(F&#39;{streams[0].name}.json&#39;, None,
            encoder.dumps(stream0.json()).encode(self.codec))

    yield self._pack(streams[1].name, None, streams[1].data)
    with BytesAsStringEncoder as encoder:
        yield self._pack(F&#39;{streams[1].name}.json&#39;, None,
            encoder.dumps(stream1.json()).encode(self.codec))

    yield self._pack(
        streams[2].name, None, lambda s=streams[2]: self._read_stream(s))

    if license := stream0.Header.get_license():
        yield self._pack(self._LICENSE_NAME, None, license.encode(self.codec))

    if script:
        from refinery.units.formats.ifps import ifps
        yield self._pack(F&#39;{self._ISCRIPT_NAME}.ps&#39;, None, script | ifps(codec) | bytes)
        yield self._pack(F&#39;{self._ISCRIPT_NAME}.bin&#39;, None, script)

    if dll := stream0.DecompressDLL:
        yield self._pack(F&#39;embedded/decompress.{magic(dll).extension}&#39;, None, dll)

    if dll := stream0.DecryptionDLL:
        yield self._pack(F&#39;embedded/decryption.{magic(dll).extension}&#39;, None, dll)

    for size, images in (
        (&#39;small&#39;, stream0.WizardImagesSmall),
        (&#39;large&#39;, stream0.WizardImagesLarge),
    ):
        _formatting = len(str(len(images) + 1))
        for k, img in enumerate(images, 1):
            yield self._pack(F&#39;embedded/images/{size}{k:0{_formatting}d}.{magic(img).extension}&#39;, None, img)

    for file in files:
        if file.dupe:
            continue
        yield self._pack(
            file.path,
            file.date,
            lambda f=file: self._read_file_and_check(f, password=password),
            tags=[t.name for t in SetupFileFlags if t &amp; file.tags],
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.formats.archive.ArchiveUnit" href="index.html#refinery.units.formats.archive.ArchiveUnit">ArchiveUnit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.Arg" href="../../index.html#refinery.units.Unit.Arg">Arg</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.CustomPathSeparator" href="../index.html#refinery.units.formats.PathExtractorUnit.CustomPathSeparator">CustomPathSeparator</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.assemble" href="../../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.filter" href="../../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.finish" href="../../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.handles" href="../../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.is_quiet" href="../../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.labelled" href="../../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.leniency" href="../../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_debug" href="../../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_detach" href="../../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_fail" href="../../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_info" href="../../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_level" href="../../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_warn" href="../../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.nozzle" href="../../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.process" href="../../index.html#refinery.units.UnitBase.process">process</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.read" href="../../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.read1" href="../../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.reverse" href="../../index.html#refinery.units.UnitBase.reverse">reverse</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.run" href="../../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.source" href="../../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.superinit" href="../../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.formats.archive" href="index.html">refinery.units.formats.archive</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.InvalidPassword" href="#refinery.units.formats.archive.xtinno.InvalidPassword">InvalidPassword</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.IncorrectVersion" href="#refinery.units.formats.archive.xtinno.IncorrectVersion">IncorrectVersion</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.FileChunkOutOfBounds" href="#refinery.units.formats.archive.xtinno.FileChunkOutOfBounds">FileChunkOutOfBounds</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.IVF" href="#refinery.units.formats.archive.xtinno.IVF">IVF</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.InnoVersion" href="#refinery.units.formats.archive.xtinno.InnoVersion">InnoVersion</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtinno.InnoVersion.ParseLegacy" href="#refinery.units.formats.archive.xtinno.InnoVersion.ParseLegacy">ParseLegacy</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtinno.InnoVersion.Parse" href="#refinery.units.formats.archive.xtinno.InnoVersion.Parse">Parse</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtinno.InnoVersion.is_ambiguous" href="#refinery.units.formats.archive.xtinno.InnoVersion.is_ambiguous">is_ambiguous</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.JsonStruct" href="#refinery.units.formats.archive.xtinno.JsonStruct">JsonStruct</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtinno.JsonStruct.json" href="#refinery.units.formats.archive.xtinno.JsonStruct.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.InnoStruct" href="#refinery.units.formats.archive.xtinno.InnoStruct">InnoStruct</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.CheckSumType" href="#refinery.units.formats.archive.xtinno.CheckSumType">CheckSumType</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtinno.CheckSumType.strong" href="#refinery.units.formats.archive.xtinno.CheckSumType.strong">strong</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.Flags" href="#refinery.units.formats.archive.xtinno.Flags">Flags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.AutoBool" href="#refinery.units.formats.archive.xtinno.AutoBool">AutoBool</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtinno.AutoBool.From" href="#refinery.units.formats.archive.xtinno.AutoBool.From">From</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.WizardStyle" href="#refinery.units.formats.archive.xtinno.WizardStyle">WizardStyle</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.StoredAlphaFormat" href="#refinery.units.formats.archive.xtinno.StoredAlphaFormat">StoredAlphaFormat</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.UninstallLogMode" href="#refinery.units.formats.archive.xtinno.UninstallLogMode">UninstallLogMode</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupStyle" href="#refinery.units.formats.archive.xtinno.SetupStyle">SetupStyle</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.PrivilegesRequired" href="#refinery.units.formats.archive.xtinno.PrivilegesRequired">PrivilegesRequired</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.PrivilegesRequiredOverrideAllowed" href="#refinery.units.formats.archive.xtinno.PrivilegesRequiredOverrideAllowed">PrivilegesRequiredOverrideAllowed</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.LanguageDetection" href="#refinery.units.formats.archive.xtinno.LanguageDetection">LanguageDetection</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.CompressionMethod" href="#refinery.units.formats.archive.xtinno.CompressionMethod">CompressionMethod</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtinno.CompressionMethod.legacy_check" href="#refinery.units.formats.archive.xtinno.CompressionMethod.legacy_check">legacy_check</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtinno.CompressionMethod.legacy_conversion_pre_4_2_5" href="#refinery.units.formats.archive.xtinno.CompressionMethod.legacy_conversion_pre_4_2_5">legacy_conversion_pre_4_2_5</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtinno.CompressionMethod.legacy_conversion_pre_4_2_6" href="#refinery.units.formats.archive.xtinno.CompressionMethod.legacy_conversion_pre_4_2_6">legacy_conversion_pre_4_2_6</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtinno.CompressionMethod.legacy_conversion_pre_5_3_9" href="#refinery.units.formats.archive.xtinno.CompressionMethod.legacy_conversion_pre_5_3_9">legacy_conversion_pre_5_3_9</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.Architecture" href="#refinery.units.formats.archive.xtinno.Architecture">Architecture</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.PasswordType" href="#refinery.units.formats.archive.xtinno.PasswordType">PasswordType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupTypeEnum" href="#refinery.units.formats.archive.xtinno.SetupTypeEnum">SetupTypeEnum</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupFlags" href="#refinery.units.formats.archive.xtinno.SetupFlags">SetupFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.StreamCompressionMethod" href="#refinery.units.formats.archive.xtinno.StreamCompressionMethod">StreamCompressionMethod</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.StreamHeader" href="#refinery.units.formats.archive.xtinno.StreamHeader">StreamHeader</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.CrcCompressedBlock" href="#refinery.units.formats.archive.xtinno.CrcCompressedBlock">CrcCompressedBlock</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.TSetupOffsets" href="#refinery.units.formats.archive.xtinno.TSetupOffsets">TSetupOffsets</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.InnoFile" href="#refinery.units.formats.archive.xtinno.InnoFile">InnoFile</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtinno.InnoFile.check" href="#refinery.units.formats.archive.xtinno.InnoFile.check">check</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.InnoStream" href="#refinery.units.formats.archive.xtinno.InnoStream">InnoStream</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.InstallMode" href="#refinery.units.formats.archive.xtinno.InstallMode">InstallMode</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupHeader" href="#refinery.units.formats.archive.xtinno.SetupHeader">SetupHeader</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtinno.SetupHeader.get_license" href="#refinery.units.formats.archive.xtinno.SetupHeader.get_license">get_license</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtinno.SetupHeader.recode_strings" href="#refinery.units.formats.archive.xtinno.SetupHeader.recode_strings">recode_strings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.Version" href="#refinery.units.formats.archive.xtinno.Version">Version</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.WindowsVersion" href="#refinery.units.formats.archive.xtinno.WindowsVersion">WindowsVersion</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.WinVerRange" href="#refinery.units.formats.archive.xtinno.WinVerRange">WinVerRange</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.LanguageId" href="#refinery.units.formats.archive.xtinno.LanguageId">LanguageId</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupLanguage" href="#refinery.units.formats.archive.xtinno.SetupLanguage">SetupLanguage</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupMessage" href="#refinery.units.formats.archive.xtinno.SetupMessage">SetupMessage</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupType" href="#refinery.units.formats.archive.xtinno.SetupType">SetupType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupComponent" href="#refinery.units.formats.archive.xtinno.SetupComponent">SetupComponent</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupTaskFlags" href="#refinery.units.formats.archive.xtinno.SetupTaskFlags">SetupTaskFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupTask" href="#refinery.units.formats.archive.xtinno.SetupTask">SetupTask</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupCondition" href="#refinery.units.formats.archive.xtinno.SetupCondition">SetupCondition</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupDirectoryFlags" href="#refinery.units.formats.archive.xtinno.SetupDirectoryFlags">SetupDirectoryFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupDirectory" href="#refinery.units.formats.archive.xtinno.SetupDirectory">SetupDirectory</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupPermission" href="#refinery.units.formats.archive.xtinno.SetupPermission">SetupPermission</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupFileFlags" href="#refinery.units.formats.archive.xtinno.SetupFileFlags">SetupFileFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupFileType" href="#refinery.units.formats.archive.xtinno.SetupFileType">SetupFileType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupFileCopyMode" href="#refinery.units.formats.archive.xtinno.SetupFileCopyMode">SetupFileCopyMode</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupFile" href="#refinery.units.formats.archive.xtinno.SetupFile">SetupFile</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupIconCloseSetting" href="#refinery.units.formats.archive.xtinno.SetupIconCloseSetting">SetupIconCloseSetting</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupIconFlags" href="#refinery.units.formats.archive.xtinno.SetupIconFlags">SetupIconFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupIcon" href="#refinery.units.formats.archive.xtinno.SetupIcon">SetupIcon</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupIniFlags" href="#refinery.units.formats.archive.xtinno.SetupIniFlags">SetupIniFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupIniEntry" href="#refinery.units.formats.archive.xtinno.SetupIniEntry">SetupIniEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupRegistryType" href="#refinery.units.formats.archive.xtinno.SetupRegistryType">SetupRegistryType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupRegistryFlags" href="#refinery.units.formats.archive.xtinno.SetupRegistryFlags">SetupRegistryFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupRegistryEntry" href="#refinery.units.formats.archive.xtinno.SetupRegistryEntry">SetupRegistryEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupDeleteType" href="#refinery.units.formats.archive.xtinno.SetupDeleteType">SetupDeleteType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupDeleteEntry" href="#refinery.units.formats.archive.xtinno.SetupDeleteEntry">SetupDeleteEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupRunWait" href="#refinery.units.formats.archive.xtinno.SetupRunWait">SetupRunWait</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupRunFlags" href="#refinery.units.formats.archive.xtinno.SetupRunFlags">SetupRunFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupRunEntry" href="#refinery.units.formats.archive.xtinno.SetupRunEntry">SetupRunEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.TSetup" href="#refinery.units.formats.archive.xtinno.TSetup">TSetup</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupDataEntryFlags" href="#refinery.units.formats.archive.xtinno.SetupDataEntryFlags">SetupDataEntryFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupSignMode" href="#refinery.units.formats.archive.xtinno.SetupSignMode">SetupSignMode</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.SetupDataEntry" href="#refinery.units.formats.archive.xtinno.SetupDataEntry">SetupDataEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.TData" href="#refinery.units.formats.archive.xtinno.TData">TData</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.InnoParseResult" href="#refinery.units.formats.archive.xtinno.InnoParseResult">InnoParseResult</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtinno.InnoParseResult.ok" href="#refinery.units.formats.archive.xtinno.InnoParseResult.ok">ok</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtinno.xtinno" href="#refinery.units.formats.archive.xtinno.xtinno">xtinno</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtinno.xtinno.unpack" href="#refinery.units.formats.archive.xtinno.xtinno.unpack">unpack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>