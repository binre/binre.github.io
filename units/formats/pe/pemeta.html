<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>the refinery.units.formats.pe.pemeta documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats.pe.pemeta</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L1-L706" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import itertools
import json
import re

from contextlib import suppress
from importlib import resources
from datetime import timedelta
from dataclasses import dataclass
from enum import Enum

from pefile import (
    DEBUG_TYPE,
    DIRECTORY_ENTRY,
    image_characteristics,
    MACHINE_TYPE,
    SUBSYSTEM_TYPE,
    PE,
)

from refinery.lib.dotnet.header import DotNetHeader
from refinery.units import Arg, Unit
from refinery.units.sinks.ppjson import ppjson
from refinery.units.formats.pe import get_pe_size
from refinery.lib.tools import date_from_timestamp
from refinery.lib.lcid import LCID

from refinery import data


class VIT(str, Enum):
    ERR = &#39;unknown&#39;
    OBJ = &#39;object file from C&#39;
    CPP = &#39;object file from C++&#39;
    ASM = &#39;object file from assembler&#39;
    RES = &#39;object from CVTRES&#39;
    LNK = &#39;linker version&#39;
    IMP = &#39;dll import in library file&#39;
    EXP = &#39;dll export in library file&#39;

    @property
    def tag(self) -&gt; str:
        if self in (VIT.OBJ, VIT.CPP, VIT.ASM, VIT.RES):
            return &#39;object&#39;
        if self is VIT.IMP:
            return &#39;import&#39;
        if self is VIT.EXP:
            return &#39;export&#39;
        if self is VIT.LNK:
            return &#39;linker&#39;
        else:
            return &#39;unknown&#39;


@dataclass
class VersionInfo:
    pid: str
    ver: str
    err: bool

    def __str__(self):
        return F&#39;{self.ver} [{self.pid.upper()}]&#39;

    def __bool__(self):
        return not self.err


with resources.path(data, &#39;rich.json&#39;) as path:
    with path.open(&#39;r&#39;) as stream:
        RICH = json.load(stream)


class ShortPID(str, Enum):
    UTC = &#39;STDLIB&#39; # STDLIBC
    RES = &#39;CVTRES&#39; # Cvt/RES
    OMF = &#39;CVTOMF&#39; # Cvt/OMF
    PGD = &#39;CVTPGD&#39; # Cvt/PGD
    LNK = &#39;LINKER&#39; # Linker
    EXP = &#39;EXPORT&#39; # Exports
    IMP = &#39;IMPORT&#39; # Imports
    OBJ = &#39;OBJECT&#39; # Object
    PHX = &#39;PHOENX&#39; # Phoenix
    ASM = &#39;MASM&#39;   # MASM
    MIL = &#39;MSIL&#39;   # MSIL
    VB6 = &#39;VB6OBJ&#39; # VB6

    def __str__(self):
        width = max(len(item.value) for item in self.__class__)
        return F&#39;{self.value:&gt;{width}}&#39;


def get_rich_short_pid(pid: str) -&gt; ShortPID:
    pid = pid.upper()
    if pid.startswith(&#39;UTC&#39;):
        return ShortPID.UTC
    if pid.startswith(&#39;CVTRES&#39;):
        return ShortPID.RES
    if pid.startswith(&#39;CVTOMF&#39;):
        return ShortPID.OMF
    if pid.startswith(&#39;CVTPGD&#39;):
        return ShortPID.PGD
    if pid.startswith(&#39;LINKER&#39;):
        return ShortPID.LNK
    if pid.startswith(&#39;EXPORT&#39;):
        return ShortPID.EXP
    if pid.startswith(&#39;IMPORT&#39;):
        return ShortPID.IMP
    if pid.startswith(&#39;IMPLIB&#39;):
        return ShortPID.IMP
    if pid.startswith(&#39;ALIASOBJ&#39;):
        return ShortPID.OBJ
    if pid.startswith(&#39;RESOURCE&#39;):
        return ShortPID.RES
    if pid.startswith(&#39;PHX&#39;):
        return ShortPID.PHX
    if pid.startswith(&#39;PHOENIX&#39;):
        return ShortPID.PHX
    if pid.startswith(&#39;MASM&#39;):
        return ShortPID.ASM
    if pid.startswith(&#39;ILASM&#39;):
        return ShortPID.MIL
    if pid.startswith(&#39;VISUALBASIC&#39;):
        return ShortPID.VB6
    raise LookupError(pid)


def get_rich_info(vid: int) -&gt; VersionInfo:
    pid = vid &gt;&gt; 0x10
    ver = vid &amp; 0xFFFF
    ver = RICH[&#39;ver&#39;].get(F&#39;{ver:04X}&#39;)
    pid = RICH[&#39;pid&#39;].get(F&#39;{pid:04X}&#39;)
    err = ver is None and pid is None
    if ver is not None:
        suffix = ver.get(&#39;ver&#39;)
        ver = ver[&#39;ide&#39;]
        if suffix:
            ver = F&#39;{ver} {suffix}&#39;
    else:
        ver = &#39;Unknown Version&#39;
    pid = pid or &#39;Unknown Type&#39;
    return VersionInfo(pid, ver, err)


class pemeta(Unit):
    &#34;&#34;&#34;
    Extract metadata from PE files. By default, all information except for imports and exports are
    extracted.
    &#34;&#34;&#34;
    def __init__(
        self, custom : Arg(&#39;-c&#39;, &#39;--custom&#39;,
            help=&#39;Unless enabled, all default categories will be extracted.&#39;) = False,
        debug      : Arg.Switch(&#39;-D&#39;, help=&#39;Parse the PDB path from the debug directory.&#39;) = False,
        dotnet     : Arg.Switch(&#39;-N&#39;, help=&#39;Parse the .NET header.&#39;) = False,
        signatures : Arg.Switch(&#39;-S&#39;, help=&#39;Parse digital signatures.&#39;) = False,
        timestamps : Arg.Counts(&#39;-T&#39;, help=&#39;Extract time stamps. Specify twice for more detail.&#39;) = 0,
        version    : Arg.Switch(&#39;-V&#39;, help=&#39;Parse the VERSION resource.&#39;) = False,
        header     : Arg.Switch(&#39;-H&#39;, help=&#39;Parse base data from the PE header.&#39;) = False,
        exports    : Arg.Counts(&#39;-E&#39;, help=&#39;List all exported functions. Specify twice to include addresses.&#39;) = 0,
        imports    : Arg.Counts(&#39;-I&#39;, help=&#39;List all imported functions. Specify twice to include addresses.&#39;) = 0,
        tabular    : Arg.Switch(&#39;-t&#39;, help=&#39;Print information in a table rather than as JSON&#39;) = False,
        timeraw    : Arg.Switch(&#39;-r&#39;, help=&#39;Extract time stamps as numbers instead of human-readable format.&#39;) = False,
    ):
        if not custom and not any((debug, dotnet, signatures, timestamps, version, header)):
            debug = dotnet = signatures = timestamps = version = header = True
        super().__init__(
            debug=debug,
            dotnet=dotnet,
            signatures=signatures,
            timestamps=timestamps,
            version=version,
            header=header,
            imports=imports,
            exports=exports,
            timeraw=timeraw,
            tabular=tabular,
        )

    @classmethod
    def _ensure_string(cls, x):
        if not isinstance(x, str):
            x = repr(x) if not isinstance(x, bytes) else x.decode(cls.codec, &#39;backslashreplace&#39;)
        return x

    @classmethod
    def _parse_pedict(cls, bin):
        return dict((
            cls._ensure_string(key).replace(&#34; &#34;, &#34;&#34;),
            cls._ensure_string(val)
        ) for key, val in bin.items() if val)

    @classmethod
    def parse_signature(cls, data: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        time stamp and code signing certificates that are attached to the input PE file.
        &#34;&#34;&#34;
        from refinery.units.formats.pkcs7 import pkcs7

        try:
            signature = data | pkcs7 | json.loads
        except Exception as E:
            raise ValueError(F&#39;PKCS7 parser failed with error: {E!s}&#39;)

        info = {}

        def _value(doc: dict, require_type=None):
            if require_type is not None:
                if doc.get(&#39;type&#39;, None) != require_type:
                    raise LookupError
            value = doc.get(&#39;value&#39;, None)
            value = [value] if value else doc.get(&#39;values&#39;, [])
            if not value:
                raise LookupError
            return value[0]

        def find_timestamps(entry) -&gt; dict:
            if isinstance(entry, dict):
                try:
                    return {&#39;Timestamp&#39;: _value(entry, &#39;signing_time&#39;)}
                except LookupError:
                    pass
                for value in entry.values():
                    result = find_timestamps(value)
                    if result is None:
                        continue
                    with suppress(KeyError):
                        result.setdefault(&#39;TimestampIssuer&#39;, entry[&#39;sid&#39;][&#39;issuer&#39;][&#39;common_name&#39;])
                    return result
            elif isinstance(entry, list):
                for value in entry:
                    result = find_timestamps(value)
                    if result is None:
                        continue
                    return result

        timestamp_info = find_timestamps(signature)
        if timestamp_info is not None:
            info.update(timestamp_info)

        try:
            certificates = signature[&#39;content&#39;][&#39;certificates&#39;]
        except KeyError:
            return info

        if len(certificates) == 1:
            main_certificate = certificates[0]
        else:
            certificates_with_extended_use = []
            main_certificate = None
            for certificate in certificates:
                with suppress(Exception):
                    crt = certificate[&#39;tbs_certificate&#39;]
                    ext = [e for e in crt[&#39;extensions&#39;] if e[&#39;extn_id&#39;] == &#39;extended_key_usage&#39; and e[&#39;extn_value&#39;] != [&#39;time_stamping&#39;]]
                    key = [e for e in crt[&#39;extensions&#39;] if e[&#39;extn_id&#39;] == &#39;key_usage&#39;]
                    if ext:
                        certificates_with_extended_use.append(certificate)
                    if any(&#39;key_cert_sign&#39; in e[&#39;extn_value&#39;] for e in key):
                        continue
                    if any(&#39;code_signing&#39; in e[&#39;extn_value&#39;] for e in ext):
                        main_certificate = certificate
                        break
            if main_certificate is None and len(certificates_with_extended_use) == 1:
                main_certificate = certificates_with_extended_use[0]
        if main_certificate:
            crt = main_certificate[&#39;tbs_certificate&#39;]
            serial = crt[&#39;serial_number&#39;]
            if isinstance(serial, int):
                serial = F&#39;{serial:x}&#39;
            if len(serial) % 2 != 0:
                serial = F&#39;0{serial}&#39;
            assert bytes.fromhex(serial) in data
            subject = crt[&#39;subject&#39;]
            location = [subject.get(t, &#39;&#39;) for t in (&#39;locality_name&#39;, &#39;state_or_province_name&#39;, &#39;country_name&#39;)]
            info.update(Subject=subject[&#39;common_name&#39;])
            if any(location):
                info.update(SubjectLocation=&#39;, &#39;.join(filter(None, location)))
            for signer_info in signature[&#39;content&#39;].get(&#39;signer_infos&#39;, ()):
                try:
                    if signer_info[&#39;sid&#39;][&#39;serial_number&#39;] != crt[&#39;serial_number&#39;]:
                        continue
                    for attr in signer_info[&#39;signed_attrs&#39;]:
                        if attr[&#39;type&#39;] == &#39;authenticode_info&#39;:
                            auth = _value(attr)
                            info.update(ProgramName=auth[&#39;programName&#39;])
                            info.update(MoreInfo=auth[&#39;moreInfo&#39;])
                except KeyError:
                    continue
            try:
                valid_from = crt[&#39;validity&#39;][&#39;not_before&#39;]
                valid_until = crt[&#39;validity&#39;][&#39;not_after&#39;]
            except KeyError:
                pass
            else:
                info.update(ValidFrom=valid_from, ValidUntil=valid_until)
            info.update(
                Issuer=crt[&#39;issuer&#39;][&#39;common_name&#39;], Fingerprint=main_certificate[&#39;fingerprint&#39;], Serial=serial)
            return info
        return info

    def _pe_characteristics(self, pe: PE):
        return {name for name, mask in image_characteristics
            if pe.FILE_HEADER.Characteristics &amp; mask}

    def _pe_address_width(self, pe: PE, default=16) -&gt; int:
        if &#39;IMAGE_FILE_16BIT_MACHINE&#39; in self._pe_characteristics(pe):
            return 4
        elif MACHINE_TYPE[pe.FILE_HEADER.Machine] in [&#39;IMAGE_FILE_MACHINE_I386&#39;]:
            return 8
        elif MACHINE_TYPE[pe.FILE_HEADER.Machine] in [
            &#39;IMAGE_FILE_MACHINE_AMD64&#39;,
            &#39;IMAGE_FILE_MACHINE_IA64&#39;,
        ]:
            return 16
        else:
            return default

    def _vint(self, pe: PE, value: int):
        if not self.args.tabular:
            return value
        aw = self._pe_address_width(pe)
        return F&#39;0x{value:0{aw}X}&#39;

    def parse_version(self, pe: PE, data=None) -&gt; dict:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        the version resource of an input PE file, if available.
        &#34;&#34;&#34;
        pe.parse_data_directories(directories=[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]])
        string_table_entries = []
        for FileInfo in pe.FileInfo:
            for FileInfoEntry in FileInfo:
                with suppress(AttributeError):
                    for StringTableEntry in FileInfoEntry.StringTable:
                        StringTableEntryParsed = self._parse_pedict(StringTableEntry.entries)
                        with suppress(AttributeError):
                            LangID = StringTableEntry.entries.get(&#39;LangID&#39;, None) or StringTableEntry.LangID
                            LangID = int(LangID, 0x10) if not isinstance(LangID, int) else LangID
                            LangHi = LangID &gt;&gt; 0x10
                            LangLo = LangID &amp; 0xFFFF
                            Language = LCID.get(LangHi, &#39;Language Neutral&#39;)
                            Charset = self._CHARSET.get(LangLo, &#39;Unknown Charset&#39;)
                            StringTableEntryParsed.update(
                                LangID=F&#39;{LangID:08X}&#39;,
                                Charset=Charset,
                                Language=Language
                            )
                        for key in StringTableEntryParsed:
                            if key.endswith(&#39;Version&#39;):
                                value = StringTableEntryParsed[key]
                                separator = &#39;, &#39;
                                if re.match(F&#39;\\d+({re.escape(separator)}\\d+){{3}}&#39;, value):
                                    StringTableEntryParsed[key] = &#39;.&#39;.join(value.split(separator))
                        string_table_entries.append(StringTableEntryParsed)
        if not string_table_entries:
            return None
        elif len(string_table_entries) == 1:
            return string_table_entries[0]
        else:
            return string_table_entries

    def parse_exports(self, pe: PE, data=None, include_addresses=False) -&gt; list:
        pe.parse_data_directories(directories=[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;]])
        base = pe.OPTIONAL_HEADER.ImageBase
        info = []
        for k, exp in enumerate(pe.DIRECTORY_ENTRY_EXPORT.symbols):
            if not exp.name:
                name = F&#39;@{k}&#39;
            else:
                name = exp.name.decode(&#39;ascii&#39;)
            item = {&#39;Name&#39;: name, &#39;Address&#39;: self._vint(pe, exp.address + base)} if include_addresses else name
            info.append(item)
        return info

    def parse_imports(self, pe: PE, data=None, include_addresses=False) -&gt; list:
        info = {}
        dirs = []
        for name in [
            &#39;DIRECTORY_ENTRY_IMPORT&#39;,
            &#39;DIRECTORY_ENTRY_DELAY_IMPORT&#39;,
        ]:
            pe.parse_data_directories(directories=[DIRECTORY_ENTRY[F&#39;IMAGE_{name}&#39;]])
            with suppress(AttributeError):
                dirs.append(getattr(pe, name))
        self.log_warn(dirs)
        for idd in itertools.chain(*dirs):
            dll: bytes = idd.dll
            dll = dll.decode(&#39;ascii&#39;)
            if dll.lower().endswith(&#39;.dll&#39;):
                dll = dll[:~3]
            imports: list[str] = info.setdefault(dll, [])
            with suppress(AttributeError):
                symbols = idd.imports
            with suppress(AttributeError):
                symbols = idd.entries
            try:
                for imp in symbols:
                    name: bytes = imp.name
                    name = name and name.decode(&#39;ascii&#39;) or F&#39;@{imp.ordinal}&#39;
                    if not include_addresses:
                        imports.append(name)
                    else:
                        imports.append(dict(Name=name, Address=self._vint(pe, imp.address)))
            except Exception as e:
                self.log_warn(F&#39;error parsing {name}: {e!s}&#39;)
        return info

    def parse_header(self, pe: PE, data=None) -&gt; dict:
        def format_macro_name(name: str, prefix, convert=True):
            name = name.split(&#39;_&#39;)[prefix:]
            if convert:
                for k, part in enumerate(name):
                    name[k] = part.upper() if len(part) &lt;= 3 else part.capitalize()
            return &#39; &#39;.join(name)

        major = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
        minor = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
        version = self._WINVER.get(major, {0: &#39;Unknown&#39;})

        try:
            MinimumOS = version[minor]
        except LookupError:
            MinimumOS = version[0]
        header_information = {
            &#39;Machine&#39;: format_macro_name(MACHINE_TYPE[pe.FILE_HEADER.Machine], 3, False),
            &#39;Subsystem&#39;: format_macro_name(SUBSYSTEM_TYPE[pe.OPTIONAL_HEADER.Subsystem], 2),
            &#39;MinimumOS&#39;: MinimumOS,
        }

        pe.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
        ])

        try:
            export_name = pe.DIRECTORY_ENTRY_EXPORT.name
            if isinstance(export_name, bytes):
                export_name = export_name.decode(&#39;utf8&#39;)
            if not export_name.isprintable():
                export_name = None
        except Exception:
            export_name = None
        if export_name:
            header_information[&#39;ExportName&#39;] = export_name

        rich_header = pe.parse_rich_header()
        rich = []

        if rich_header:
            it = rich_header.get(&#39;values&#39;, [])
            if self.args.tabular:
                cw = max(len(F&#39;{c:d}&#39;) for c in it[1::2])
            for idv, count in zip(it[0::2], it[1::2]):
                info = get_rich_info(idv)
                if not info:
                    continue
                pid = info.pid.upper()
                if self.args.tabular:
                    short_pid = get_rich_short_pid(pid)
                    rich.append(F&#39;[{idv:08x}] {count:&gt;0{cw}d} {short_pid!s} {info.ver}&#39;)
                else:
                    rich.append({
                        &#39;Counter&#39;: count,
                        &#39;Encoded&#39;: F&#39;{idv:08x}&#39;,
                        &#39;Library&#39;: pid,
                        &#39;Product&#39;: info.ver,
                    })
            header_information[&#39;RICH&#39;] = rich

        characteristics = self._pe_characteristics(pe)
        for typespec, flag in {
            &#39;EXE&#39;: &#39;IMAGE_FILE_EXECUTABLE_IMAGE&#39;,
            &#39;DLL&#39;: &#39;IMAGE_FILE_DLL&#39;,
            &#39;SYS&#39;: &#39;IMAGE_FILE_SYSTEM&#39;
        }.items():
            if flag in characteristics:
                header_information[&#39;Type&#39;] = typespec

        base = pe.OPTIONAL_HEADER.ImageBase
        header_information[&#39;ImageBase&#39;] = self._vint(pe, base)
        header_information[&#39;ImageSize&#39;] = get_pe_size(pe)
        header_information[&#39;Bits&#39;] = 4 * self._pe_address_width(pe, 16)
        header_information[&#39;EntryPoint&#39;] = self._vint(pe, pe.OPTIONAL_HEADER.AddressOfEntryPoint + base)
        return header_information

    def parse_time_stamps(self, pe: PE, raw_time_stamps: bool, more_detail: bool) -&gt; dict:
        &#34;&#34;&#34;
        Extracts time stamps from the PE header (link time), as well as from the imports,
        exports, debug, and resource directory. The resource time stamp is also parsed as
        a DOS time stamp and returned as the &#34;Delphi&#34; time stamp.
        &#34;&#34;&#34;
        if raw_time_stamps:
            def dt(ts): return ts
        else:
            dt = date_from_timestamp

        pe.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]
        ])

        info = {}

        with suppress(AttributeError):
            info.update(Linker=dt(pe.FILE_HEADER.TimeDateStamp))

        for dir_name, _dll, info_key in [
            (&#39;DIRECTORY_ENTRY_IMPORT&#39;,       &#39;dll&#39;,  &#39;Import&#39;), # noqa
            (&#39;DIRECTORY_ENTRY_DELAY_IMPORT&#39;, &#39;dll&#39;,  &#39;Symbol&#39;), # noqa
            (&#39;DIRECTORY_ENTRY_BOUND_IMPORT&#39;, &#39;name&#39;, &#39;Module&#39;), # noqa
        ]:
            impts = {}
            for entry in getattr(pe, dir_name, []):
                ts = 0
                with suppress(AttributeError):
                    ts = entry.struct.dwTimeDateStamp
                with suppress(AttributeError):
                    ts = entry.struct.TimeDateStamp
                if ts == 0 or ts == 0xFFFFFFFF:
                    continue
                name = getattr(entry, _dll, B&#39;&#39;).decode()
                if name.lower().endswith(&#39;.dll&#39;):
                    name = name[:-4]
                impts[name] = dt(ts)
            if not impts:
                continue
            if not more_detail:
                dmin = min(impts.values())
                dmax = max(impts.values())
                small_delta = 2 * 60 * 60
                if not raw_time_stamps:
                    small_delta = timedelta(seconds=small_delta)
                if dmax - dmin &lt; small_delta:
                    impts = dmin
            info[info_key] = impts

        with suppress(AttributeError):
            Export = pe.DIRECTORY_ENTRY_EXPORT.struct.TimeDateStamp
            if Export: info.update(Export=dt(Export))

        with suppress(AttributeError):
            res_timestamp = pe.DIRECTORY_ENTRY_RESOURCE.struct.TimeDateStamp
            if res_timestamp:
                with suppress(ValueError):
                    from refinery.units.misc.datefix import datefix
                    dos = datefix.dostime(res_timestamp)
                    info.update(Delphi=dos)
                    info.update(RsrcTS=dt(res_timestamp))

        def norm(value):
            if isinstance(value, list):
                return [norm(v) for v in value]
            if isinstance(value, dict):
                return {k: norm(v) for k, v in value.items()}
            if isinstance(value, int):
                return value
            return str(value)

        return {key: norm(value) for key, value in info.items()}

    def parse_dotnet(self, pe: PE, data):
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        the .NET metadata of an input PE file.
        &#34;&#34;&#34;
        header = DotNetHeader(data, pe=pe)
        tables = header.meta.Streams.Tables
        info = dict(
            RuntimeVersion=F&#39;{header.head.MajorRuntimeVersion}.{header.head.MinorRuntimeVersion}&#39;,
            Version=F&#39;{header.meta.MajorVersion}.{header.meta.MinorVersion}&#39;,
            VersionString=header.meta.VersionString
        )

        info[&#39;Flags&#39;] = [name for name, check in header.head.KnownFlags.items() if check]

        if len(tables.Assembly) == 1:
            assembly = tables.Assembly[0]
            info.update(
                AssemblyName=assembly.Name,
                Release=&#39;{}.{}.{}.{}&#39;.format(
                    assembly.MajorVersion,
                    assembly.MinorVersion,
                    assembly.BuildNumber,
                    assembly.RevisionNumber
                )
            )

        try:
            entry = self._vint(pe, header.head.EntryPointToken + pe.OPTIONAL_HEADER.ImageBase)
            info.update(EntryPoint=entry)
        except AttributeError:
            pass

        if len(tables.Module) == 1:
            module = tables.Module[0]
            info.update(ModuleName=module.Name)

        return info

    def parse_debug(self, pe: PE, data=None):
        result = {}
        pe.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;]])
        for dbg in pe.DIRECTORY_ENTRY_DEBUG:
            if DEBUG_TYPE.get(dbg.struct.Type, None) != &#39;IMAGE_DEBUG_TYPE_CODEVIEW&#39;:
                continue
            with suppress(Exception):
                pdb = dbg.entry.PdbFileName
                if 0 in pdb:
                    pdb = pdb[:pdb.index(0)]
                result.update(
                    PdbPath=pdb.decode(self.codec),
                    PdbAge=dbg.entry.Age
                )
        return result

    def process(self, data):
        result = {}
        pe = PE(data=data, fast_load=True)

        for switch, resolver, name in [
            (self.args.debug,   self.parse_debug,    &#39;Debug&#39;),    # noqa
            (self.args.dotnet,  self.parse_dotnet,   &#39;DotNet&#39;),   # noqa
            (self.args.header,  self.parse_header,   &#39;Header&#39;),   # noqa
            (self.args.version, self.parse_version,  &#39;Version&#39;),  # noqa
            (self.args.imports, self.parse_imports,  &#39;Imports&#39;),  # noqa
            (self.args.exports, self.parse_exports,  &#39;Exports&#39;),  # noqa
        ]:
            if not switch:
                continue
            self.log_debug(F&#39;parsing: {name}&#39;)
            args = pe, data
            if switch &gt; 1:
                args = *args, True
            try:
                info = resolver(*args)
            except Exception as E:
                self.log_info(F&#39;failed to obtain {name}: {E!s}&#39;)
                continue
            if info:
                result[name] = info

        signature = {}

        if self.args.timestamps or self.args.signatures:
            with suppress(Exception):
                from refinery.units.formats.pe.pesig import pesig
                signature = self.parse_signature(next(data | pesig))

        if self.args.timestamps:
            ts = self.parse_time_stamps(pe, self.args.timeraw, self.args.timestamps &gt; 1)
            with suppress(KeyError):
                ts.update(Signed=signature[&#39;Timestamp&#39;])
            result.update(TimeStamp=ts)

        if signature and self.args.signatures:
            result[&#39;Signature&#39;] = signature

        if result:
            yield from ppjson(tabular=self.args.tabular)._pretty_output(result, indent=4, ensure_ascii=False)

    _CHARSET = {
        0x0000: &#39;7-bit ASCII&#39;,
        0x03A4: &#39;Japan (Shift ? JIS X-0208)&#39;,
        0x03B5: &#39;Korea (Shift ? KSC 5601)&#39;,
        0x03B6: &#39;Taiwan (Big5)&#39;,
        0x04B0: &#39;Unicode&#39;,
        0x04E2: &#39;Latin-2 (Eastern European)&#39;,
        0x04E3: &#39;Cyrillic&#39;,
        0x04E4: &#39;Multilingual&#39;,
        0x04E5: &#39;Greek&#39;,
        0x04E6: &#39;Turkish&#39;,
        0x04E7: &#39;Hebrew&#39;,
        0x04E8: &#39;Arabic&#39;,
    }

    _WINVER = {
        3: {
            0x00: &#39;Windows NT 3&#39;,
            0x0A: &#39;Windows NT 3.1&#39;,
            0x32: &#39;Windows NT 3.5&#39;,
            0x33: &#39;Windows NT 3.51&#39;,
        },
        4: {
            0x00: &#39;Windows 95&#39;,
            0x0A: &#39;Windows 98&#39;,
        },
        5: {
            0x00: &#39;Windows 2000&#39;,
            0x5A: &#39;Windows Me&#39;,
            0x01: &#39;Windows XP&#39;,
            0x02: &#39;Windows Server 2003&#39;,
        },
        6: {
            0x00: &#39;Windows Vista&#39;,
            0x01: &#39;Windows 7&#39;,
            0x02: &#39;Windows 8&#39;,
            0x03: &#39;Windows 8.1&#39;,
        },
        10: {
            0x00: &#39;Windows 10&#39;,
        }
    }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.units.formats.pe.pemeta.get_rich_short_pid"><code class="name flex">
<span>def <span class="ident">get_rich_short_pid</span></span>(<span>pid)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L93-L125" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_rich_short_pid(pid: str) -&gt; ShortPID:
    pid = pid.upper()
    if pid.startswith(&#39;UTC&#39;):
        return ShortPID.UTC
    if pid.startswith(&#39;CVTRES&#39;):
        return ShortPID.RES
    if pid.startswith(&#39;CVTOMF&#39;):
        return ShortPID.OMF
    if pid.startswith(&#39;CVTPGD&#39;):
        return ShortPID.PGD
    if pid.startswith(&#39;LINKER&#39;):
        return ShortPID.LNK
    if pid.startswith(&#39;EXPORT&#39;):
        return ShortPID.EXP
    if pid.startswith(&#39;IMPORT&#39;):
        return ShortPID.IMP
    if pid.startswith(&#39;IMPLIB&#39;):
        return ShortPID.IMP
    if pid.startswith(&#39;ALIASOBJ&#39;):
        return ShortPID.OBJ
    if pid.startswith(&#39;RESOURCE&#39;):
        return ShortPID.RES
    if pid.startswith(&#39;PHX&#39;):
        return ShortPID.PHX
    if pid.startswith(&#39;PHOENIX&#39;):
        return ShortPID.PHX
    if pid.startswith(&#39;MASM&#39;):
        return ShortPID.ASM
    if pid.startswith(&#39;ILASM&#39;):
        return ShortPID.MIL
    if pid.startswith(&#39;VISUALBASIC&#39;):
        return ShortPID.VB6
    raise LookupError(pid)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.get_rich_info"><code class="name flex">
<span>def <span class="ident">get_rich_info</span></span>(<span>vid)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L128-L142" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_rich_info(vid: int) -&gt; VersionInfo:
    pid = vid &gt;&gt; 0x10
    ver = vid &amp; 0xFFFF
    ver = RICH[&#39;ver&#39;].get(F&#39;{ver:04X}&#39;)
    pid = RICH[&#39;pid&#39;].get(F&#39;{pid:04X}&#39;)
    err = ver is None and pid is None
    if ver is not None:
        suffix = ver.get(&#39;ver&#39;)
        ver = ver[&#39;ide&#39;]
        if suffix:
            ver = F&#39;{ver} {suffix}&#39;
    else:
        ver = &#39;Unknown Version&#39;
    pid = pid or &#39;Unknown Type&#39;
    return VersionInfo(pid, ver, err)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.pe.pemeta.VIT"><code class="flex name class">
<span>class <span class="ident">VIT</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L32-L53" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VIT(str, Enum):
    ERR = &#39;unknown&#39;
    OBJ = &#39;object file from C&#39;
    CPP = &#39;object file from C++&#39;
    ASM = &#39;object file from assembler&#39;
    RES = &#39;object from CVTRES&#39;
    LNK = &#39;linker version&#39;
    IMP = &#39;dll import in library file&#39;
    EXP = &#39;dll export in library file&#39;

    @property
    def tag(self) -&gt; str:
        if self in (VIT.OBJ, VIT.CPP, VIT.ASM, VIT.RES):
            return &#39;object&#39;
        if self is VIT.IMP:
            return &#39;import&#39;
        if self is VIT.EXP:
            return &#39;export&#39;
        if self is VIT.LNK:
            return &#39;linker&#39;
        else:
            return &#39;unknown&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.VIT.ERR"><code class="name">var <span class="ident">ERR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.OBJ"><code class="name">var <span class="ident">OBJ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.CPP"><code class="name">var <span class="ident">CPP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.ASM"><code class="name">var <span class="ident">ASM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.RES"><code class="name">var <span class="ident">RES</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.LNK"><code class="name">var <span class="ident">LNK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.IMP"><code class="name">var <span class="ident">IMP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.EXP"><code class="name">var <span class="ident">EXP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.VIT.tag"><code class="name">var <span class="ident">tag</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L42-L53" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def tag(self) -&gt; str:
    if self in (VIT.OBJ, VIT.CPP, VIT.ASM, VIT.RES):
        return &#39;object&#39;
    if self is VIT.IMP:
        return &#39;import&#39;
    if self is VIT.EXP:
        return &#39;export&#39;
    if self is VIT.LNK:
        return &#39;linker&#39;
    else:
        return &#39;unknown&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VersionInfo"><code class="flex name class">
<span>class <span class="ident">VersionInfo</span></span>
<span>(</span><span>pid, ver, err)</span>
</code></dt>
<dd>
<section class="desc"><p>VersionInfo(pid: str, ver: str, err: bool)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L57-L66" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VersionInfo:
    pid: str
    ver: str
    err: bool

    def __str__(self):
        return F&#39;{self.ver} [{self.pid.upper()}]&#39;

    def __bool__(self):
        return not self.err</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.VersionInfo.pid"><code class="name">var <span class="ident">pid</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VersionInfo.ver"><code class="name">var <span class="ident">ver</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VersionInfo.err"><code class="name">var <span class="ident">err</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID"><code class="flex name class">
<span>class <span class="ident">ShortPID</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L74-L90" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ShortPID(str, Enum):
    UTC = &#39;STDLIB&#39; # STDLIBC
    RES = &#39;CVTRES&#39; # Cvt/RES
    OMF = &#39;CVTOMF&#39; # Cvt/OMF
    PGD = &#39;CVTPGD&#39; # Cvt/PGD
    LNK = &#39;LINKER&#39; # Linker
    EXP = &#39;EXPORT&#39; # Exports
    IMP = &#39;IMPORT&#39; # Imports
    OBJ = &#39;OBJECT&#39; # Object
    PHX = &#39;PHOENX&#39; # Phoenix
    ASM = &#39;MASM&#39;   # MASM
    MIL = &#39;MSIL&#39;   # MSIL
    VB6 = &#39;VB6OBJ&#39; # VB6

    def __str__(self):
        width = max(len(item.value) for item in self.__class__)
        return F&#39;{self.value:&gt;{width}}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.UTC"><code class="name">var <span class="ident">UTC</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.RES"><code class="name">var <span class="ident">RES</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.OMF"><code class="name">var <span class="ident">OMF</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.PGD"><code class="name">var <span class="ident">PGD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.LNK"><code class="name">var <span class="ident">LNK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.EXP"><code class="name">var <span class="ident">EXP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.IMP"><code class="name">var <span class="ident">IMP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.OBJ"><code class="name">var <span class="ident">OBJ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.PHX"><code class="name">var <span class="ident">PHX</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.ASM"><code class="name">var <span class="ident">ASM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.MIL"><code class="name">var <span class="ident">MIL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.VB6"><code class="name">var <span class="ident">VB6</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta"><code class="flex name class">
<span>class <span class="ident">pemeta</span></span>
<span>(</span><span>custom=False, debug=False, dotnet=False, signatures=False, timestamps=0, version=False, header=False, exports=0, imports=0, tabular=False, timeraw=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Extract metadata from PE files. By default, all information except for imports and exports are
extracted.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L145-L706" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class pemeta(Unit):
    &#34;&#34;&#34;
    Extract metadata from PE files. By default, all information except for imports and exports are
    extracted.
    &#34;&#34;&#34;
    def __init__(
        self, custom : Arg(&#39;-c&#39;, &#39;--custom&#39;,
            help=&#39;Unless enabled, all default categories will be extracted.&#39;) = False,
        debug      : Arg.Switch(&#39;-D&#39;, help=&#39;Parse the PDB path from the debug directory.&#39;) = False,
        dotnet     : Arg.Switch(&#39;-N&#39;, help=&#39;Parse the .NET header.&#39;) = False,
        signatures : Arg.Switch(&#39;-S&#39;, help=&#39;Parse digital signatures.&#39;) = False,
        timestamps : Arg.Counts(&#39;-T&#39;, help=&#39;Extract time stamps. Specify twice for more detail.&#39;) = 0,
        version    : Arg.Switch(&#39;-V&#39;, help=&#39;Parse the VERSION resource.&#39;) = False,
        header     : Arg.Switch(&#39;-H&#39;, help=&#39;Parse base data from the PE header.&#39;) = False,
        exports    : Arg.Counts(&#39;-E&#39;, help=&#39;List all exported functions. Specify twice to include addresses.&#39;) = 0,
        imports    : Arg.Counts(&#39;-I&#39;, help=&#39;List all imported functions. Specify twice to include addresses.&#39;) = 0,
        tabular    : Arg.Switch(&#39;-t&#39;, help=&#39;Print information in a table rather than as JSON&#39;) = False,
        timeraw    : Arg.Switch(&#39;-r&#39;, help=&#39;Extract time stamps as numbers instead of human-readable format.&#39;) = False,
    ):
        if not custom and not any((debug, dotnet, signatures, timestamps, version, header)):
            debug = dotnet = signatures = timestamps = version = header = True
        super().__init__(
            debug=debug,
            dotnet=dotnet,
            signatures=signatures,
            timestamps=timestamps,
            version=version,
            header=header,
            imports=imports,
            exports=exports,
            timeraw=timeraw,
            tabular=tabular,
        )

    @classmethod
    def _ensure_string(cls, x):
        if not isinstance(x, str):
            x = repr(x) if not isinstance(x, bytes) else x.decode(cls.codec, &#39;backslashreplace&#39;)
        return x

    @classmethod
    def _parse_pedict(cls, bin):
        return dict((
            cls._ensure_string(key).replace(&#34; &#34;, &#34;&#34;),
            cls._ensure_string(val)
        ) for key, val in bin.items() if val)

    @classmethod
    def parse_signature(cls, data: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        time stamp and code signing certificates that are attached to the input PE file.
        &#34;&#34;&#34;
        from refinery.units.formats.pkcs7 import pkcs7

        try:
            signature = data | pkcs7 | json.loads
        except Exception as E:
            raise ValueError(F&#39;PKCS7 parser failed with error: {E!s}&#39;)

        info = {}

        def _value(doc: dict, require_type=None):
            if require_type is not None:
                if doc.get(&#39;type&#39;, None) != require_type:
                    raise LookupError
            value = doc.get(&#39;value&#39;, None)
            value = [value] if value else doc.get(&#39;values&#39;, [])
            if not value:
                raise LookupError
            return value[0]

        def find_timestamps(entry) -&gt; dict:
            if isinstance(entry, dict):
                try:
                    return {&#39;Timestamp&#39;: _value(entry, &#39;signing_time&#39;)}
                except LookupError:
                    pass
                for value in entry.values():
                    result = find_timestamps(value)
                    if result is None:
                        continue
                    with suppress(KeyError):
                        result.setdefault(&#39;TimestampIssuer&#39;, entry[&#39;sid&#39;][&#39;issuer&#39;][&#39;common_name&#39;])
                    return result
            elif isinstance(entry, list):
                for value in entry:
                    result = find_timestamps(value)
                    if result is None:
                        continue
                    return result

        timestamp_info = find_timestamps(signature)
        if timestamp_info is not None:
            info.update(timestamp_info)

        try:
            certificates = signature[&#39;content&#39;][&#39;certificates&#39;]
        except KeyError:
            return info

        if len(certificates) == 1:
            main_certificate = certificates[0]
        else:
            certificates_with_extended_use = []
            main_certificate = None
            for certificate in certificates:
                with suppress(Exception):
                    crt = certificate[&#39;tbs_certificate&#39;]
                    ext = [e for e in crt[&#39;extensions&#39;] if e[&#39;extn_id&#39;] == &#39;extended_key_usage&#39; and e[&#39;extn_value&#39;] != [&#39;time_stamping&#39;]]
                    key = [e for e in crt[&#39;extensions&#39;] if e[&#39;extn_id&#39;] == &#39;key_usage&#39;]
                    if ext:
                        certificates_with_extended_use.append(certificate)
                    if any(&#39;key_cert_sign&#39; in e[&#39;extn_value&#39;] for e in key):
                        continue
                    if any(&#39;code_signing&#39; in e[&#39;extn_value&#39;] for e in ext):
                        main_certificate = certificate
                        break
            if main_certificate is None and len(certificates_with_extended_use) == 1:
                main_certificate = certificates_with_extended_use[0]
        if main_certificate:
            crt = main_certificate[&#39;tbs_certificate&#39;]
            serial = crt[&#39;serial_number&#39;]
            if isinstance(serial, int):
                serial = F&#39;{serial:x}&#39;
            if len(serial) % 2 != 0:
                serial = F&#39;0{serial}&#39;
            assert bytes.fromhex(serial) in data
            subject = crt[&#39;subject&#39;]
            location = [subject.get(t, &#39;&#39;) for t in (&#39;locality_name&#39;, &#39;state_or_province_name&#39;, &#39;country_name&#39;)]
            info.update(Subject=subject[&#39;common_name&#39;])
            if any(location):
                info.update(SubjectLocation=&#39;, &#39;.join(filter(None, location)))
            for signer_info in signature[&#39;content&#39;].get(&#39;signer_infos&#39;, ()):
                try:
                    if signer_info[&#39;sid&#39;][&#39;serial_number&#39;] != crt[&#39;serial_number&#39;]:
                        continue
                    for attr in signer_info[&#39;signed_attrs&#39;]:
                        if attr[&#39;type&#39;] == &#39;authenticode_info&#39;:
                            auth = _value(attr)
                            info.update(ProgramName=auth[&#39;programName&#39;])
                            info.update(MoreInfo=auth[&#39;moreInfo&#39;])
                except KeyError:
                    continue
            try:
                valid_from = crt[&#39;validity&#39;][&#39;not_before&#39;]
                valid_until = crt[&#39;validity&#39;][&#39;not_after&#39;]
            except KeyError:
                pass
            else:
                info.update(ValidFrom=valid_from, ValidUntil=valid_until)
            info.update(
                Issuer=crt[&#39;issuer&#39;][&#39;common_name&#39;], Fingerprint=main_certificate[&#39;fingerprint&#39;], Serial=serial)
            return info
        return info

    def _pe_characteristics(self, pe: PE):
        return {name for name, mask in image_characteristics
            if pe.FILE_HEADER.Characteristics &amp; mask}

    def _pe_address_width(self, pe: PE, default=16) -&gt; int:
        if &#39;IMAGE_FILE_16BIT_MACHINE&#39; in self._pe_characteristics(pe):
            return 4
        elif MACHINE_TYPE[pe.FILE_HEADER.Machine] in [&#39;IMAGE_FILE_MACHINE_I386&#39;]:
            return 8
        elif MACHINE_TYPE[pe.FILE_HEADER.Machine] in [
            &#39;IMAGE_FILE_MACHINE_AMD64&#39;,
            &#39;IMAGE_FILE_MACHINE_IA64&#39;,
        ]:
            return 16
        else:
            return default

    def _vint(self, pe: PE, value: int):
        if not self.args.tabular:
            return value
        aw = self._pe_address_width(pe)
        return F&#39;0x{value:0{aw}X}&#39;

    def parse_version(self, pe: PE, data=None) -&gt; dict:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        the version resource of an input PE file, if available.
        &#34;&#34;&#34;
        pe.parse_data_directories(directories=[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]])
        string_table_entries = []
        for FileInfo in pe.FileInfo:
            for FileInfoEntry in FileInfo:
                with suppress(AttributeError):
                    for StringTableEntry in FileInfoEntry.StringTable:
                        StringTableEntryParsed = self._parse_pedict(StringTableEntry.entries)
                        with suppress(AttributeError):
                            LangID = StringTableEntry.entries.get(&#39;LangID&#39;, None) or StringTableEntry.LangID
                            LangID = int(LangID, 0x10) if not isinstance(LangID, int) else LangID
                            LangHi = LangID &gt;&gt; 0x10
                            LangLo = LangID &amp; 0xFFFF
                            Language = LCID.get(LangHi, &#39;Language Neutral&#39;)
                            Charset = self._CHARSET.get(LangLo, &#39;Unknown Charset&#39;)
                            StringTableEntryParsed.update(
                                LangID=F&#39;{LangID:08X}&#39;,
                                Charset=Charset,
                                Language=Language
                            )
                        for key in StringTableEntryParsed:
                            if key.endswith(&#39;Version&#39;):
                                value = StringTableEntryParsed[key]
                                separator = &#39;, &#39;
                                if re.match(F&#39;\\d+({re.escape(separator)}\\d+){{3}}&#39;, value):
                                    StringTableEntryParsed[key] = &#39;.&#39;.join(value.split(separator))
                        string_table_entries.append(StringTableEntryParsed)
        if not string_table_entries:
            return None
        elif len(string_table_entries) == 1:
            return string_table_entries[0]
        else:
            return string_table_entries

    def parse_exports(self, pe: PE, data=None, include_addresses=False) -&gt; list:
        pe.parse_data_directories(directories=[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;]])
        base = pe.OPTIONAL_HEADER.ImageBase
        info = []
        for k, exp in enumerate(pe.DIRECTORY_ENTRY_EXPORT.symbols):
            if not exp.name:
                name = F&#39;@{k}&#39;
            else:
                name = exp.name.decode(&#39;ascii&#39;)
            item = {&#39;Name&#39;: name, &#39;Address&#39;: self._vint(pe, exp.address + base)} if include_addresses else name
            info.append(item)
        return info

    def parse_imports(self, pe: PE, data=None, include_addresses=False) -&gt; list:
        info = {}
        dirs = []
        for name in [
            &#39;DIRECTORY_ENTRY_IMPORT&#39;,
            &#39;DIRECTORY_ENTRY_DELAY_IMPORT&#39;,
        ]:
            pe.parse_data_directories(directories=[DIRECTORY_ENTRY[F&#39;IMAGE_{name}&#39;]])
            with suppress(AttributeError):
                dirs.append(getattr(pe, name))
        self.log_warn(dirs)
        for idd in itertools.chain(*dirs):
            dll: bytes = idd.dll
            dll = dll.decode(&#39;ascii&#39;)
            if dll.lower().endswith(&#39;.dll&#39;):
                dll = dll[:~3]
            imports: list[str] = info.setdefault(dll, [])
            with suppress(AttributeError):
                symbols = idd.imports
            with suppress(AttributeError):
                symbols = idd.entries
            try:
                for imp in symbols:
                    name: bytes = imp.name
                    name = name and name.decode(&#39;ascii&#39;) or F&#39;@{imp.ordinal}&#39;
                    if not include_addresses:
                        imports.append(name)
                    else:
                        imports.append(dict(Name=name, Address=self._vint(pe, imp.address)))
            except Exception as e:
                self.log_warn(F&#39;error parsing {name}: {e!s}&#39;)
        return info

    def parse_header(self, pe: PE, data=None) -&gt; dict:
        def format_macro_name(name: str, prefix, convert=True):
            name = name.split(&#39;_&#39;)[prefix:]
            if convert:
                for k, part in enumerate(name):
                    name[k] = part.upper() if len(part) &lt;= 3 else part.capitalize()
            return &#39; &#39;.join(name)

        major = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
        minor = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
        version = self._WINVER.get(major, {0: &#39;Unknown&#39;})

        try:
            MinimumOS = version[minor]
        except LookupError:
            MinimumOS = version[0]
        header_information = {
            &#39;Machine&#39;: format_macro_name(MACHINE_TYPE[pe.FILE_HEADER.Machine], 3, False),
            &#39;Subsystem&#39;: format_macro_name(SUBSYSTEM_TYPE[pe.OPTIONAL_HEADER.Subsystem], 2),
            &#39;MinimumOS&#39;: MinimumOS,
        }

        pe.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
        ])

        try:
            export_name = pe.DIRECTORY_ENTRY_EXPORT.name
            if isinstance(export_name, bytes):
                export_name = export_name.decode(&#39;utf8&#39;)
            if not export_name.isprintable():
                export_name = None
        except Exception:
            export_name = None
        if export_name:
            header_information[&#39;ExportName&#39;] = export_name

        rich_header = pe.parse_rich_header()
        rich = []

        if rich_header:
            it = rich_header.get(&#39;values&#39;, [])
            if self.args.tabular:
                cw = max(len(F&#39;{c:d}&#39;) for c in it[1::2])
            for idv, count in zip(it[0::2], it[1::2]):
                info = get_rich_info(idv)
                if not info:
                    continue
                pid = info.pid.upper()
                if self.args.tabular:
                    short_pid = get_rich_short_pid(pid)
                    rich.append(F&#39;[{idv:08x}] {count:&gt;0{cw}d} {short_pid!s} {info.ver}&#39;)
                else:
                    rich.append({
                        &#39;Counter&#39;: count,
                        &#39;Encoded&#39;: F&#39;{idv:08x}&#39;,
                        &#39;Library&#39;: pid,
                        &#39;Product&#39;: info.ver,
                    })
            header_information[&#39;RICH&#39;] = rich

        characteristics = self._pe_characteristics(pe)
        for typespec, flag in {
            &#39;EXE&#39;: &#39;IMAGE_FILE_EXECUTABLE_IMAGE&#39;,
            &#39;DLL&#39;: &#39;IMAGE_FILE_DLL&#39;,
            &#39;SYS&#39;: &#39;IMAGE_FILE_SYSTEM&#39;
        }.items():
            if flag in characteristics:
                header_information[&#39;Type&#39;] = typespec

        base = pe.OPTIONAL_HEADER.ImageBase
        header_information[&#39;ImageBase&#39;] = self._vint(pe, base)
        header_information[&#39;ImageSize&#39;] = get_pe_size(pe)
        header_information[&#39;Bits&#39;] = 4 * self._pe_address_width(pe, 16)
        header_information[&#39;EntryPoint&#39;] = self._vint(pe, pe.OPTIONAL_HEADER.AddressOfEntryPoint + base)
        return header_information

    def parse_time_stamps(self, pe: PE, raw_time_stamps: bool, more_detail: bool) -&gt; dict:
        &#34;&#34;&#34;
        Extracts time stamps from the PE header (link time), as well as from the imports,
        exports, debug, and resource directory. The resource time stamp is also parsed as
        a DOS time stamp and returned as the &#34;Delphi&#34; time stamp.
        &#34;&#34;&#34;
        if raw_time_stamps:
            def dt(ts): return ts
        else:
            dt = date_from_timestamp

        pe.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]
        ])

        info = {}

        with suppress(AttributeError):
            info.update(Linker=dt(pe.FILE_HEADER.TimeDateStamp))

        for dir_name, _dll, info_key in [
            (&#39;DIRECTORY_ENTRY_IMPORT&#39;,       &#39;dll&#39;,  &#39;Import&#39;), # noqa
            (&#39;DIRECTORY_ENTRY_DELAY_IMPORT&#39;, &#39;dll&#39;,  &#39;Symbol&#39;), # noqa
            (&#39;DIRECTORY_ENTRY_BOUND_IMPORT&#39;, &#39;name&#39;, &#39;Module&#39;), # noqa
        ]:
            impts = {}
            for entry in getattr(pe, dir_name, []):
                ts = 0
                with suppress(AttributeError):
                    ts = entry.struct.dwTimeDateStamp
                with suppress(AttributeError):
                    ts = entry.struct.TimeDateStamp
                if ts == 0 or ts == 0xFFFFFFFF:
                    continue
                name = getattr(entry, _dll, B&#39;&#39;).decode()
                if name.lower().endswith(&#39;.dll&#39;):
                    name = name[:-4]
                impts[name] = dt(ts)
            if not impts:
                continue
            if not more_detail:
                dmin = min(impts.values())
                dmax = max(impts.values())
                small_delta = 2 * 60 * 60
                if not raw_time_stamps:
                    small_delta = timedelta(seconds=small_delta)
                if dmax - dmin &lt; small_delta:
                    impts = dmin
            info[info_key] = impts

        with suppress(AttributeError):
            Export = pe.DIRECTORY_ENTRY_EXPORT.struct.TimeDateStamp
            if Export: info.update(Export=dt(Export))

        with suppress(AttributeError):
            res_timestamp = pe.DIRECTORY_ENTRY_RESOURCE.struct.TimeDateStamp
            if res_timestamp:
                with suppress(ValueError):
                    from refinery.units.misc.datefix import datefix
                    dos = datefix.dostime(res_timestamp)
                    info.update(Delphi=dos)
                    info.update(RsrcTS=dt(res_timestamp))

        def norm(value):
            if isinstance(value, list):
                return [norm(v) for v in value]
            if isinstance(value, dict):
                return {k: norm(v) for k, v in value.items()}
            if isinstance(value, int):
                return value
            return str(value)

        return {key: norm(value) for key, value in info.items()}

    def parse_dotnet(self, pe: PE, data):
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        the .NET metadata of an input PE file.
        &#34;&#34;&#34;
        header = DotNetHeader(data, pe=pe)
        tables = header.meta.Streams.Tables
        info = dict(
            RuntimeVersion=F&#39;{header.head.MajorRuntimeVersion}.{header.head.MinorRuntimeVersion}&#39;,
            Version=F&#39;{header.meta.MajorVersion}.{header.meta.MinorVersion}&#39;,
            VersionString=header.meta.VersionString
        )

        info[&#39;Flags&#39;] = [name for name, check in header.head.KnownFlags.items() if check]

        if len(tables.Assembly) == 1:
            assembly = tables.Assembly[0]
            info.update(
                AssemblyName=assembly.Name,
                Release=&#39;{}.{}.{}.{}&#39;.format(
                    assembly.MajorVersion,
                    assembly.MinorVersion,
                    assembly.BuildNumber,
                    assembly.RevisionNumber
                )
            )

        try:
            entry = self._vint(pe, header.head.EntryPointToken + pe.OPTIONAL_HEADER.ImageBase)
            info.update(EntryPoint=entry)
        except AttributeError:
            pass

        if len(tables.Module) == 1:
            module = tables.Module[0]
            info.update(ModuleName=module.Name)

        return info

    def parse_debug(self, pe: PE, data=None):
        result = {}
        pe.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;]])
        for dbg in pe.DIRECTORY_ENTRY_DEBUG:
            if DEBUG_TYPE.get(dbg.struct.Type, None) != &#39;IMAGE_DEBUG_TYPE_CODEVIEW&#39;:
                continue
            with suppress(Exception):
                pdb = dbg.entry.PdbFileName
                if 0 in pdb:
                    pdb = pdb[:pdb.index(0)]
                result.update(
                    PdbPath=pdb.decode(self.codec),
                    PdbAge=dbg.entry.Age
                )
        return result

    def process(self, data):
        result = {}
        pe = PE(data=data, fast_load=True)

        for switch, resolver, name in [
            (self.args.debug,   self.parse_debug,    &#39;Debug&#39;),    # noqa
            (self.args.dotnet,  self.parse_dotnet,   &#39;DotNet&#39;),   # noqa
            (self.args.header,  self.parse_header,   &#39;Header&#39;),   # noqa
            (self.args.version, self.parse_version,  &#39;Version&#39;),  # noqa
            (self.args.imports, self.parse_imports,  &#39;Imports&#39;),  # noqa
            (self.args.exports, self.parse_exports,  &#39;Exports&#39;),  # noqa
        ]:
            if not switch:
                continue
            self.log_debug(F&#39;parsing: {name}&#39;)
            args = pe, data
            if switch &gt; 1:
                args = *args, True
            try:
                info = resolver(*args)
            except Exception as E:
                self.log_info(F&#39;failed to obtain {name}: {E!s}&#39;)
                continue
            if info:
                result[name] = info

        signature = {}

        if self.args.timestamps or self.args.signatures:
            with suppress(Exception):
                from refinery.units.formats.pe.pesig import pesig
                signature = self.parse_signature(next(data | pesig))

        if self.args.timestamps:
            ts = self.parse_time_stamps(pe, self.args.timeraw, self.args.timestamps &gt; 1)
            with suppress(KeyError):
                ts.update(Signed=signature[&#39;Timestamp&#39;])
            result.update(TimeStamp=ts)

        if signature and self.args.signatures:
            result[&#39;Signature&#39;] = signature

        if result:
            yield from ppjson(tabular=self.args.tabular)._pretty_output(result, indent=4, ensure_ascii=False)

    _CHARSET = {
        0x0000: &#39;7-bit ASCII&#39;,
        0x03A4: &#39;Japan (Shift ? JIS X-0208)&#39;,
        0x03B5: &#39;Korea (Shift ? KSC 5601)&#39;,
        0x03B6: &#39;Taiwan (Big5)&#39;,
        0x04B0: &#39;Unicode&#39;,
        0x04E2: &#39;Latin-2 (Eastern European)&#39;,
        0x04E3: &#39;Cyrillic&#39;,
        0x04E4: &#39;Multilingual&#39;,
        0x04E5: &#39;Greek&#39;,
        0x04E6: &#39;Turkish&#39;,
        0x04E7: &#39;Hebrew&#39;,
        0x04E8: &#39;Arabic&#39;,
    }

    _WINVER = {
        3: {
            0x00: &#39;Windows NT 3&#39;,
            0x0A: &#39;Windows NT 3.1&#39;,
            0x32: &#39;Windows NT 3.5&#39;,
            0x33: &#39;Windows NT 3.51&#39;,
        },
        4: {
            0x00: &#39;Windows 95&#39;,
            0x0A: &#39;Windows 98&#39;,
        },
        5: {
            0x00: &#39;Windows 2000&#39;,
            0x5A: &#39;Windows Me&#39;,
            0x01: &#39;Windows XP&#39;,
            0x02: &#39;Windows Server 2003&#39;,
        },
        6: {
            0x00: &#39;Windows Vista&#39;,
            0x01: &#39;Windows 7&#39;,
            0x02: &#39;Windows 8&#39;,
            0x03: &#39;Windows 8.1&#39;,
        },
        10: {
            0x00: &#39;Windows 10&#39;,
        }
    }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.pemeta.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_signature"><code class="name flex">
<span>def <span class="ident">parse_signature</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts a JSON-serializable and human-readable dictionary with information about
time stamp and code signing certificates that are attached to the input PE file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L192-L299" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def parse_signature(cls, data: bytearray) -&gt; dict:
    &#34;&#34;&#34;
    Extracts a JSON-serializable and human-readable dictionary with information about
    time stamp and code signing certificates that are attached to the input PE file.
    &#34;&#34;&#34;
    from refinery.units.formats.pkcs7 import pkcs7

    try:
        signature = data | pkcs7 | json.loads
    except Exception as E:
        raise ValueError(F&#39;PKCS7 parser failed with error: {E!s}&#39;)

    info = {}

    def _value(doc: dict, require_type=None):
        if require_type is not None:
            if doc.get(&#39;type&#39;, None) != require_type:
                raise LookupError
        value = doc.get(&#39;value&#39;, None)
        value = [value] if value else doc.get(&#39;values&#39;, [])
        if not value:
            raise LookupError
        return value[0]

    def find_timestamps(entry) -&gt; dict:
        if isinstance(entry, dict):
            try:
                return {&#39;Timestamp&#39;: _value(entry, &#39;signing_time&#39;)}
            except LookupError:
                pass
            for value in entry.values():
                result = find_timestamps(value)
                if result is None:
                    continue
                with suppress(KeyError):
                    result.setdefault(&#39;TimestampIssuer&#39;, entry[&#39;sid&#39;][&#39;issuer&#39;][&#39;common_name&#39;])
                return result
        elif isinstance(entry, list):
            for value in entry:
                result = find_timestamps(value)
                if result is None:
                    continue
                return result

    timestamp_info = find_timestamps(signature)
    if timestamp_info is not None:
        info.update(timestamp_info)

    try:
        certificates = signature[&#39;content&#39;][&#39;certificates&#39;]
    except KeyError:
        return info

    if len(certificates) == 1:
        main_certificate = certificates[0]
    else:
        certificates_with_extended_use = []
        main_certificate = None
        for certificate in certificates:
            with suppress(Exception):
                crt = certificate[&#39;tbs_certificate&#39;]
                ext = [e for e in crt[&#39;extensions&#39;] if e[&#39;extn_id&#39;] == &#39;extended_key_usage&#39; and e[&#39;extn_value&#39;] != [&#39;time_stamping&#39;]]
                key = [e for e in crt[&#39;extensions&#39;] if e[&#39;extn_id&#39;] == &#39;key_usage&#39;]
                if ext:
                    certificates_with_extended_use.append(certificate)
                if any(&#39;key_cert_sign&#39; in e[&#39;extn_value&#39;] for e in key):
                    continue
                if any(&#39;code_signing&#39; in e[&#39;extn_value&#39;] for e in ext):
                    main_certificate = certificate
                    break
        if main_certificate is None and len(certificates_with_extended_use) == 1:
            main_certificate = certificates_with_extended_use[0]
    if main_certificate:
        crt = main_certificate[&#39;tbs_certificate&#39;]
        serial = crt[&#39;serial_number&#39;]
        if isinstance(serial, int):
            serial = F&#39;{serial:x}&#39;
        if len(serial) % 2 != 0:
            serial = F&#39;0{serial}&#39;
        assert bytes.fromhex(serial) in data
        subject = crt[&#39;subject&#39;]
        location = [subject.get(t, &#39;&#39;) for t in (&#39;locality_name&#39;, &#39;state_or_province_name&#39;, &#39;country_name&#39;)]
        info.update(Subject=subject[&#39;common_name&#39;])
        if any(location):
            info.update(SubjectLocation=&#39;, &#39;.join(filter(None, location)))
        for signer_info in signature[&#39;content&#39;].get(&#39;signer_infos&#39;, ()):
            try:
                if signer_info[&#39;sid&#39;][&#39;serial_number&#39;] != crt[&#39;serial_number&#39;]:
                    continue
                for attr in signer_info[&#39;signed_attrs&#39;]:
                    if attr[&#39;type&#39;] == &#39;authenticode_info&#39;:
                        auth = _value(attr)
                        info.update(ProgramName=auth[&#39;programName&#39;])
                        info.update(MoreInfo=auth[&#39;moreInfo&#39;])
            except KeyError:
                continue
        try:
            valid_from = crt[&#39;validity&#39;][&#39;not_before&#39;]
            valid_until = crt[&#39;validity&#39;][&#39;not_after&#39;]
        except KeyError:
            pass
        else:
            info.update(ValidFrom=valid_from, ValidUntil=valid_until)
        info.update(
            Issuer=crt[&#39;issuer&#39;][&#39;common_name&#39;], Fingerprint=main_certificate[&#39;fingerprint&#39;], Serial=serial)
        return info
    return info</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_version"><code class="name flex">
<span>def <span class="ident">parse_version</span></span>(<span>self, pe, data=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts a JSON-serializable and human-readable dictionary with information about
the version resource of an input PE file, if available.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L324-L360" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_version(self, pe: PE, data=None) -&gt; dict:
    &#34;&#34;&#34;
    Extracts a JSON-serializable and human-readable dictionary with information about
    the version resource of an input PE file, if available.
    &#34;&#34;&#34;
    pe.parse_data_directories(directories=[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]])
    string_table_entries = []
    for FileInfo in pe.FileInfo:
        for FileInfoEntry in FileInfo:
            with suppress(AttributeError):
                for StringTableEntry in FileInfoEntry.StringTable:
                    StringTableEntryParsed = self._parse_pedict(StringTableEntry.entries)
                    with suppress(AttributeError):
                        LangID = StringTableEntry.entries.get(&#39;LangID&#39;, None) or StringTableEntry.LangID
                        LangID = int(LangID, 0x10) if not isinstance(LangID, int) else LangID
                        LangHi = LangID &gt;&gt; 0x10
                        LangLo = LangID &amp; 0xFFFF
                        Language = LCID.get(LangHi, &#39;Language Neutral&#39;)
                        Charset = self._CHARSET.get(LangLo, &#39;Unknown Charset&#39;)
                        StringTableEntryParsed.update(
                            LangID=F&#39;{LangID:08X}&#39;,
                            Charset=Charset,
                            Language=Language
                        )
                    for key in StringTableEntryParsed:
                        if key.endswith(&#39;Version&#39;):
                            value = StringTableEntryParsed[key]
                            separator = &#39;, &#39;
                            if re.match(F&#39;\\d+({re.escape(separator)}\\d+){{3}}&#39;, value):
                                StringTableEntryParsed[key] = &#39;.&#39;.join(value.split(separator))
                    string_table_entries.append(StringTableEntryParsed)
    if not string_table_entries:
        return None
    elif len(string_table_entries) == 1:
        return string_table_entries[0]
    else:
        return string_table_entries</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_exports"><code class="name flex">
<span>def <span class="ident">parse_exports</span></span>(<span>self, pe, data=None, include_addresses=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L362-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_exports(self, pe: PE, data=None, include_addresses=False) -&gt; list:
    pe.parse_data_directories(directories=[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;]])
    base = pe.OPTIONAL_HEADER.ImageBase
    info = []
    for k, exp in enumerate(pe.DIRECTORY_ENTRY_EXPORT.symbols):
        if not exp.name:
            name = F&#39;@{k}&#39;
        else:
            name = exp.name.decode(&#39;ascii&#39;)
        item = {&#39;Name&#39;: name, &#39;Address&#39;: self._vint(pe, exp.address + base)} if include_addresses else name
        info.append(item)
    return info</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_imports"><code class="name flex">
<span>def <span class="ident">parse_imports</span></span>(<span>self, pe, data=None, include_addresses=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L375-L406" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_imports(self, pe: PE, data=None, include_addresses=False) -&gt; list:
    info = {}
    dirs = []
    for name in [
        &#39;DIRECTORY_ENTRY_IMPORT&#39;,
        &#39;DIRECTORY_ENTRY_DELAY_IMPORT&#39;,
    ]:
        pe.parse_data_directories(directories=[DIRECTORY_ENTRY[F&#39;IMAGE_{name}&#39;]])
        with suppress(AttributeError):
            dirs.append(getattr(pe, name))
    self.log_warn(dirs)
    for idd in itertools.chain(*dirs):
        dll: bytes = idd.dll
        dll = dll.decode(&#39;ascii&#39;)
        if dll.lower().endswith(&#39;.dll&#39;):
            dll = dll[:~3]
        imports: list[str] = info.setdefault(dll, [])
        with suppress(AttributeError):
            symbols = idd.imports
        with suppress(AttributeError):
            symbols = idd.entries
        try:
            for imp in symbols:
                name: bytes = imp.name
                name = name and name.decode(&#39;ascii&#39;) or F&#39;@{imp.ordinal}&#39;
                if not include_addresses:
                    imports.append(name)
                else:
                    imports.append(dict(Name=name, Address=self._vint(pe, imp.address)))
        except Exception as e:
            self.log_warn(F&#39;error parsing {name}: {e!s}&#39;)
    return info</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_header"><code class="name flex">
<span>def <span class="ident">parse_header</span></span>(<span>self, pe, data=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L408-L483" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_header(self, pe: PE, data=None) -&gt; dict:
    def format_macro_name(name: str, prefix, convert=True):
        name = name.split(&#39;_&#39;)[prefix:]
        if convert:
            for k, part in enumerate(name):
                name[k] = part.upper() if len(part) &lt;= 3 else part.capitalize()
        return &#39; &#39;.join(name)

    major = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
    minor = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
    version = self._WINVER.get(major, {0: &#39;Unknown&#39;})

    try:
        MinimumOS = version[minor]
    except LookupError:
        MinimumOS = version[0]
    header_information = {
        &#39;Machine&#39;: format_macro_name(MACHINE_TYPE[pe.FILE_HEADER.Machine], 3, False),
        &#39;Subsystem&#39;: format_macro_name(SUBSYSTEM_TYPE[pe.OPTIONAL_HEADER.Subsystem], 2),
        &#39;MinimumOS&#39;: MinimumOS,
    }

    pe.parse_data_directories(directories=[
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
    ])

    try:
        export_name = pe.DIRECTORY_ENTRY_EXPORT.name
        if isinstance(export_name, bytes):
            export_name = export_name.decode(&#39;utf8&#39;)
        if not export_name.isprintable():
            export_name = None
    except Exception:
        export_name = None
    if export_name:
        header_information[&#39;ExportName&#39;] = export_name

    rich_header = pe.parse_rich_header()
    rich = []

    if rich_header:
        it = rich_header.get(&#39;values&#39;, [])
        if self.args.tabular:
            cw = max(len(F&#39;{c:d}&#39;) for c in it[1::2])
        for idv, count in zip(it[0::2], it[1::2]):
            info = get_rich_info(idv)
            if not info:
                continue
            pid = info.pid.upper()
            if self.args.tabular:
                short_pid = get_rich_short_pid(pid)
                rich.append(F&#39;[{idv:08x}] {count:&gt;0{cw}d} {short_pid!s} {info.ver}&#39;)
            else:
                rich.append({
                    &#39;Counter&#39;: count,
                    &#39;Encoded&#39;: F&#39;{idv:08x}&#39;,
                    &#39;Library&#39;: pid,
                    &#39;Product&#39;: info.ver,
                })
        header_information[&#39;RICH&#39;] = rich

    characteristics = self._pe_characteristics(pe)
    for typespec, flag in {
        &#39;EXE&#39;: &#39;IMAGE_FILE_EXECUTABLE_IMAGE&#39;,
        &#39;DLL&#39;: &#39;IMAGE_FILE_DLL&#39;,
        &#39;SYS&#39;: &#39;IMAGE_FILE_SYSTEM&#39;
    }.items():
        if flag in characteristics:
            header_information[&#39;Type&#39;] = typespec

    base = pe.OPTIONAL_HEADER.ImageBase
    header_information[&#39;ImageBase&#39;] = self._vint(pe, base)
    header_information[&#39;ImageSize&#39;] = get_pe_size(pe)
    header_information[&#39;Bits&#39;] = 4 * self._pe_address_width(pe, 16)
    header_information[&#39;EntryPoint&#39;] = self._vint(pe, pe.OPTIONAL_HEADER.AddressOfEntryPoint + base)
    return header_information</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_time_stamps"><code class="name flex">
<span>def <span class="ident">parse_time_stamps</span></span>(<span>self, pe, raw_time_stamps, more_detail)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts time stamps from the PE header (link time), as well as from the imports,
exports, debug, and resource directory. The resource time stamp is also parsed as
a DOS time stamp and returned as the "Delphi" time stamp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L485-L562" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_time_stamps(self, pe: PE, raw_time_stamps: bool, more_detail: bool) -&gt; dict:
    &#34;&#34;&#34;
    Extracts time stamps from the PE header (link time), as well as from the imports,
    exports, debug, and resource directory. The resource time stamp is also parsed as
    a DOS time stamp and returned as the &#34;Delphi&#34; time stamp.
    &#34;&#34;&#34;
    if raw_time_stamps:
        def dt(ts): return ts
    else:
        dt = date_from_timestamp

    pe.parse_data_directories(directories=[
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_IMPORT&#39;],
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT&#39;],
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT&#39;],
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;],
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]
    ])

    info = {}

    with suppress(AttributeError):
        info.update(Linker=dt(pe.FILE_HEADER.TimeDateStamp))

    for dir_name, _dll, info_key in [
        (&#39;DIRECTORY_ENTRY_IMPORT&#39;,       &#39;dll&#39;,  &#39;Import&#39;), # noqa
        (&#39;DIRECTORY_ENTRY_DELAY_IMPORT&#39;, &#39;dll&#39;,  &#39;Symbol&#39;), # noqa
        (&#39;DIRECTORY_ENTRY_BOUND_IMPORT&#39;, &#39;name&#39;, &#39;Module&#39;), # noqa
    ]:
        impts = {}
        for entry in getattr(pe, dir_name, []):
            ts = 0
            with suppress(AttributeError):
                ts = entry.struct.dwTimeDateStamp
            with suppress(AttributeError):
                ts = entry.struct.TimeDateStamp
            if ts == 0 or ts == 0xFFFFFFFF:
                continue
            name = getattr(entry, _dll, B&#39;&#39;).decode()
            if name.lower().endswith(&#39;.dll&#39;):
                name = name[:-4]
            impts[name] = dt(ts)
        if not impts:
            continue
        if not more_detail:
            dmin = min(impts.values())
            dmax = max(impts.values())
            small_delta = 2 * 60 * 60
            if not raw_time_stamps:
                small_delta = timedelta(seconds=small_delta)
            if dmax - dmin &lt; small_delta:
                impts = dmin
        info[info_key] = impts

    with suppress(AttributeError):
        Export = pe.DIRECTORY_ENTRY_EXPORT.struct.TimeDateStamp
        if Export: info.update(Export=dt(Export))

    with suppress(AttributeError):
        res_timestamp = pe.DIRECTORY_ENTRY_RESOURCE.struct.TimeDateStamp
        if res_timestamp:
            with suppress(ValueError):
                from refinery.units.misc.datefix import datefix
                dos = datefix.dostime(res_timestamp)
                info.update(Delphi=dos)
                info.update(RsrcTS=dt(res_timestamp))

    def norm(value):
        if isinstance(value, list):
            return [norm(v) for v in value]
        if isinstance(value, dict):
            return {k: norm(v) for k, v in value.items()}
        if isinstance(value, int):
            return value
        return str(value)

    return {key: norm(value) for key, value in info.items()}</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_dotnet"><code class="name flex">
<span>def <span class="ident">parse_dotnet</span></span>(<span>self, pe, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts a JSON-serializable and human-readable dictionary with information about
the .NET metadata of an input PE file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L564-L601" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_dotnet(self, pe: PE, data):
    &#34;&#34;&#34;
    Extracts a JSON-serializable and human-readable dictionary with information about
    the .NET metadata of an input PE file.
    &#34;&#34;&#34;
    header = DotNetHeader(data, pe=pe)
    tables = header.meta.Streams.Tables
    info = dict(
        RuntimeVersion=F&#39;{header.head.MajorRuntimeVersion}.{header.head.MinorRuntimeVersion}&#39;,
        Version=F&#39;{header.meta.MajorVersion}.{header.meta.MinorVersion}&#39;,
        VersionString=header.meta.VersionString
    )

    info[&#39;Flags&#39;] = [name for name, check in header.head.KnownFlags.items() if check]

    if len(tables.Assembly) == 1:
        assembly = tables.Assembly[0]
        info.update(
            AssemblyName=assembly.Name,
            Release=&#39;{}.{}.{}.{}&#39;.format(
                assembly.MajorVersion,
                assembly.MinorVersion,
                assembly.BuildNumber,
                assembly.RevisionNumber
            )
        )

    try:
        entry = self._vint(pe, header.head.EntryPointToken + pe.OPTIONAL_HEADER.ImageBase)
        info.update(EntryPoint=entry)
    except AttributeError:
        pass

    if len(tables.Module) == 1:
        module = tables.Module[0]
        info.update(ModuleName=module.Name)

    return info</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_debug"><code class="name flex">
<span>def <span class="ident">parse_debug</span></span>(<span>self, pe, data=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/pe/pemeta.py#L603-L618" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_debug(self, pe: PE, data=None):
    result = {}
    pe.parse_data_directories(directories=[
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;]])
    for dbg in pe.DIRECTORY_ENTRY_DEBUG:
        if DEBUG_TYPE.get(dbg.struct.Type, None) != &#39;IMAGE_DEBUG_TYPE_CODEVIEW&#39;:
            continue
        with suppress(Exception):
            pdb = dbg.entry.PdbFileName
            if 0 in pdb:
                pdb = pdb[:pdb.index(0)]
            result.update(
                PdbPath=pdb.decode(self.codec),
                PdbAge=dbg.entry.Age
            )
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.Arg" href="../../index.html#refinery.units.Unit.Arg">Arg</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.handles" href="../../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.reverse" href="../../index.html#refinery.units.UnitBase.reverse">reverse</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.formats.pe" href="index.html">refinery.units.formats.pe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.units.formats.pe.pemeta.get_rich_short_pid" href="#refinery.units.formats.pe.pemeta.get_rich_short_pid">get_rich_short_pid</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.get_rich_info" href="#refinery.units.formats.pe.pemeta.get_rich_info">get_rich_info</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.pe.pemeta.VIT" href="#refinery.units.formats.pe.pemeta.VIT">VIT</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.pe.pemeta.VersionInfo" href="#refinery.units.formats.pe.pemeta.VersionInfo">VersionInfo</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.pe.pemeta.ShortPID" href="#refinery.units.formats.pe.pemeta.ShortPID">ShortPID</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.pe.pemeta.pemeta" href="#refinery.units.formats.pe.pemeta.pemeta">pemeta</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_signature" href="#refinery.units.formats.pe.pemeta.pemeta.parse_signature">parse_signature</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_version" href="#refinery.units.formats.pe.pemeta.pemeta.parse_version">parse_version</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_exports" href="#refinery.units.formats.pe.pemeta.pemeta.parse_exports">parse_exports</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_imports" href="#refinery.units.formats.pe.pemeta.pemeta.parse_imports">parse_imports</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_header" href="#refinery.units.formats.pe.pemeta.pemeta.parse_header">parse_header</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_time_stamps" href="#refinery.units.formats.pe.pemeta.pemeta.parse_time_stamps">parse_time_stamps</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_dotnet" href="#refinery.units.formats.pe.pemeta.pemeta.parse_dotnet">parse_dotnet</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_debug" href="#refinery.units.formats.pe.pemeta.pemeta.parse_debug">parse_debug</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>