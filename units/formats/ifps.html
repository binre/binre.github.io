<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>the refinery.units.formats.ifps documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats.ifps</code></h1>
</header>
<section id="section-intro">
<p>The code is based on the logic implemented in IFPSTools:
<a href="https://github.com/Wack0/IFPSTools">https://github.com/Wack0/IFPSTools</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L1-L927" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
The code is based on the logic implemented in IFPSTools:
 https://github.com/Wack0/IFPSTools
&#34;&#34;&#34;
from __future__ import annotations

import enum
import io
import uuid

from typing import Callable, Dict, Generator, List, NamedTuple, Optional, Tuple, Type, TypeVar, Union
from dataclasses import dataclass, field
from collections import OrderedDict
from functools import WRAPPER_ASSIGNMENTS, update_wrapper

from refinery.units.formats import Unit
from refinery.lib.structures import Struct, StructReader, StreamDetour

_CLS = TypeVar(&#39;_CLS&#39;)
_TAB = &#39;\x20\x20&#39;


def extended(_data: bytes):
    if len(_data) != 10:
        raise ValueError
    data = int.from_bytes(_data, &#39;little&#39;)
    sign = data &gt;&gt; 79
    data = data ^ (sign &lt;&lt; 79)
    sign = -1.0 if sign else +1.0
    exponent = data &gt;&gt; 64
    data = data ^ (exponent &lt;&lt; 64)
    if exponent == 0:
        if data == 0:
            return sign * 0
        exponent = -16382
    elif exponent == 0b111111111111111:
        if data == 0:
            return sign * float(&#39;Inf&#39;)
        else:
            return sign * float(&#39;NaN&#39;)
    else:
        exponent = exponent - 16383
    mantissa = data / (1 &lt;&lt; 64)
    return sign * mantissa * (2 ** exponent)


def rfix(cls: _CLS) -&gt; _CLS:
    cls.__repr__ = lambda self: F&#39;{self.__class__.__name__}.{self.name}&#39;
    cls.__str__ = lambda self: self.name
    return cls


@rfix
class Op(enum.IntEnum):
    Assign       = 0x00  # noqa
    Calculate    = 0x01  # noqa
    Push         = 0x02  # noqa
    PushVar      = 0x03  # noqa
    Pop          = 0x04  # noqa
    Call         = 0x05  # noqa
    Jump         = 0x06  # noqa
    JumpTrue     = 0x07  # noqa
    JumpFalse    = 0x08  # noqa
    Ret          = 0x09  # noqa
    StackType    = 0x0A  # noqa
    PushType     = 0x0B  # noqa
    Compare      = 0x0C  # noqa
    CallVar      = 0x0D  # noqa
    SetPtr       = 0x0E  # noqa
    LogicalNot   = 0x0F  # noqa
    Neg          = 0x10  # noqa
    SetFlag      = 0x11  # noqa
    JumpFlag     = 0x12  # noqa
    PushEH       = 0x13  # noqa
    PopEH        = 0x14  # noqa
    Not          = 0x15  # noqa
    SetCopyPtr   = 0x16  # noqa
    Inc          = 0x17  # noqa
    Dec          = 0x18  # noqa
    JumpPop1     = 0x19  # noqa
    JumpPop2     = 0x1A  # noqa
    Nop          = 0xFF  # noqa
    _INVALID     = 0xDD  # noqa

    @classmethod
    def FromInt(cls, code: int):
        try:
            return cls(code)
        except ValueError:
            return cls._INVALID


@rfix
class TC(int, enum.Enum):
    ReturnAddress       = 0x00  # noqa
    U08                 = 0x01  # noqa
    S08                 = 0x02  # noqa
    U16                 = 0x03  # noqa
    S16                 = 0x04  # noqa
    U32                 = 0x05  # noqa
    S32                 = 0x06  # noqa
    Single              = 0x07  # noqa
    Double              = 0x08  # noqa
    Extended            = 0x09  # noqa
    String              = 0x0A  # noqa
    Record              = 0x0B  # noqa
    Array               = 0x0C  # noqa
    Pointer             = 0x0D  # noqa
    PChar               = 0x0E  # noqa
    ResourcePointer     = 0x0F  # noqa
    Variant             = 0x10  # noqa
    S64                 = 0x11  # noqa
    Char                = 0x12  # noqa
    WideString          = 0x13  # noqa
    WideChar            = 0x14  # noqa
    ProcPtr             = 0x15  # noqa
    Tuple               = 0x16  # noqa
    Set                 = 0x17  # noqa
    Currency            = 0x18  # noqa
    Class               = 0x19  # noqa
    Interface           = 0x1A  # noqa
    NotificationVariant = 0x1B  # noqa
    UnicodeString       = 0x1C  # noqa
    Enum                = 0x81  # noqa
    Type                = 0x82  # noqa
    ExtClass            = 0x83  # noqa

    @property
    def width(self):
        return {
            TC.Variant       : 0x10,
            TC.Char          : 0x01,
            TC.S08           : 0x01,
            TC.U08           : 0x01,
            TC.WideChar      : 0x02,
            TC.S16           : 0x02,
            TC.U16           : 0x02,
            TC.WideString    : 0x04,
            TC.UnicodeString : 0x04,
            TC.Interface     : 0x04,
            TC.Class         : 0x04,
            TC.PChar         : 0x04,
            TC.String        : 0x04,
            TC.Single        : 0x04,
            TC.S32           : 0x04,
            TC.U32           : 0x04,
            TC.ProcPtr       : 0x0C,
            TC.Currency      : 0x08,
            TC.Pointer       : 0x0C,
            TC.Double        : 0x08,
            TC.S64           : 0x08,
            TC.Extended      : 0x0A,
            TC.ReturnAddress : 0x1C,
        }.get(self, 0)


@dataclass
class _OptionsMixin:
    symbol: Optional[str] = None
    attributes: Optional[List[Attribute]] = None

    def __str__(self):
        if self.symbol is not None:
            return self.symbol
        return super().__str__()


@dataclass
class _TypeBase:
    code: TC

    def display(self, indent=0):
        return indent * _TAB + self.code.name

    def simple(self, nested=False):
        return True

    def __str__(self):
        return self.display(0)


def optionals(cls: _CLS) -&gt; Union[_CLS, Type[_OptionsMixin]]:
    class _mixed(_OptionsMixin, cls):
        ...
    assigned = set(WRAPPER_ASSIGNMENTS) - {&#39;__annotations__&#39;}
    update_wrapper(_mixed, cls, assigned=assigned, updated=())
    return dataclass(_mixed)


@optionals
@dataclass
class TGeneric(_TypeBase):
    pass


@optionals
@dataclass
class TProcPtr(_TypeBase):
    body: bytes

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.body.hex()})&#39;


@optionals
@dataclass
class TInterface(_TypeBase):
    uuid: uuid.UUID

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.uuid!s})&#39;


@optionals
@dataclass
class TClass(_TypeBase):
    name: str

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.name})&#39;


@optionals
@dataclass
class TSet(_TypeBase):
    size: int

    @property
    def size_in_bytes(self):
        q, r = divmod(self.size, 8)
        return q + (r and 1 or 0)

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.size})&#39;


@optionals
@dataclass
class TArray(_TypeBase):
    type: TGeneric

    def display(self, indent=0):
        display = F&#39;{_TAB * indent}{self.type!s}&#39;
        return F&#39;{display}[]&#39;

    def simple(self, nested=False):
        return self.type.simple(nested)


@optionals
@dataclass
class TTuple(_TypeBase):
    type: TGeneric
    size: int
    offset: Optional[int] = None

    def display(self, indent=0):
        display = F&#39;{_TAB * indent}{self.type!s}&#39;
        return F&#39;{display}[{self.size}]&#39;

    def simple(self, nested=False):
        return self.type.simple(nested)


@optionals
@dataclass
class TRecord(_TypeBase):
    members: Tuple[TGeneric, ...]

    def simple(self, nested=False):
        if nested:
            return False
        if len(self.members) &gt; 10:
            return False
        return all(m.simple(True) for m in self.members)

    def display(self, indent=0):
        output = io.StringIO()
        output.write(indent * _TAB)
        output.write(&#39;struct {&#39;)
        if self.simple():
            output.write(&#39;, &#39;.join(str(m) for m in self.members))
        else:
            for k, member in enumerate(self.members):
                if k &gt; 0:
                    output.write(&#39;,&#39;)
                output.write(&#39;\n&#39;)
                output.write(member.display(indent + 1))
            if self.members:
                output.write(F&#39;\n{_TAB * indent}&#39;)
        output.write(&#39;}&#39;)
        return output.getvalue()


TType = Union[TRecord, TTuple, TArray, TSet, TProcPtr, TClass, TInterface, TGeneric]


class Value(NamedTuple):
    type: TGeneric
    value: Union[str, int, float, bytes]

    def __repr__(self):
        value = self.value
        if isinstance(value, bytes):
            value = value.hex()
        return F&#39;{self.type.code.name}({value!r})&#39;

    def __str__(self):
        return repr(self.value)


class Attribute(NamedTuple):
    name: str
    fields: Tuple[Value, ...]

    def __repr__(self):
        name = self.name
        if self.fields:
            name += &#39;[{}]&#39;.format(&#39;,&#39;.join(repr(f) for f in self.fields))
        return name


class DeclSpecParam(NamedTuple):
    mode_in: bool
    type: Optional[TGeneric] = None


@dataclass
class DeclSpec:

    void: bool
    parameters: List[DeclSpecParam]
    name: str = &#39;&#39;
    calling_convention: Optional[str] = None
    return_type: Optional[TGeneric] = None
    module: Optional[str] = None
    classname: Optional[str] = None
    delay_load: bool = False
    load_with_altered_search_path: bool = False
    is_property: bool = False

    def represent(self, name: str, ref: bool = False):
        def pparam(k: int, p: DeclSpecParam):
            name = F&#39;{VariantType.Argument!s}{k}&#39;
            if p.type is not None:
                name = F&#39;{name}: {p.type!s}&#39;
            if not p.mode_in:
                name = F&#39;*{name}&#39;
            return name
        if self.name and name in self.name:
            name = self.name
        spec = name
        if self.classname:
            spec = F&#39;{self.classname}.{spec}&#39;
        if self.module:
            spec = F&#39;{self.module}::{spec}&#39;
        if not ref:
            if self.delay_load:
                spec = F&#39;__delay_load {spec}&#39;
            if self.calling_convention:
                spec = F&#39;__{self.calling_convention} {spec}&#39;
            spec = F&#39;{self.type} {spec}&#39;
            args = self.parameters
            args = args and &#39;, &#39;.join(pparam(*t) for t in enumerate(args)) or &#39;&#39;
            spec = F&#39;{spec}({args})&#39;
            if self.return_type:
                spec = F&#39;{spec} -&gt; {self.return_type.code.name}&#39;
        return spec

    @property
    def type(self):
        return &#39;sub&#39; if self.void else &#39;function&#39;

    def __repr__(self):
        return self.represent(self.name or &#39;(*)&#39;)

    @classmethod
    def ParseF(cls, reader: StructReader[bytes], load_flags: bool):
        def ascii():
            return reader.read_c_string(&#39;latin1&#39;)

        def boolean():
            return bool(reader.u8())

        def cc():
            return {
                0: &#39;register&#39;,
                1: &#39;pascal&#39;,
                2: &#39;cdecl&#39;,
                3: &#39;stdcall&#39;,
            }.get(reader.u8(), cls.calling_convention)

        kw = {}
        parameters = None
        if reader.peek(4) == b&#39;dll:&#39;:
            reader.seekrel(4)
            if reader.peek(6) == B&#39;files:&#39;:
                reader.seekrel(6)
            kw.update(module=ascii(), name=ascii(), calling_convention=cc())
            if load_flags:
                kw.update(delay_load=boolean(), load_with_altered_search_path=boolean())
            void = not boolean()
        elif reader.peek(6) == b&#39;class:&#39;:
            reader.seekrel(6)
            if reader.remaining_bytes == 1:
                rest = reader.peek(1)
                void = False
                parameters = [DeclSpecParam(False)]
                kw.update(
                    classname=&#39;Class&#39;,
                    name={b&#39;+&#39;: &#39;CastToType&#39;, B&#39;-&#39;: &#39;SetNil&#39;}.get(rest),
                    calling_convention=&#39;pascal&#39;,
                )
            else:
                kw.update(classname=reader.read_terminated_array(b&#39;|&#39;).decode(&#39;latin1&#39;))
                name = reader.read_terminated_array(b&#39;|&#39;).decode(&#39;latin1&#39;)
                if name[-1] == &#39;@&#39;:
                    kw.update(is_property=True)
                    name = name[:-1]
                kw.update(name=name, calling_convention=cc())
                void = not reader.u8()
        else:
            void = not reader.u8()
        if parameters is not None:
            parameters = [DeclSpecParam(bool(b)) for b in reader.read()]
        return cls(void, parameters, **kw)

    @classmethod
    def ParseE(cls, data: bytes, ipfs: IFPSFile):
        decl = data.split(B&#39;\x20&#39;)
        return_type = int(decl.pop(0))
        void = return_type == -1
        if not void:
            return_type = ipfs.types[return_type]
        else:
            return_type = None
        parameters = []
        for param in decl:
            mode_in = param[0] == B&#39;@&#39;[0]
            ti = int(param[1:])
            parameters.append(DeclSpecParam(mode_in, ipfs.types[ti]))
        return cls(void, parameters, return_type=return_type)


class Function(NamedTuple):
    name: str
    decl: Optional[DeclSpec]
    body: Optional[List[Instruction]] = None
    exported: bool = False
    attributes: Optional[List[Attribute]] = None

    def reference(self) -&gt; str:
        if self.decl is None:
            return self.name
        return self.decl.represent(self.name, ref=True)

    def __repr__(self):
        if self.decl is None:
            return F&#39;symbol {self.name}&#39;
        return self.decl.represent(self.name)

    @property
    def type(self):
        if self.decl is None:
            return &#39;symbol&#39;
        return self.decl.type


class Variable(NamedTuple):
    index: int
    flags: int
    type: TGeneric
    name: str

    def __repr__(self):
        return F&#39;{self.name}: {self.type!s}&#39;


@rfix
class OperandType(enum.IntEnum):
    Variant = 0
    Value = 1
    IndexedInt = 2
    IndexedVar = 3


class VariantType(str, enum.Enum):
    Global = &#39;GlobalVar&#39;
    ReturnValue = &#39;ReturnValue&#39;
    Variable = &#39;LocalVar&#39;
    Argument = &#39;Argument&#39;

    def __repr__(self):
        return self.name

    def __str__(self):
        return self.value


class Variant(NamedTuple):
    index: int
    type: VariantType

    def __repr__(self):
        return F&#39;{self.type!s}{self.index}&#39;


class Operand(NamedTuple):
    type: OperandType
    variant: Optional[Variant] = None
    value: Optional[Value] = None
    index: Optional[Union[Variant, int]] = None

    def __repr__(self):
        if self.type is OperandType.Value:
            return str(self.value)
        if self.type is OperandType.Variant:
            return F&#39;{self.variant}&#39;
        if self.type is OperandType.IndexedInt:
            return F&#39;{self.variant}[0x{self.index:02X}]&#39;
        if self.type is OperandType.IndexedVar:
            return F&#39;{self.variant}[{self.index!s}]&#39;
        raise RuntimeError(F&#39;Unexpected OperandType {self.type!r} in {self.__class__.__name__}&#39;)


_Op_Maxlen = max(len(op.name) for op in Op)


@dataclass
class Instruction:
    offset: int
    opcode: Op
    operands: List[Union[str, int, Operand, TGeneric]] = field(default_factory=list)
    jumptarget: bool = False

    def _oprep(self, fuse_index=None, is_jump=False):
        if fuse_index is None:
            operands = list(self.operands)
        else:
            rest = self.operands[fuse_index:]
            rest = &#39;\x20&#39;.join((str(op) for op in rest))
            operands = [*self.operands[:fuse_index], rest]
        if is_jump:
            operands[0] = F&#39;0x{operands[0]:X}&#39;
        return &#39;, &#39;.join(str(op) for op in operands)

    def __repr__(self):
        return F&#39;{self.opcode.name}({self._oprep()})&#39;

    def __str__(self):
        fuse = None
        if self.opcode is Op.Compare:
            fuse = 1
        if self.opcode is Op.Calculate:
            fuse = 0
        jmp = self.opcode in (
            Op.Jump,
            Op.JumpFalse,
            Op.JumpTrue,
            Op.JumpFlag,
            Op.JumpPop1,
            Op.JumpPop2,
        )
        return F&#39;{self.opcode!s:&lt;{_Op_Maxlen}}{_TAB}{self._oprep(fuse, jmp)}&#39;


class IFPSFile(Struct):
    MinVer = 12
    MaxVer = 23

    Magic = B&#39;IFPS&#39;

    def __init__(self, reader: StructReader[memoryview], codec: str):
        self.codec = codec
        self.types: List[TType] = []
        self.functions: List[Function] = []
        self.variables: List[Variable] = []
        self.strings: List[str] = []
        self.reader = reader
        if reader.remaining_bytes &lt; 28:
            raise ValueError(&#39;Less than 28 bytes in file, not enough data to parse.&#39;)
        magic = reader.read(4)
        if magic != self.Magic:
            raise ValueError(F&#39;Invalid magic sequence: {magic.hex()}&#39;)
        self.version = reader.u32()
        self.count_types = reader.u32()
        self.count_functions = reader.u32()
        self.count_variables = reader.u32()
        self.entry = reader.u32()
        self.import_size = reader.u32()
        self.void = False
        if self.version not in range(self.MinVer, self.MaxVer + 1):
            ifps.log_warn(
                F&#39;This IFPS file has version {self.version}, which is not in the supported range &#39;
                F&#39;[{self.MinVer},{self.MaxVer}].&#39;)
        self._load_types()
        self._load_functions()
        self._load_variables()

    @property
    def _load_flags(self):
        return self.version &gt;= 23

    def _load_types(self):
        reader = self.reader
        types = self.types
        for k in range(self.count_types):
            typecode = reader.u8()
            exported = bool(typecode &amp; 0x80)
            typecode = typecode &amp; 0x7F
            try:
                code = TC(typecode)
            except ValueError as V:
                raise ValueError(F&#39;Unknown type code value 0x{typecode:02X}.&#39;) from V
            if code is TC.Class:
                t = TClass(code, reader.read_length_prefixed_ascii())
            elif code is TC.ProcPtr:
                t = TProcPtr(code, reader.read_length_prefixed())
            elif code is TC.Interface:
                guid = uuid.UUID(bytes=bytes(reader.read(0x10)))
                t = TInterface(code, guid)
            elif code is TC.Set:
                t = TSet(code, reader.u32())
            elif code is TC.Tuple:
                type = types[reader.u32()]
                size = reader.u32()
                offset = None if self.version &lt;= 22 else reader.u32()
                t = TTuple(code, type, size, offset)
            elif code is TC.Array:
                t = TArray(code, types[reader.u32()])
            elif code is TC.Record:
                length = reader.u32()
                members = tuple(types[reader.u32()] for _ in range(length))
                t = TRecord(code, members, symbol=F&#39;RECORD{k}&#39;)
            else:
                t = TGeneric(code, symbol=code.name)
            if exported:
                t.symbol = reader.read_length_prefixed_ascii()
                if self.version &lt;= 21:
                    t.name = reader.read_length_prefixed_ascii()
            types.append(t)
            if self.version &gt;= 21:
                t.attributes = list(self._read_attributes())

    def _read_value(self, reader: Optional[StructReader] = None) -&gt; Value:
        if reader is None:
            reader = self.reader
        type = self.types[reader.u32()]
        size = type.code.width
        processor: Optional[Callable[[], Union[int, float, str, bytes]]] = {
            TC.U08           : reader.u8,
            TC.S08           : reader.i8,
            TC.U16           : reader.u16,
            TC.S16           : reader.i16,
            TC.U32           : reader.u32,
            TC.S32           : reader.i32,
            TC.S64           : reader.i64,
            TC.Single        : reader.f32,
            TC.Double        : reader.f64,
            TC.Extended      : lambda: extended(reader.read(10)),
            TC.String        : lambda: reader.read_length_prefixed(encoding=self.codec),
            TC.PChar         : lambda: reader.read_length_prefixed(encoding=self.codec),
            TC.WideString    : reader.read_length_prefixed_utf16,
            TC.UnicodeString : reader.read_length_prefixed_utf16,
            TC.Char          : lambda: chr(reader.u8()),
            TC.WideChar      : lambda: chr(reader.u16()),
            TC.ProcPtr       : reader.u32,
            TC.Set           : lambda: bytes(reader.read(type.size_in_bytes)),
            TC.Currency      : lambda: reader.u64() / 10_000,
        }.get(type.code, None)
        if processor is not None:
            data = processor()
        elif size &gt; 0:
            data = bytes(reader.read(size))
        else:
            raise ValueError(F&#39;Unable to read attribute of type {type!s}.&#39;)
        if isinstance(data, str) and data not in self.strings:
            self.strings.append(data)
        return Value(type, data)

    def _read_attributes(self) -&gt; Generator[Attribute, None, None]:
        reader = self.reader
        count = reader.u32()
        for _ in range(count):
            name = reader.read_length_prefixed_ascii()
            fields = tuple(self._read_value() for _ in range(reader.u32()))
            yield Attribute(name, fields)

    def _load_functions(self):
        reader = self.reader
        width = len(F&#39;{self.count_functions:X}&#39;)
        for k in range(self.count_functions):
            decl = None
            body = None
            name = F&#39;F{k:0{width}X}&#39;
            function_flags = reader.u8()
            attributes = None
            has_attributes = bool(function_flags &amp; 4)
            imported = bool(function_flags &amp; 1)
            exported = bool(function_flags &amp; 2)
            if imported:
                name = reader.read_length_prefixed_ascii(8)
                if exported:
                    read = StructReader(bytes(reader.read_length_prefixed()))
                    decl = DeclSpec.ParseF(read, self._load_flags)
            else:
                offset = reader.u32()
                size = reader.u32()
                with StreamDetour(reader, offset):
                    body = list(self._parse_bytecode(reader.read(size)))
                self.void = False
                if exported:
                    name = reader.read_length_prefixed_ascii()
                    decl = DeclSpec.ParseE(bytes(reader.read_length_prefixed()), self)
                    self.void = decl.void
            if has_attributes:
                attributes = list(self._read_attributes())
            self.functions.append(Function(name, decl, body, exported, attributes))
        for function in self.functions:
            if function.body is None:
                continue
            for instruction in function.body:
                if instruction.opcode is Op.Call:
                    t: Function = self.functions[instruction.operands[0]]
                    instruction.operands[0] = t.reference()

    def _load_variables(self):
        reader = self.reader
        width = len(str(self.count_variables))
        for index in range(self.count_variables):
            tcode = reader.u32()
            flags = reader.u8()
            name = F&#39;{VariantType.Global!s}{index:0{width}}&#39;
            if flags &amp; 1:
                name = reader.read_length_prefixed_ascii()
            self.variables.append(Variable(index, flags, self.types[tcode], name))

    def _read_variant(self, index: int) -&gt; Variant:
        if index &lt; 0x40000000:
            return Variant(index, VariantType.Global)
        index -= 0x60000000
        if index == -1 and not self.void:
            type = VariantType.ReturnValue
        if index &gt;= 0:
            type = VariantType.Variable
        else:
            type = VariantType.Argument
            index = -index
            if self.void:
                index -= 1
        return Variant(index, type)

    def _read_operand(self, reader: StructReader) -&gt; Operand:
        ot = OperandType(reader.u8())
        kw = {}
        if ot is OperandType.Variant:
            kw.update(variant=self._read_variant(reader.u32()))
        if ot is OperandType.Value:
            kw.update(value=self._read_value(reader))
        if ot &gt;= OperandType.IndexedInt:
            kw.update(variant=self._read_variant(reader.u32()))
            index = reader.u32()
            if ot is OperandType.IndexedVar:
                index = self._read_variant(index)
            kw.update(index=index)
        return Operand(ot, **kw)

    def _parse_bytecode(self, data: memoryview) -&gt; Generator[Instruction, None, None]:
        disassembly: Dict[int, Instruction] = OrderedDict()
        reader = StructReader(data)

        argcount = {
            Op.Assign: 2,
            Op.CallVar: 1,
            Op.Dec: 1,
            Op.Inc: 1,
            Op.LogicalNot: 1,
            Op.Neg: 1,
            Op.Not: 1,
            Op.SetCopyPtr: 2,
            Op.SetPtr: 2,
        }

        while not reader.eof:
            def arg(k=1):
                for _ in range(k):
                    args.append(self._read_operand(reader))
            addr = reader.tell()
            cval = reader.u8()
            code = Op.FromInt(cval)
            insn = Instruction(addr, code)
            args = insn.operands
            disassembly[insn.offset] = insn
            aryness = argcount.get(code)
            if aryness is not None:
                arg(aryness)
            elif code in (Op.Ret, Op.Nop, Op.Pop):
                pass
            elif code is Op.Calculate:
                infix = [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;%&#39;, &#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;^&#39;][reader.u8()]
                infix = F&#39;{infix}=&#39;
                a = self._read_operand(reader)
                b = self._read_operand(reader)
                args.extend((a, infix, b))
            elif code in (Op.Push, Op.PushVar):
                arg()
            elif code in (Op.Jump, Op.JumpFlag):
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.Call:
                args.append(reader.u32())
            elif code in (Op.JumpTrue, Op.JumpFalse):
                target = reader.i32()
                val = self._read_operand(reader)
                args.append(reader.tell() + target)
                args.append(val)
            elif code is Op.JumpPop1:
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.JumpPop2:
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.StackType:
                args.append(self._read_variant(reader.u32()))
                args.append(reader.u32())
            elif code is Op.PushType:
                args.append(self.types[reader.u32()])
            elif code is Op.Compare:
                infix = [&#39;&gt;=&#39;, &#39;&lt;=&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;!=&#39;, &#39;==&#39;, &#39;in&#39;, &#39;is&#39;][reader.u8()]
                arg(2)
                args.append(infix)
                arg(1)
            elif code is Op.SetFlag:
                arg()
                args.append(reader.u8())
            elif code is Op.PushEH:
                args.extend(reader.u32() for _ in range(4))
            elif code is Op.PopEH:
                args.append(reader.u8())
            elif code is Op._INVALID:
                raise ValueError(F&#39;Unsupported opcode: 0x{cval:02X}&#39;)
            else:
                raise ValueError(F&#39;Unhandled opcode: {code.name}&#39;)

        for k, instruction in enumerate(disassembly.values()):
            if instruction.opcode in (
                Op.Jump,
                Op.JumpTrue,
                Op.JumpFalse,
                Op.JumpFlag,
                Op.JumpPop1,
                Op.JumpPop2,
            ):
                target = instruction.operands[0]
                try:
                    disassembly[target].jumptarget = True
                except KeyError as K:
                    raise RuntimeError(
                        F&#39;The jump target of instruction {k} at 0x{instruction.offset:X} is invalid; &#39;
                        F&#39;the invalid instruction is a {instruction.opcode.name} to 0x{target:X}.&#39;
                    ) from K

        yield from disassembly.values()

    def __str__(self):
        output = io.StringIO()
        _omax = max((
            max(insn.offset for insn in fn.body)
            for fn in self.functions if fn.body
        ), default=0)
        _omax = max(len(self.types), len(self.variables), _omax)
        width = len(F&#39;{_omax:X}&#39;)

        if self.types:
            for type in self.types:
                if type.code is not TC.Record:
                    continue
                output.write(F&#39;typedef {type.symbol} = {type.display()}\n&#39;)
            output.write(&#39;\n&#39;)

        if self.variables:
            for variable in self.variables:
                output.write(F&#39;{variable!s};\n&#39;)
            output.write(&#39;\n&#39;)

        if self.functions:
            for function in self.functions:
                if function.body is None:
                    output.write(F&#39;external {function!s};\n&#39;)
            output.write(&#39;\n&#39;)
            for function in self.functions:
                if function.body is None:
                    continue
                output.write(F&#39;begin {function!s}\n&#39;)
                for instruction in function.body:
                    output.write(F&#39;{_TAB}0x{instruction.offset:0{width}X}{_TAB}{instruction!s}\n&#39;)
                output.write(F&#39;end {function.type}\n\n&#39;)

        return output.getvalue()


class IFPSBase(Unit, abstract=True):
    def __init__(
        self,
        codec: Unit.Arg.String(
            help=&#39;Optionally specify the string encoding. The default is &#34;{default}&#34;.&#39;) = &#39;cp1252&#39;
    ):
        super().__init__(codec=codec)


class ifps(IFPSBase):
    &#34;&#34;&#34;
    Disassembles compiled Pascal script files that start with the magic sequence &#34;IFPS&#34;. These
    scripts can be found, for example, when unpacking InnoSetup installers using innounp.
    &#34;&#34;&#34;
    def process(self, data):
        return str(IFPSFile(data, self.args.codec)).encode(self.codec)

    @classmethod
    def handles(self, data: bytearray) -&gt; bool:
        return data.startswith(IFPSFile.Magic)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.units.formats.ifps.extended"><code class="name flex">
<span>def <span class="ident">extended</span></span>(<span>_data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L25-L46" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extended(_data: bytes):
    if len(_data) != 10:
        raise ValueError
    data = int.from_bytes(_data, &#39;little&#39;)
    sign = data &gt;&gt; 79
    data = data ^ (sign &lt;&lt; 79)
    sign = -1.0 if sign else +1.0
    exponent = data &gt;&gt; 64
    data = data ^ (exponent &lt;&lt; 64)
    if exponent == 0:
        if data == 0:
            return sign * 0
        exponent = -16382
    elif exponent == 0b111111111111111:
        if data == 0:
            return sign * float(&#39;Inf&#39;)
        else:
            return sign * float(&#39;NaN&#39;)
    else:
        exponent = exponent - 16383
    mantissa = data / (1 &lt;&lt; 64)
    return sign * mantissa * (2 ** exponent)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.ifps.rfix"><code class="name flex">
<span>def <span class="ident">rfix</span></span>(<span>cls)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L49-L52" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rfix(cls: _CLS) -&gt; _CLS:
    cls.__repr__ = lambda self: F&#39;{self.__class__.__name__}.{self.name}&#39;
    cls.__str__ = lambda self: self.name
    return cls</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.ifps.optionals"><code class="name flex">
<span>def <span class="ident">optionals</span></span>(<span>cls)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L184-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def optionals(cls: _CLS) -&gt; Union[_CLS, Type[_OptionsMixin]]:
    class _mixed(_OptionsMixin, cls):
        ...
    assigned = set(WRAPPER_ASSIGNMENTS) - {&#39;__annotations__&#39;}
    update_wrapper(_mixed, cls, assigned=assigned, updated=())
    return dataclass(_mixed)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.ifps.Op"><code class="flex name class">
<span>class <span class="ident">Op</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L56-L92" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Op(enum.IntEnum):
    Assign       = 0x00  # noqa
    Calculate    = 0x01  # noqa
    Push         = 0x02  # noqa
    PushVar      = 0x03  # noqa
    Pop          = 0x04  # noqa
    Call         = 0x05  # noqa
    Jump         = 0x06  # noqa
    JumpTrue     = 0x07  # noqa
    JumpFalse    = 0x08  # noqa
    Ret          = 0x09  # noqa
    StackType    = 0x0A  # noqa
    PushType     = 0x0B  # noqa
    Compare      = 0x0C  # noqa
    CallVar      = 0x0D  # noqa
    SetPtr       = 0x0E  # noqa
    LogicalNot   = 0x0F  # noqa
    Neg          = 0x10  # noqa
    SetFlag      = 0x11  # noqa
    JumpFlag     = 0x12  # noqa
    PushEH       = 0x13  # noqa
    PopEH        = 0x14  # noqa
    Not          = 0x15  # noqa
    SetCopyPtr   = 0x16  # noqa
    Inc          = 0x17  # noqa
    Dec          = 0x18  # noqa
    JumpPop1     = 0x19  # noqa
    JumpPop2     = 0x1A  # noqa
    Nop          = 0xFF  # noqa
    _INVALID     = 0xDD  # noqa

    @classmethod
    def FromInt(cls, code: int):
        try:
            return cls(code)
        except ValueError:
            return cls._INVALID</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.Op.Assign"><code class="name">var <span class="ident">Assign</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Calculate"><code class="name">var <span class="ident">Calculate</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Push"><code class="name">var <span class="ident">Push</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.PushVar"><code class="name">var <span class="ident">PushVar</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Pop"><code class="name">var <span class="ident">Pop</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Call"><code class="name">var <span class="ident">Call</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Jump"><code class="name">var <span class="ident">Jump</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.JumpTrue"><code class="name">var <span class="ident">JumpTrue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.JumpFalse"><code class="name">var <span class="ident">JumpFalse</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Ret"><code class="name">var <span class="ident">Ret</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.StackType"><code class="name">var <span class="ident">StackType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.PushType"><code class="name">var <span class="ident">PushType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Compare"><code class="name">var <span class="ident">Compare</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.CallVar"><code class="name">var <span class="ident">CallVar</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.SetPtr"><code class="name">var <span class="ident">SetPtr</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.LogicalNot"><code class="name">var <span class="ident">LogicalNot</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Neg"><code class="name">var <span class="ident">Neg</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.SetFlag"><code class="name">var <span class="ident">SetFlag</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.JumpFlag"><code class="name">var <span class="ident">JumpFlag</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.PushEH"><code class="name">var <span class="ident">PushEH</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.PopEH"><code class="name">var <span class="ident">PopEH</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Not"><code class="name">var <span class="ident">Not</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.SetCopyPtr"><code class="name">var <span class="ident">SetCopyPtr</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Inc"><code class="name">var <span class="ident">Inc</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Dec"><code class="name">var <span class="ident">Dec</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.JumpPop1"><code class="name">var <span class="ident">JumpPop1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.JumpPop2"><code class="name">var <span class="ident">JumpPop2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Op.Nop"><code class="name">var <span class="ident">Nop</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.Op.FromInt"><code class="name flex">
<span>def <span class="ident">FromInt</span></span>(<span>code)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L87-L92" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def FromInt(cls, code: int):
    try:
        return cls(code)
    except ValueError:
        return cls._INVALID</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.TC"><code class="flex name class">
<span>class <span class="ident">TC</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L96-L156" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TC(int, enum.Enum):
    ReturnAddress       = 0x00  # noqa
    U08                 = 0x01  # noqa
    S08                 = 0x02  # noqa
    U16                 = 0x03  # noqa
    S16                 = 0x04  # noqa
    U32                 = 0x05  # noqa
    S32                 = 0x06  # noqa
    Single              = 0x07  # noqa
    Double              = 0x08  # noqa
    Extended            = 0x09  # noqa
    String              = 0x0A  # noqa
    Record              = 0x0B  # noqa
    Array               = 0x0C  # noqa
    Pointer             = 0x0D  # noqa
    PChar               = 0x0E  # noqa
    ResourcePointer     = 0x0F  # noqa
    Variant             = 0x10  # noqa
    S64                 = 0x11  # noqa
    Char                = 0x12  # noqa
    WideString          = 0x13  # noqa
    WideChar            = 0x14  # noqa
    ProcPtr             = 0x15  # noqa
    Tuple               = 0x16  # noqa
    Set                 = 0x17  # noqa
    Currency            = 0x18  # noqa
    Class               = 0x19  # noqa
    Interface           = 0x1A  # noqa
    NotificationVariant = 0x1B  # noqa
    UnicodeString       = 0x1C  # noqa
    Enum                = 0x81  # noqa
    Type                = 0x82  # noqa
    ExtClass            = 0x83  # noqa

    @property
    def width(self):
        return {
            TC.Variant       : 0x10,
            TC.Char          : 0x01,
            TC.S08           : 0x01,
            TC.U08           : 0x01,
            TC.WideChar      : 0x02,
            TC.S16           : 0x02,
            TC.U16           : 0x02,
            TC.WideString    : 0x04,
            TC.UnicodeString : 0x04,
            TC.Interface     : 0x04,
            TC.Class         : 0x04,
            TC.PChar         : 0x04,
            TC.String        : 0x04,
            TC.Single        : 0x04,
            TC.S32           : 0x04,
            TC.U32           : 0x04,
            TC.ProcPtr       : 0x0C,
            TC.Currency      : 0x08,
            TC.Pointer       : 0x0C,
            TC.Double        : 0x08,
            TC.S64           : 0x08,
            TC.Extended      : 0x0A,
            TC.ReturnAddress : 0x1C,
        }.get(self, 0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TC.ReturnAddress"><code class="name">var <span class="ident">ReturnAddress</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.U08"><code class="name">var <span class="ident">U08</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.S08"><code class="name">var <span class="ident">S08</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.U16"><code class="name">var <span class="ident">U16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.S16"><code class="name">var <span class="ident">S16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.U32"><code class="name">var <span class="ident">U32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.S32"><code class="name">var <span class="ident">S32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Single"><code class="name">var <span class="ident">Single</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Double"><code class="name">var <span class="ident">Double</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Extended"><code class="name">var <span class="ident">Extended</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.String"><code class="name">var <span class="ident">String</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Record"><code class="name">var <span class="ident">Record</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Array"><code class="name">var <span class="ident">Array</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Pointer"><code class="name">var <span class="ident">Pointer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.PChar"><code class="name">var <span class="ident">PChar</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.ResourcePointer"><code class="name">var <span class="ident">ResourcePointer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Variant"><code class="name">var <span class="ident">Variant</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.S64"><code class="name">var <span class="ident">S64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Char"><code class="name">var <span class="ident">Char</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.WideString"><code class="name">var <span class="ident">WideString</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.WideChar"><code class="name">var <span class="ident">WideChar</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.ProcPtr"><code class="name">var <span class="ident">ProcPtr</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Tuple"><code class="name">var <span class="ident">Tuple</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Set"><code class="name">var <span class="ident">Set</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Currency"><code class="name">var <span class="ident">Currency</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Class"><code class="name">var <span class="ident">Class</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Interface"><code class="name">var <span class="ident">Interface</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.NotificationVariant"><code class="name">var <span class="ident">NotificationVariant</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.UnicodeString"><code class="name">var <span class="ident">UnicodeString</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Enum"><code class="name">var <span class="ident">Enum</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.Type"><code class="name">var <span class="ident">Type</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TC.ExtClass"><code class="name">var <span class="ident">ExtClass</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TC.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L130-L156" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def width(self):
    return {
        TC.Variant       : 0x10,
        TC.Char          : 0x01,
        TC.S08           : 0x01,
        TC.U08           : 0x01,
        TC.WideChar      : 0x02,
        TC.S16           : 0x02,
        TC.U16           : 0x02,
        TC.WideString    : 0x04,
        TC.UnicodeString : 0x04,
        TC.Interface     : 0x04,
        TC.Class         : 0x04,
        TC.PChar         : 0x04,
        TC.String        : 0x04,
        TC.Single        : 0x04,
        TC.S32           : 0x04,
        TC.U32           : 0x04,
        TC.ProcPtr       : 0x0C,
        TC.Currency      : 0x08,
        TC.Pointer       : 0x0C,
        TC.Double        : 0x08,
        TC.S64           : 0x08,
        TC.Extended      : 0x0A,
        TC.ReturnAddress : 0x1C,
    }.get(self, 0)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.TGeneric"><code class="flex name class">
<span>class <span class="ident">TGeneric</span></span>
<span>(</span><span>code)</span>
</code></dt>
<dd>
<section class="desc"><p>TGeneric(code: 'TC')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L194-L195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TGeneric(_TypeBase):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>refinery.units.formats.ifps._TypeBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.ifps.TGeneric" href="#refinery.units.formats.ifps.TGeneric">TGeneric</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TGeneric.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.TProcPtr"><code class="flex name class">
<span>class <span class="ident">TProcPtr</span></span>
<span>(</span><span>code, body)</span>
</code></dt>
<dd>
<section class="desc"><p>TProcPtr(code: 'TC', body: 'bytes')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L200-L205" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TProcPtr(_TypeBase):
    body: bytes

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.body.hex()})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>refinery.units.formats.ifps._TypeBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.ifps.TProcPtr" href="#refinery.units.formats.ifps.TProcPtr">TProcPtr</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TProcPtr.body"><code class="name">var <span class="ident">body</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.TProcPtr.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L203-L205" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def display(self, indent=0):
    display = super().display(indent)
    return F&#39;{display}({self.body.hex()})&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.TInterface"><code class="flex name class">
<span>class <span class="ident">TInterface</span></span>
<span>(</span><span>code, uuid)</span>
</code></dt>
<dd>
<section class="desc"><p>TInterface(code: 'TC', uuid: 'uuid.UUID')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L210-L215" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TInterface(_TypeBase):
    uuid: uuid.UUID

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.uuid!s})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>refinery.units.formats.ifps._TypeBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.ifps.TInterface" href="#refinery.units.formats.ifps.TInterface">TInterface</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TInterface.uuid"><code class="name">var <span class="ident">uuid</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.TInterface.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L213-L215" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def display(self, indent=0):
    display = super().display(indent)
    return F&#39;{display}({self.uuid!s})&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.TClass"><code class="flex name class">
<span>class <span class="ident">TClass</span></span>
<span>(</span><span>code, name)</span>
</code></dt>
<dd>
<section class="desc"><p>TClass(code: 'TC', name: 'str')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L220-L225" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TClass(_TypeBase):
    name: str

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.name})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>refinery.units.formats.ifps._TypeBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.ifps.TClass" href="#refinery.units.formats.ifps.TClass">TClass</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TClass.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.TClass.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L223-L225" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def display(self, indent=0):
    display = super().display(indent)
    return F&#39;{display}({self.name})&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.TSet"><code class="flex name class">
<span>class <span class="ident">TSet</span></span>
<span>(</span><span>code, size)</span>
</code></dt>
<dd>
<section class="desc"><p>TSet(code: 'TC', size: 'int')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L230-L240" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TSet(_TypeBase):
    size: int

    @property
    def size_in_bytes(self):
        q, r = divmod(self.size, 8)
        return q + (r and 1 or 0)

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.size})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>refinery.units.formats.ifps._TypeBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.ifps.TSet" href="#refinery.units.formats.ifps.TSet">TSet</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TSet.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TSet.size_in_bytes"><code class="name">var <span class="ident">size_in_bytes</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L233-L236" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def size_in_bytes(self):
    q, r = divmod(self.size, 8)
    return q + (r and 1 or 0)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.TSet.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L238-L240" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def display(self, indent=0):
    display = super().display(indent)
    return F&#39;{display}({self.size})&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.TArray"><code class="flex name class">
<span>class <span class="ident">TArray</span></span>
<span>(</span><span>code, type)</span>
</code></dt>
<dd>
<section class="desc"><p>TArray(code: 'TC', type: 'TGeneric')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L245-L253" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TArray(_TypeBase):
    type: TGeneric

    def display(self, indent=0):
        display = F&#39;{_TAB * indent}{self.type!s}&#39;
        return F&#39;{display}[]&#39;

    def simple(self, nested=False):
        return self.type.simple(nested)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>refinery.units.formats.ifps._TypeBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.ifps.TArray" href="#refinery.units.formats.ifps.TArray">TArray</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TArray.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.TArray.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L248-L250" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def display(self, indent=0):
    display = F&#39;{_TAB * indent}{self.type!s}&#39;
    return F&#39;{display}[]&#39;</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.ifps.TArray.simple"><code class="name flex">
<span>def <span class="ident">simple</span></span>(<span>self, nested=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L252-L253" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def simple(self, nested=False):
    return self.type.simple(nested)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.TTuple"><code class="flex name class">
<span>class <span class="ident">TTuple</span></span>
<span>(</span><span>code, type, size, offset=None)</span>
</code></dt>
<dd>
<section class="desc"><p>TTuple(code: 'TC', type: 'TGeneric', size: 'int', offset: 'Optional[int]' = None)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L258-L268" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TTuple(_TypeBase):
    type: TGeneric
    size: int
    offset: Optional[int] = None

    def display(self, indent=0):
        display = F&#39;{_TAB * indent}{self.type!s}&#39;
        return F&#39;{display}[{self.size}]&#39;

    def simple(self, nested=False):
        return self.type.simple(nested)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>refinery.units.formats.ifps._TypeBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.ifps.TTuple" href="#refinery.units.formats.ifps.TTuple">TTuple</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TTuple.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TTuple.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.TTuple.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.TTuple.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L263-L265" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def display(self, indent=0):
    display = F&#39;{_TAB * indent}{self.type!s}&#39;
    return F&#39;{display}[{self.size}]&#39;</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.ifps.TTuple.simple"><code class="name flex">
<span>def <span class="ident">simple</span></span>(<span>self, nested=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L267-L268" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def simple(self, nested=False):
    return self.type.simple(nested)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.TRecord"><code class="flex name class">
<span>class <span class="ident">TRecord</span></span>
<span>(</span><span>code, members)</span>
</code></dt>
<dd>
<section class="desc"><p>TRecord(code: 'TC', members: 'Tuple[TGeneric, &hellip;]')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L273-L298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TRecord(_TypeBase):
    members: Tuple[TGeneric, ...]

    def simple(self, nested=False):
        if nested:
            return False
        if len(self.members) &gt; 10:
            return False
        return all(m.simple(True) for m in self.members)

    def display(self, indent=0):
        output = io.StringIO()
        output.write(indent * _TAB)
        output.write(&#39;struct {&#39;)
        if self.simple():
            output.write(&#39;, &#39;.join(str(m) for m in self.members))
        else:
            for k, member in enumerate(self.members):
                if k &gt; 0:
                    output.write(&#39;,&#39;)
                output.write(&#39;\n&#39;)
                output.write(member.display(indent + 1))
            if self.members:
                output.write(F&#39;\n{_TAB * indent}&#39;)
        output.write(&#39;}&#39;)
        return output.getvalue()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>refinery.units.formats.ifps._TypeBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.ifps.TRecord" href="#refinery.units.formats.ifps.TRecord">TRecord</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.TRecord.members"><code class="name">var <span class="ident">members</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.TRecord.simple"><code class="name flex">
<span>def <span class="ident">simple</span></span>(<span>self, nested=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L276-L281" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def simple(self, nested=False):
    if nested:
        return False
    if len(self.members) &gt; 10:
        return False
    return all(m.simple(True) for m in self.members)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.ifps.TRecord.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L283-L298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def display(self, indent=0):
    output = io.StringIO()
    output.write(indent * _TAB)
    output.write(&#39;struct {&#39;)
    if self.simple():
        output.write(&#39;, &#39;.join(str(m) for m in self.members))
    else:
        for k, member in enumerate(self.members):
            if k &gt; 0:
                output.write(&#39;,&#39;)
            output.write(&#39;\n&#39;)
            output.write(member.display(indent + 1))
        if self.members:
            output.write(F&#39;\n{_TAB * indent}&#39;)
    output.write(&#39;}&#39;)
    return output.getvalue()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.Value"><code class="flex name class">
<span>class <span class="ident">Value</span></span>
<span>(</span><span>type, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Value(type, value)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L304-L315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Value(NamedTuple):
    type: TGeneric
    value: Union[str, int, float, bytes]

    def __repr__(self):
        value = self.value
        if isinstance(value, bytes):
            value = value.hex()
        return F&#39;{self.type.code.name}({value!r})&#39;

    def __str__(self):
        return repr(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.Value.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Value.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.Attribute"><code class="flex name class">
<span>class <span class="ident">Attribute</span></span>
<span>(</span><span>name, fields)</span>
</code></dt>
<dd>
<section class="desc"><p>Attribute(name, fields)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L318-L326" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Attribute(NamedTuple):
    name: str
    fields: Tuple[Value, ...]

    def __repr__(self):
        name = self.name
        if self.fields:
            name += &#39;[{}]&#39;.format(&#39;,&#39;.join(repr(f) for f in self.fields))
        return name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.Attribute.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Attribute.fields"><code class="name">var <span class="ident">fields</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpecParam"><code class="flex name class">
<span>class <span class="ident">DeclSpecParam</span></span>
<span>(</span><span>mode_in, type=None)</span>
</code></dt>
<dd>
<section class="desc"><p>DeclSpecParam(mode_in, type)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L329-L331" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DeclSpecParam(NamedTuple):
    mode_in: bool
    type: Optional[TGeneric] = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.DeclSpecParam.mode_in"><code class="name">var <span class="ident">mode_in</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpecParam.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec"><code class="flex name class">
<span>class <span class="ident">DeclSpec</span></span>
<span>(</span><span>void, parameters, name='', calling_convention=None, return_type=None, module=None, classname=None, delay_load=False, load_with_altered_search_path=False, is_property=False)</span>
</code></dt>
<dd>
<section class="desc"><p>DeclSpec(void: 'bool', parameters: 'List[DeclSpecParam]', name: 'str' = '', calling_convention: 'Optional[str]' = None, return_type: 'Optional[TGeneric]' = None, module: 'Optional[str]' = None, classname: 'Optional[str]' = None, delay_load: 'bool' = False, load_with_altered_search_path: 'bool' = False, is_property: 'bool' = False)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L335-L448" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DeclSpec:

    void: bool
    parameters: List[DeclSpecParam]
    name: str = &#39;&#39;
    calling_convention: Optional[str] = None
    return_type: Optional[TGeneric] = None
    module: Optional[str] = None
    classname: Optional[str] = None
    delay_load: bool = False
    load_with_altered_search_path: bool = False
    is_property: bool = False

    def represent(self, name: str, ref: bool = False):
        def pparam(k: int, p: DeclSpecParam):
            name = F&#39;{VariantType.Argument!s}{k}&#39;
            if p.type is not None:
                name = F&#39;{name}: {p.type!s}&#39;
            if not p.mode_in:
                name = F&#39;*{name}&#39;
            return name
        if self.name and name in self.name:
            name = self.name
        spec = name
        if self.classname:
            spec = F&#39;{self.classname}.{spec}&#39;
        if self.module:
            spec = F&#39;{self.module}::{spec}&#39;
        if not ref:
            if self.delay_load:
                spec = F&#39;__delay_load {spec}&#39;
            if self.calling_convention:
                spec = F&#39;__{self.calling_convention} {spec}&#39;
            spec = F&#39;{self.type} {spec}&#39;
            args = self.parameters
            args = args and &#39;, &#39;.join(pparam(*t) for t in enumerate(args)) or &#39;&#39;
            spec = F&#39;{spec}({args})&#39;
            if self.return_type:
                spec = F&#39;{spec} -&gt; {self.return_type.code.name}&#39;
        return spec

    @property
    def type(self):
        return &#39;sub&#39; if self.void else &#39;function&#39;

    def __repr__(self):
        return self.represent(self.name or &#39;(*)&#39;)

    @classmethod
    def ParseF(cls, reader: StructReader[bytes], load_flags: bool):
        def ascii():
            return reader.read_c_string(&#39;latin1&#39;)

        def boolean():
            return bool(reader.u8())

        def cc():
            return {
                0: &#39;register&#39;,
                1: &#39;pascal&#39;,
                2: &#39;cdecl&#39;,
                3: &#39;stdcall&#39;,
            }.get(reader.u8(), cls.calling_convention)

        kw = {}
        parameters = None
        if reader.peek(4) == b&#39;dll:&#39;:
            reader.seekrel(4)
            if reader.peek(6) == B&#39;files:&#39;:
                reader.seekrel(6)
            kw.update(module=ascii(), name=ascii(), calling_convention=cc())
            if load_flags:
                kw.update(delay_load=boolean(), load_with_altered_search_path=boolean())
            void = not boolean()
        elif reader.peek(6) == b&#39;class:&#39;:
            reader.seekrel(6)
            if reader.remaining_bytes == 1:
                rest = reader.peek(1)
                void = False
                parameters = [DeclSpecParam(False)]
                kw.update(
                    classname=&#39;Class&#39;,
                    name={b&#39;+&#39;: &#39;CastToType&#39;, B&#39;-&#39;: &#39;SetNil&#39;}.get(rest),
                    calling_convention=&#39;pascal&#39;,
                )
            else:
                kw.update(classname=reader.read_terminated_array(b&#39;|&#39;).decode(&#39;latin1&#39;))
                name = reader.read_terminated_array(b&#39;|&#39;).decode(&#39;latin1&#39;)
                if name[-1] == &#39;@&#39;:
                    kw.update(is_property=True)
                    name = name[:-1]
                kw.update(name=name, calling_convention=cc())
                void = not reader.u8()
        else:
            void = not reader.u8()
        if parameters is not None:
            parameters = [DeclSpecParam(bool(b)) for b in reader.read()]
        return cls(void, parameters, **kw)

    @classmethod
    def ParseE(cls, data: bytes, ipfs: IFPSFile):
        decl = data.split(B&#39;\x20&#39;)
        return_type = int(decl.pop(0))
        void = return_type == -1
        if not void:
            return_type = ipfs.types[return_type]
        else:
            return_type = None
        parameters = []
        for param in decl:
            mode_in = param[0] == B&#39;@&#39;[0]
            ti = int(param[1:])
            parameters.append(DeclSpecParam(mode_in, ipfs.types[ti]))
        return cls(void, parameters, return_type=return_type)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.DeclSpec.void"><code class="name">var <span class="ident">void</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec.parameters"><code class="name">var <span class="ident">parameters</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec.calling_convention"><code class="name">var <span class="ident">calling_convention</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec.return_type"><code class="name">var <span class="ident">return_type</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec.module"><code class="name">var <span class="ident">module</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec.classname"><code class="name">var <span class="ident">classname</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec.delay_load"><code class="name">var <span class="ident">delay_load</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec.load_with_altered_search_path"><code class="name">var <span class="ident">load_with_altered_search_path</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec.is_property"><code class="name">var <span class="ident">is_property</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.DeclSpec.ParseF"><code class="name flex">
<span>def <span class="ident">ParseF</span></span>(<span>reader, load_flags)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L383-L432" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def ParseF(cls, reader: StructReader[bytes], load_flags: bool):
    def ascii():
        return reader.read_c_string(&#39;latin1&#39;)

    def boolean():
        return bool(reader.u8())

    def cc():
        return {
            0: &#39;register&#39;,
            1: &#39;pascal&#39;,
            2: &#39;cdecl&#39;,
            3: &#39;stdcall&#39;,
        }.get(reader.u8(), cls.calling_convention)

    kw = {}
    parameters = None
    if reader.peek(4) == b&#39;dll:&#39;:
        reader.seekrel(4)
        if reader.peek(6) == B&#39;files:&#39;:
            reader.seekrel(6)
        kw.update(module=ascii(), name=ascii(), calling_convention=cc())
        if load_flags:
            kw.update(delay_load=boolean(), load_with_altered_search_path=boolean())
        void = not boolean()
    elif reader.peek(6) == b&#39;class:&#39;:
        reader.seekrel(6)
        if reader.remaining_bytes == 1:
            rest = reader.peek(1)
            void = False
            parameters = [DeclSpecParam(False)]
            kw.update(
                classname=&#39;Class&#39;,
                name={b&#39;+&#39;: &#39;CastToType&#39;, B&#39;-&#39;: &#39;SetNil&#39;}.get(rest),
                calling_convention=&#39;pascal&#39;,
            )
        else:
            kw.update(classname=reader.read_terminated_array(b&#39;|&#39;).decode(&#39;latin1&#39;))
            name = reader.read_terminated_array(b&#39;|&#39;).decode(&#39;latin1&#39;)
            if name[-1] == &#39;@&#39;:
                kw.update(is_property=True)
                name = name[:-1]
            kw.update(name=name, calling_convention=cc())
            void = not reader.u8()
    else:
        void = not reader.u8()
    if parameters is not None:
        parameters = [DeclSpecParam(bool(b)) for b in reader.read()]
    return cls(void, parameters, **kw)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.ifps.DeclSpec.ParseE"><code class="name flex">
<span>def <span class="ident">ParseE</span></span>(<span>data, ipfs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L434-L448" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def ParseE(cls, data: bytes, ipfs: IFPSFile):
    decl = data.split(B&#39;\x20&#39;)
    return_type = int(decl.pop(0))
    void = return_type == -1
    if not void:
        return_type = ipfs.types[return_type]
    else:
        return_type = None
    parameters = []
    for param in decl:
        mode_in = param[0] == B&#39;@&#39;[0]
        ti = int(param[1:])
        parameters.append(DeclSpecParam(mode_in, ipfs.types[ti]))
    return cls(void, parameters, return_type=return_type)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.DeclSpec.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L376-L378" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def type(self):
    return &#39;sub&#39; if self.void else &#39;function&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.DeclSpec.represent"><code class="name flex">
<span>def <span class="ident">represent</span></span>(<span>self, name, ref=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L348-L374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def represent(self, name: str, ref: bool = False):
    def pparam(k: int, p: DeclSpecParam):
        name = F&#39;{VariantType.Argument!s}{k}&#39;
        if p.type is not None:
            name = F&#39;{name}: {p.type!s}&#39;
        if not p.mode_in:
            name = F&#39;*{name}&#39;
        return name
    if self.name and name in self.name:
        name = self.name
    spec = name
    if self.classname:
        spec = F&#39;{self.classname}.{spec}&#39;
    if self.module:
        spec = F&#39;{self.module}::{spec}&#39;
    if not ref:
        if self.delay_load:
            spec = F&#39;__delay_load {spec}&#39;
        if self.calling_convention:
            spec = F&#39;__{self.calling_convention} {spec}&#39;
        spec = F&#39;{self.type} {spec}&#39;
        args = self.parameters
        args = args and &#39;, &#39;.join(pparam(*t) for t in enumerate(args)) or &#39;&#39;
        spec = F&#39;{spec}({args})&#39;
        if self.return_type:
            spec = F&#39;{spec} -&gt; {self.return_type.code.name}&#39;
    return spec</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.Function"><code class="flex name class">
<span>class <span class="ident">Function</span></span>
<span>(</span><span>name, decl, body=None, exported=False, attributes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Function(name, decl, body, exported, attributes)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L451-L472" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Function(NamedTuple):
    name: str
    decl: Optional[DeclSpec]
    body: Optional[List[Instruction]] = None
    exported: bool = False
    attributes: Optional[List[Attribute]] = None

    def reference(self) -&gt; str:
        if self.decl is None:
            return self.name
        return self.decl.represent(self.name, ref=True)

    def __repr__(self):
        if self.decl is None:
            return F&#39;symbol {self.name}&#39;
        return self.decl.represent(self.name)

    @property
    def type(self):
        if self.decl is None:
            return &#39;symbol&#39;
        return self.decl.type</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.Function.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Function.decl"><code class="name">var <span class="ident">decl</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Function.body"><code class="name">var <span class="ident">body</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Function.exported"><code class="name">var <span class="ident">exported</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Function.attributes"><code class="name">var <span class="ident">attributes</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 4</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Function.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L468-L472" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def type(self):
    if self.decl is None:
        return &#39;symbol&#39;
    return self.decl.type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.ifps.Function.reference"><code class="name flex">
<span>def <span class="ident">reference</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L458-L461" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reference(self) -&gt; str:
    if self.decl is None:
        return self.name
    return self.decl.represent(self.name, ref=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.Variable"><code class="flex name class">
<span>class <span class="ident">Variable</span></span>
<span>(</span><span>index, flags, type, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Variable(index, flags, type, name)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L475-L482" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Variable(NamedTuple):
    index: int
    flags: int
    type: TGeneric
    name: str

    def __repr__(self):
        return F&#39;{self.name}: {self.type!s}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.Variable.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Variable.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Variable.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Variable.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.OperandType"><code class="flex name class">
<span>class <span class="ident">OperandType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L486-L490" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class OperandType(enum.IntEnum):
    Variant = 0
    Value = 1
    IndexedInt = 2
    IndexedVar = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.OperandType.Variant"><code class="name">var <span class="ident">Variant</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.OperandType.Value"><code class="name">var <span class="ident">Value</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.OperandType.IndexedInt"><code class="name">var <span class="ident">IndexedInt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.OperandType.IndexedVar"><code class="name">var <span class="ident">IndexedVar</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.VariantType"><code class="flex name class">
<span>class <span class="ident">VariantType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L493-L503" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VariantType(str, enum.Enum):
    Global = &#39;GlobalVar&#39;
    ReturnValue = &#39;ReturnValue&#39;
    Variable = &#39;LocalVar&#39;
    Argument = &#39;Argument&#39;

    def __repr__(self):
        return self.name

    def __str__(self):
        return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.VariantType.Global"><code class="name">var <span class="ident">Global</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.VariantType.ReturnValue"><code class="name">var <span class="ident">ReturnValue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.VariantType.Variable"><code class="name">var <span class="ident">Variable</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.VariantType.Argument"><code class="name">var <span class="ident">Argument</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.Variant"><code class="flex name class">
<span>class <span class="ident">Variant</span></span>
<span>(</span><span>index, type)</span>
</code></dt>
<dd>
<section class="desc"><p>Variant(index, type)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L506-L511" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Variant(NamedTuple):
    index: int
    type: VariantType

    def __repr__(self):
        return F&#39;{self.type!s}{self.index}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.Variant.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Variant.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.Operand"><code class="flex name class">
<span>class <span class="ident">Operand</span></span>
<span>(</span><span>type, variant=None, value=None, index=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Operand(type, variant, value, index)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L514-L529" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Operand(NamedTuple):
    type: OperandType
    variant: Optional[Variant] = None
    value: Optional[Value] = None
    index: Optional[Union[Variant, int]] = None

    def __repr__(self):
        if self.type is OperandType.Value:
            return str(self.value)
        if self.type is OperandType.Variant:
            return F&#39;{self.variant}&#39;
        if self.type is OperandType.IndexedInt:
            return F&#39;{self.variant}[0x{self.index:02X}]&#39;
        if self.type is OperandType.IndexedVar:
            return F&#39;{self.variant}[{self.index!s}]&#39;
        raise RuntimeError(F&#39;Unexpected OperandType {self.type!r} in {self.__class__.__name__}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.Operand.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Operand.variant"><code class="name">var <span class="ident">variant</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Operand.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="refinery.units.formats.ifps.Operand.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.Instruction"><code class="flex name class">
<span>class <span class="ident">Instruction</span></span>
<span>(</span><span>offset, opcode, operands=&lt;factory&gt;, jumptarget=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Instruction(offset: 'int', opcode: 'Op', operands: 'List[Union[str, int, Operand, TGeneric]]' = <factory>, jumptarget: 'bool' = False)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L536-L570" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Instruction:
    offset: int
    opcode: Op
    operands: List[Union[str, int, Operand, TGeneric]] = field(default_factory=list)
    jumptarget: bool = False

    def _oprep(self, fuse_index=None, is_jump=False):
        if fuse_index is None:
            operands = list(self.operands)
        else:
            rest = self.operands[fuse_index:]
            rest = &#39;\x20&#39;.join((str(op) for op in rest))
            operands = [*self.operands[:fuse_index], rest]
        if is_jump:
            operands[0] = F&#39;0x{operands[0]:X}&#39;
        return &#39;, &#39;.join(str(op) for op in operands)

    def __repr__(self):
        return F&#39;{self.opcode.name}({self._oprep()})&#39;

    def __str__(self):
        fuse = None
        if self.opcode is Op.Compare:
            fuse = 1
        if self.opcode is Op.Calculate:
            fuse = 0
        jmp = self.opcode in (
            Op.Jump,
            Op.JumpFalse,
            Op.JumpTrue,
            Op.JumpFlag,
            Op.JumpPop1,
            Op.JumpPop2,
        )
        return F&#39;{self.opcode!s:&lt;{_Op_Maxlen}}{_TAB}{self._oprep(fuse, jmp)}&#39;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.Instruction.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Instruction.opcode"><code class="name">var <span class="ident">opcode</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Instruction.operands"><code class="name">var <span class="ident">operands</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.Instruction.jumptarget"><code class="name">var <span class="ident">jumptarget</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.IFPSFile"><code class="flex name class">
<span>class <span class="ident">IFPSFile</span></span>
<span>(</span><span>reader, codec)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L573-L905" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IFPSFile(Struct):
    MinVer = 12
    MaxVer = 23

    Magic = B&#39;IFPS&#39;

    def __init__(self, reader: StructReader[memoryview], codec: str):
        self.codec = codec
        self.types: List[TType] = []
        self.functions: List[Function] = []
        self.variables: List[Variable] = []
        self.strings: List[str] = []
        self.reader = reader
        if reader.remaining_bytes &lt; 28:
            raise ValueError(&#39;Less than 28 bytes in file, not enough data to parse.&#39;)
        magic = reader.read(4)
        if magic != self.Magic:
            raise ValueError(F&#39;Invalid magic sequence: {magic.hex()}&#39;)
        self.version = reader.u32()
        self.count_types = reader.u32()
        self.count_functions = reader.u32()
        self.count_variables = reader.u32()
        self.entry = reader.u32()
        self.import_size = reader.u32()
        self.void = False
        if self.version not in range(self.MinVer, self.MaxVer + 1):
            ifps.log_warn(
                F&#39;This IFPS file has version {self.version}, which is not in the supported range &#39;
                F&#39;[{self.MinVer},{self.MaxVer}].&#39;)
        self._load_types()
        self._load_functions()
        self._load_variables()

    @property
    def _load_flags(self):
        return self.version &gt;= 23

    def _load_types(self):
        reader = self.reader
        types = self.types
        for k in range(self.count_types):
            typecode = reader.u8()
            exported = bool(typecode &amp; 0x80)
            typecode = typecode &amp; 0x7F
            try:
                code = TC(typecode)
            except ValueError as V:
                raise ValueError(F&#39;Unknown type code value 0x{typecode:02X}.&#39;) from V
            if code is TC.Class:
                t = TClass(code, reader.read_length_prefixed_ascii())
            elif code is TC.ProcPtr:
                t = TProcPtr(code, reader.read_length_prefixed())
            elif code is TC.Interface:
                guid = uuid.UUID(bytes=bytes(reader.read(0x10)))
                t = TInterface(code, guid)
            elif code is TC.Set:
                t = TSet(code, reader.u32())
            elif code is TC.Tuple:
                type = types[reader.u32()]
                size = reader.u32()
                offset = None if self.version &lt;= 22 else reader.u32()
                t = TTuple(code, type, size, offset)
            elif code is TC.Array:
                t = TArray(code, types[reader.u32()])
            elif code is TC.Record:
                length = reader.u32()
                members = tuple(types[reader.u32()] for _ in range(length))
                t = TRecord(code, members, symbol=F&#39;RECORD{k}&#39;)
            else:
                t = TGeneric(code, symbol=code.name)
            if exported:
                t.symbol = reader.read_length_prefixed_ascii()
                if self.version &lt;= 21:
                    t.name = reader.read_length_prefixed_ascii()
            types.append(t)
            if self.version &gt;= 21:
                t.attributes = list(self._read_attributes())

    def _read_value(self, reader: Optional[StructReader] = None) -&gt; Value:
        if reader is None:
            reader = self.reader
        type = self.types[reader.u32()]
        size = type.code.width
        processor: Optional[Callable[[], Union[int, float, str, bytes]]] = {
            TC.U08           : reader.u8,
            TC.S08           : reader.i8,
            TC.U16           : reader.u16,
            TC.S16           : reader.i16,
            TC.U32           : reader.u32,
            TC.S32           : reader.i32,
            TC.S64           : reader.i64,
            TC.Single        : reader.f32,
            TC.Double        : reader.f64,
            TC.Extended      : lambda: extended(reader.read(10)),
            TC.String        : lambda: reader.read_length_prefixed(encoding=self.codec),
            TC.PChar         : lambda: reader.read_length_prefixed(encoding=self.codec),
            TC.WideString    : reader.read_length_prefixed_utf16,
            TC.UnicodeString : reader.read_length_prefixed_utf16,
            TC.Char          : lambda: chr(reader.u8()),
            TC.WideChar      : lambda: chr(reader.u16()),
            TC.ProcPtr       : reader.u32,
            TC.Set           : lambda: bytes(reader.read(type.size_in_bytes)),
            TC.Currency      : lambda: reader.u64() / 10_000,
        }.get(type.code, None)
        if processor is not None:
            data = processor()
        elif size &gt; 0:
            data = bytes(reader.read(size))
        else:
            raise ValueError(F&#39;Unable to read attribute of type {type!s}.&#39;)
        if isinstance(data, str) and data not in self.strings:
            self.strings.append(data)
        return Value(type, data)

    def _read_attributes(self) -&gt; Generator[Attribute, None, None]:
        reader = self.reader
        count = reader.u32()
        for _ in range(count):
            name = reader.read_length_prefixed_ascii()
            fields = tuple(self._read_value() for _ in range(reader.u32()))
            yield Attribute(name, fields)

    def _load_functions(self):
        reader = self.reader
        width = len(F&#39;{self.count_functions:X}&#39;)
        for k in range(self.count_functions):
            decl = None
            body = None
            name = F&#39;F{k:0{width}X}&#39;
            function_flags = reader.u8()
            attributes = None
            has_attributes = bool(function_flags &amp; 4)
            imported = bool(function_flags &amp; 1)
            exported = bool(function_flags &amp; 2)
            if imported:
                name = reader.read_length_prefixed_ascii(8)
                if exported:
                    read = StructReader(bytes(reader.read_length_prefixed()))
                    decl = DeclSpec.ParseF(read, self._load_flags)
            else:
                offset = reader.u32()
                size = reader.u32()
                with StreamDetour(reader, offset):
                    body = list(self._parse_bytecode(reader.read(size)))
                self.void = False
                if exported:
                    name = reader.read_length_prefixed_ascii()
                    decl = DeclSpec.ParseE(bytes(reader.read_length_prefixed()), self)
                    self.void = decl.void
            if has_attributes:
                attributes = list(self._read_attributes())
            self.functions.append(Function(name, decl, body, exported, attributes))
        for function in self.functions:
            if function.body is None:
                continue
            for instruction in function.body:
                if instruction.opcode is Op.Call:
                    t: Function = self.functions[instruction.operands[0]]
                    instruction.operands[0] = t.reference()

    def _load_variables(self):
        reader = self.reader
        width = len(str(self.count_variables))
        for index in range(self.count_variables):
            tcode = reader.u32()
            flags = reader.u8()
            name = F&#39;{VariantType.Global!s}{index:0{width}}&#39;
            if flags &amp; 1:
                name = reader.read_length_prefixed_ascii()
            self.variables.append(Variable(index, flags, self.types[tcode], name))

    def _read_variant(self, index: int) -&gt; Variant:
        if index &lt; 0x40000000:
            return Variant(index, VariantType.Global)
        index -= 0x60000000
        if index == -1 and not self.void:
            type = VariantType.ReturnValue
        if index &gt;= 0:
            type = VariantType.Variable
        else:
            type = VariantType.Argument
            index = -index
            if self.void:
                index -= 1
        return Variant(index, type)

    def _read_operand(self, reader: StructReader) -&gt; Operand:
        ot = OperandType(reader.u8())
        kw = {}
        if ot is OperandType.Variant:
            kw.update(variant=self._read_variant(reader.u32()))
        if ot is OperandType.Value:
            kw.update(value=self._read_value(reader))
        if ot &gt;= OperandType.IndexedInt:
            kw.update(variant=self._read_variant(reader.u32()))
            index = reader.u32()
            if ot is OperandType.IndexedVar:
                index = self._read_variant(index)
            kw.update(index=index)
        return Operand(ot, **kw)

    def _parse_bytecode(self, data: memoryview) -&gt; Generator[Instruction, None, None]:
        disassembly: Dict[int, Instruction] = OrderedDict()
        reader = StructReader(data)

        argcount = {
            Op.Assign: 2,
            Op.CallVar: 1,
            Op.Dec: 1,
            Op.Inc: 1,
            Op.LogicalNot: 1,
            Op.Neg: 1,
            Op.Not: 1,
            Op.SetCopyPtr: 2,
            Op.SetPtr: 2,
        }

        while not reader.eof:
            def arg(k=1):
                for _ in range(k):
                    args.append(self._read_operand(reader))
            addr = reader.tell()
            cval = reader.u8()
            code = Op.FromInt(cval)
            insn = Instruction(addr, code)
            args = insn.operands
            disassembly[insn.offset] = insn
            aryness = argcount.get(code)
            if aryness is not None:
                arg(aryness)
            elif code in (Op.Ret, Op.Nop, Op.Pop):
                pass
            elif code is Op.Calculate:
                infix = [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;%&#39;, &#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;^&#39;][reader.u8()]
                infix = F&#39;{infix}=&#39;
                a = self._read_operand(reader)
                b = self._read_operand(reader)
                args.extend((a, infix, b))
            elif code in (Op.Push, Op.PushVar):
                arg()
            elif code in (Op.Jump, Op.JumpFlag):
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.Call:
                args.append(reader.u32())
            elif code in (Op.JumpTrue, Op.JumpFalse):
                target = reader.i32()
                val = self._read_operand(reader)
                args.append(reader.tell() + target)
                args.append(val)
            elif code is Op.JumpPop1:
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.JumpPop2:
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.StackType:
                args.append(self._read_variant(reader.u32()))
                args.append(reader.u32())
            elif code is Op.PushType:
                args.append(self.types[reader.u32()])
            elif code is Op.Compare:
                infix = [&#39;&gt;=&#39;, &#39;&lt;=&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;!=&#39;, &#39;==&#39;, &#39;in&#39;, &#39;is&#39;][reader.u8()]
                arg(2)
                args.append(infix)
                arg(1)
            elif code is Op.SetFlag:
                arg()
                args.append(reader.u8())
            elif code is Op.PushEH:
                args.extend(reader.u32() for _ in range(4))
            elif code is Op.PopEH:
                args.append(reader.u8())
            elif code is Op._INVALID:
                raise ValueError(F&#39;Unsupported opcode: 0x{cval:02X}&#39;)
            else:
                raise ValueError(F&#39;Unhandled opcode: {code.name}&#39;)

        for k, instruction in enumerate(disassembly.values()):
            if instruction.opcode in (
                Op.Jump,
                Op.JumpTrue,
                Op.JumpFalse,
                Op.JumpFlag,
                Op.JumpPop1,
                Op.JumpPop2,
            ):
                target = instruction.operands[0]
                try:
                    disassembly[target].jumptarget = True
                except KeyError as K:
                    raise RuntimeError(
                        F&#39;The jump target of instruction {k} at 0x{instruction.offset:X} is invalid; &#39;
                        F&#39;the invalid instruction is a {instruction.opcode.name} to 0x{target:X}.&#39;
                    ) from K

        yield from disassembly.values()

    def __str__(self):
        output = io.StringIO()
        _omax = max((
            max(insn.offset for insn in fn.body)
            for fn in self.functions if fn.body
        ), default=0)
        _omax = max(len(self.types), len(self.variables), _omax)
        width = len(F&#39;{_omax:X}&#39;)

        if self.types:
            for type in self.types:
                if type.code is not TC.Record:
                    continue
                output.write(F&#39;typedef {type.symbol} = {type.display()}\n&#39;)
            output.write(&#39;\n&#39;)

        if self.variables:
            for variable in self.variables:
                output.write(F&#39;{variable!s};\n&#39;)
            output.write(&#39;\n&#39;)

        if self.functions:
            for function in self.functions:
                if function.body is None:
                    output.write(F&#39;external {function!s};\n&#39;)
            output.write(&#39;\n&#39;)
            for function in self.functions:
                if function.body is None:
                    continue
                output.write(F&#39;begin {function!s}\n&#39;)
                for instruction in function.body:
                    output.write(F&#39;{_TAB}0x{instruction.offset:0{width}X}{_TAB}{instruction!s}\n&#39;)
                output.write(F&#39;end {function.type}\n\n&#39;)

        return output.getvalue()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.IFPSFile.MinVer"><code class="name">var <span class="ident">MinVer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.IFPSFile.MaxVer"><code class="name">var <span class="ident">MaxVer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.IFPSFile.Magic"><code class="name">var <span class="ident">Magic</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.ifps.IFPSBase"><code class="flex name class">
<span>class <span class="ident">IFPSBase</span></span>
<span>(</span><span>codec='cp1252')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L908-L914" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IFPSBase(Unit, abstract=True):
    def __init__(
        self,
        codec: Unit.Arg.String(
            help=&#39;Optionally specify the string encoding. The default is &#34;{default}&#34;.&#39;) = &#39;cp1252&#39;
    ):
        super().__init__(codec=codec)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.ifps.ifps" href="#refinery.units.formats.ifps.ifps">ifps</a></li>
<li><a title="refinery.units.formats.ifpsstr.ifpsstr" href="ifpsstr.html#refinery.units.formats.ifpsstr.ifpsstr">ifpsstr</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.IFPSBase.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.IFPSBase.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.Arg" href="../index.html#refinery.units.Unit.Arg">Arg</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.reverse" href="../index.html#refinery.units.UnitBase.reverse">reverse</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.units.formats.ifps.ifps"><code class="flex name class">
<span>class <span class="ident">ifps</span></span>
<span>(</span><span>codec='cp1252')</span>
</code></dt>
<dd>
<section class="desc"><p>Disassembles compiled Pascal script files that start with the magic sequence "IFPS". These
scripts can be found, for example, when unpacking InnoSetup installers using innounp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/formats/ifps.py#L917-L927" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ifps(IFPSBase):
    &#34;&#34;&#34;
    Disassembles compiled Pascal script files that start with the magic sequence &#34;IFPS&#34;. These
    scripts can be found, for example, when unpacking InnoSetup installers using innounp.
    &#34;&#34;&#34;
    def process(self, data):
        return str(IFPSFile(data, self.args.codec)).encode(self.codec)

    @classmethod
    def handles(self, data: bytearray) -&gt; bool:
        return data.startswith(IFPSFile.Magic)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.ifps.IFPSBase" href="#refinery.units.formats.ifps.IFPSBase">IFPSBase</a></li>
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.ifps.ifps.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.ifps.ifps.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.formats.ifps.IFPSBase" href="#refinery.units.formats.ifps.IFPSBase">IFPSBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.formats.ifps.IFPSBase.Arg" href="../index.html#refinery.units.Unit.Arg">Arg</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.reverse" href="../index.html#refinery.units.UnitBase.reverse">reverse</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.formats.ifps.IFPSBase.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.formats" href="index.html">refinery.units.formats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.extended" href="#refinery.units.formats.ifps.extended">extended</a></code></li>
<li><code><a title="refinery.units.formats.ifps.rfix" href="#refinery.units.formats.ifps.rfix">rfix</a></code></li>
<li><code><a title="refinery.units.formats.ifps.optionals" href="#refinery.units.formats.ifps.optionals">optionals</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.ifps.Op" href="#refinery.units.formats.ifps.Op">Op</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.Op.FromInt" href="#refinery.units.formats.ifps.Op.FromInt">FromInt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.TC" href="#refinery.units.formats.ifps.TC">TC</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.TGeneric" href="#refinery.units.formats.ifps.TGeneric">TGeneric</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.TProcPtr" href="#refinery.units.formats.ifps.TProcPtr">TProcPtr</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.TProcPtr.display" href="#refinery.units.formats.ifps.TProcPtr.display">display</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.TInterface" href="#refinery.units.formats.ifps.TInterface">TInterface</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.TInterface.display" href="#refinery.units.formats.ifps.TInterface.display">display</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.TClass" href="#refinery.units.formats.ifps.TClass">TClass</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.TClass.display" href="#refinery.units.formats.ifps.TClass.display">display</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.TSet" href="#refinery.units.formats.ifps.TSet">TSet</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.TSet.display" href="#refinery.units.formats.ifps.TSet.display">display</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.TArray" href="#refinery.units.formats.ifps.TArray">TArray</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.TArray.display" href="#refinery.units.formats.ifps.TArray.display">display</a></code></li>
<li><code><a title="refinery.units.formats.ifps.TArray.simple" href="#refinery.units.formats.ifps.TArray.simple">simple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.TTuple" href="#refinery.units.formats.ifps.TTuple">TTuple</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.TTuple.display" href="#refinery.units.formats.ifps.TTuple.display">display</a></code></li>
<li><code><a title="refinery.units.formats.ifps.TTuple.simple" href="#refinery.units.formats.ifps.TTuple.simple">simple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.TRecord" href="#refinery.units.formats.ifps.TRecord">TRecord</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.TRecord.simple" href="#refinery.units.formats.ifps.TRecord.simple">simple</a></code></li>
<li><code><a title="refinery.units.formats.ifps.TRecord.display" href="#refinery.units.formats.ifps.TRecord.display">display</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.Value" href="#refinery.units.formats.ifps.Value">Value</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.Attribute" href="#refinery.units.formats.ifps.Attribute">Attribute</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.DeclSpecParam" href="#refinery.units.formats.ifps.DeclSpecParam">DeclSpecParam</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.DeclSpec" href="#refinery.units.formats.ifps.DeclSpec">DeclSpec</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.DeclSpec.ParseF" href="#refinery.units.formats.ifps.DeclSpec.ParseF">ParseF</a></code></li>
<li><code><a title="refinery.units.formats.ifps.DeclSpec.ParseE" href="#refinery.units.formats.ifps.DeclSpec.ParseE">ParseE</a></code></li>
<li><code><a title="refinery.units.formats.ifps.DeclSpec.represent" href="#refinery.units.formats.ifps.DeclSpec.represent">represent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.Function" href="#refinery.units.formats.ifps.Function">Function</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.ifps.Function.reference" href="#refinery.units.formats.ifps.Function.reference">reference</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.Variable" href="#refinery.units.formats.ifps.Variable">Variable</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.OperandType" href="#refinery.units.formats.ifps.OperandType">OperandType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.VariantType" href="#refinery.units.formats.ifps.VariantType">VariantType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.Variant" href="#refinery.units.formats.ifps.Variant">Variant</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.Operand" href="#refinery.units.formats.ifps.Operand">Operand</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.Instruction" href="#refinery.units.formats.ifps.Instruction">Instruction</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.IFPSFile" href="#refinery.units.formats.ifps.IFPSFile">IFPSFile</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.IFPSBase" href="#refinery.units.formats.ifps.IFPSBase">IFPSBase</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.ifps.ifps" href="#refinery.units.formats.ifps.ifps">ifps</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>