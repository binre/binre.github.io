<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>the refinery.units.misc.xkey documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.misc.xkey</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/misc/xkey.py#L1-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from __future__ import annotations

from itertools import product
from collections import Counter
from refinery import Unit, Arg

try:
    from Crypto.Util.strxor import strxor
except ImportError:
    def strxor(a, b): return bytes(x ^ y for x, y in zip(a, b))


def _generate_cribs(cribs: bytes | tuple[bytes | tuple[bytes, ...], ...]):
    if isinstance(cribs, bytes):
        yield cribs
        return
    for p in product(*[[c] if isinstance(c, bytes) else c for c in cribs]):
        yield B&#39;&#39;.join(p)


def _cyclic_base(string: bytes):
    n = len(string)
    for p in range(1, n // 2 + 1):
        q = n // p + 1
        k = string[:p]
        t = q * k
        if t.startswith(string):
            return k
    return None


def _S(options: bytes):
    return tuple(bytes((b,)) for b in options)


class xkey(Unit):
    &#34;&#34;&#34;
    The unit expects encrypted input which was encrypted byte-wise with a polyalphabetic key. It
    attempts do determine this key by three methods:

    1. Known plaintext cribs: The unit contains a library of file signatures that are expected to
       occur at specific offsets. It uses these to attempt a known-plaintext attack against the
       input. If a key is found that is at most half the size of such a crib, it is returned.
    2. Known alphabets: For each given key length, the input is split into slices that would have
       been encrypted with a single byte for keys of that length. Each such slice undergoes a
       character frequency analysis. If the histogram indicates that an alphabet of a small size
       was used (i.e. base64), then the unit attempts to determine the key based on this.
    3. Known high frequency glyph: Works if the plaintext contains one letter that occurs with
       very high frequency, i.e. zero padding in PE or ELF files, and the space character in text.
       Based on this assumption, the unit computes the most likely key. This method will work best
       on uncompressed files that were encrypted with a short key.
    &#34;&#34;&#34;

    _CRIBS: dict[range, dict[str, bytes | tuple[bytes | tuple[bytes, ...], ...]]] = {
        range(0, 64, 4): {
            &#39;ZIP&#39;           : (B&#39;PK\x03\x04&#39;, (B&#39;\x14\x00&#39;, B&#39;\x0A\x00&#39;), (B&#39;\x08\x00&#39;, B&#39;\x00\x00&#39;)),
            &#39;RAR&#39;           : (B&#39;Rar!\x1A\x07&#39;, (B&#39;\x01\x00&#39;, B&#39;\x00&#39;)),
            &#39;ZPAQ&#39;          : (B&#39;\x37\x6B\x53\x74\xA0\x31\x83\xD3\x8C\xB2\x28\xB0\xD3\x7A\x50\x51&#39;),
            &#39;ZSTD&#39;          : (B&#39;\x28\xB5\x2F\xFD&#39;),
            &#39;ZZip&#39;          : (B&#39;7z\xBC\xAF\x27\x1C&#39;, (B&#39;\x00\x02&#39;, B&#39;\x00\x03&#39;, B&#39;\x00\x04&#39;)),
            &#39;APLib&#39;         : (B&#39;AP32\x18\0\0\0&#39;),
            &#39;BZip&#39;          : (B&#39;BZh&#39;),
            &#39;DDS&#39;           : (B&#39;\x00\x00\x00\x01Bud1&#39;),
            &#39;ELF&#39;           : (B&#39;\x7FELF&#39;),
            &#39;JavaClass&#39;     : (B&#39;\xCA\xFE\xBA\xBE&#39;),
            &#39;LZIP&#39;          : (B&#39;LZIP&#39;),
            &#39;SZDD&#39;          : (B&#39;SZDD\x88\xF0\x27\x33&#39;),
            &#39;LZMA&#39;          : (B&#39;\x5D\x00\x00\x00&#39;),
            &#39;LZMA/XZ&#39;       : (B&#39;\xFD7zXZ&#39;),
            &#39;LZO&#39;           : (B&#39;\x89\x4c\x5a\x4f\x00\x0d\x0a\x1a\x0a&#39;),
            &#39;MachO/BE&#39;      : (B&#39;\xCA\xFE\xBA\xBE&#39;),
            &#39;MachO/LE&#39;      : (B&#39;\xBE\xBA\xFE\xCA&#39;),
            &#39;MSCF&#39;          : (B&#39;\x0A\x51\xE5\xC0&#39;),
            &#39;OleDocument&#39;   : (B&#39;\xD0\xCF\x11\xE0&#39;),
            &#39;PdfDocument&#39;   : (B&#39;%PDF-&#39;, _S(B&#39;12&#39;), (B&#39;.&#39;), _S(B&#39;0123456789&#39;), _S(B&#39;\r\n&#39;)),
            &#39;SQLite&#39;        : (B&#39;SQLite format 3\0&#39;),
            &#39;GIF&#39;           : (B&#39;GIF87a&#39;, B&#39;GIF89a&#39;),
            &#39;PNG&#39;           : (B&#39;\x89PNG\r\n\x1A\n&#39;),
            &#39;DEX&#39;           : (B&#39;dex\n035\0&#39;),
            &#39;JPG&#39;           : (B&#39;\xFF\xD8\xFF&#39;, _S(B&#39;\xE0\xE1\xEE&#39;), (B&#39;\x00\x10\x4A\x46\x49\x46\x00\x01&#39;, B&#39;&#39;)),
            &#39;OneNote&#39;       : (B&#39;\xE4\x52\x5C\x7B\x8C\xD8\xA7\x4D\xAE\xB1\x53\x78\xD0\x29\x96\xD3&#39;),
            &#39;A3xScript&#39;     : (B&#39;\xA3\x48\x4B\xBE\x98\x6C\x4A\xA9\x99\x4C\x53\x0A\x86\xD6\x48\x7D&#39;),
            &#39;RTFDocument&#39;   : (B&#39;{\\rtf1&#39;, (B&#39;\\adeflang&#39;, B&#39;\\ansi&#39;, B&#39;&#39;)),
            &#39;CallToPop&#39;     : (B&#39;\xE8\0\0\0\0&#39;, (
                               B&#39;\x41\x58&#39;, B&#39;\x41\x59&#39;, B&#39;\x41\x5A&#39;, B&#39;\x41\x5B&#39;,
                                   B&#39;\x58&#39;,     B&#39;\x59&#39;,     B&#39;\x5A&#39;,     B&#39;\x5B&#39;,   # noqa
                                   B&#39;\x5C&#39;,     B&#39;\x5D&#39;,     B&#39;\x5E&#39;,     B&#39;\x5F&#39;,   # noqa
                               )),
            &#39;Cert&#39;          : (B&#39;-----BEGIN CERTIFICATE-----&#39;),
            &#39;PrivateKey&#39;    : (B&#39;-----BEGIN PRIVATE KEY-----&#39;),
            &#39;PrivateKeyDSA&#39; : (B&#39;-----BEGIN DSA PRIVATE KEY-----&#39;),
            &#39;PrivateKeyRSA&#39; : (B&#39;-----BEGIN RSA PRIVATE KEY-----&#39;),
            &#39;PrivateKeySSH&#39; : (B&#39;-----BEGIN OPENSSH PRIVATE KEY-----&#39;),
            &#39;PEM&#39;           : (B&#39;-----BEGIN &#39;),
            &#39;PuTTY-Key&#39;     : (B&#39;PuTTY-User-Key-File-&#39;, (B&#39;2:&#39;, B&#39;3:&#39;)),
            &#39;MsAccess&#39;      : (B&#39;\0\01\0\0Standard &#39;, (B&#39;ACE&#39;, B&#39;Jet&#39;), B&#39; DB&#39;),
        },
        range(0x10, 0x11): {
            &#39;ASAR&#39;          : (B&#39;{&#34;files&#34;:{&#34;&#39;),
        },
        range(0x40): {
            &#39;DocTypeLower&#39;  : (B&#39;&lt;!doctype&#39;),
            &#39;DocTypeUpper&#39;  : (B&#39;&lt;!DOCTYPE&#39;),
            &#39;HTMLLower&#39;     : (B&#39;&lt;html&gt;&#39;),
            &#39;HTMLUpper&#39;     : (B&#39;&lt;HTML&gt;&#39;),
            &#39;XML&#39;           : (B&#39;&lt;?xml version=&#34;&#39;),
            &#39;Ace&#39;           : (B&#39;**ACE**&#39;),
        },
        range(0x40, 0x60): {
            &#39;PEDelphiStub&#39;  : (B&#39;This program cannot be run in DOS mode.&#39;),
            &#39;PEStub&#39;        : (B&#39;This program must be run under Win&#39;, (B&#39;32&#39;, B&#39;64&#39;)),
        },
        range(0xD0, 0xD1): {
            &#39;Tar&#39;           : (B&#39;\x00&#39; * 0x30 + B&#39;ustar&#39;, (B&#39;\x20\x20\x00&#39;, B&#39;\x00\x30\x30&#39;)),
        },
        range(0x200): {
            &#39;EmailReceived&#39; : (B&#39;\nReceived:\x20from&#39;),
            &#39;EmailSubject&#39;  : (B&#39;\nSubject:\x20&#39;),
            &#39;EmailFrom&#39;     : (B&#39;\nFrom:\x20&#39;),
            &#39;EmailTo&#39;       : (B&#39;\nTo:\x20&#39;),
            &#39;PESectionData&#39; : (B&#39;.data\0\0\0&#39;),
            &#39;PESectionText&#39; : (B&#39;.text\0\0\0&#39;),
        },
    }

    _ENC_ALPHABETS = [
        B&#39;0123456789,&#39;,
        B&#39;0123456789;&#39;,
        B&#39;0123456789ABCDEF&#39;,
        B&#39;0123456789abcdef&#39;,
        B&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&#39;,
        B&#39;abcdefghijklmnopqrstuvwxyz234567&#39;,
        B&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/&#39;,
        B&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_&#39;,
    ]

    _WSH_ALPHABET = bytes(set(range(0x20, 0x80)) - {0x3C, 0x3E} | {0x09})

    def __init__(
        self,
        range: Arg.Bounds(help=&#39;range of length values to try in Python slice syntax, the default is {default}.&#39;) = slice(1, 32),
        no_alph: Arg.Switch(&#39;-na&#39;, &#39;--no-alph&#39;, help=&#39;disables search for keys via known encoder alphabets&#39;) = False,
        no_crib: Arg.Switch(&#39;-nc&#39;, &#39;--no-crib&#39;, help=&#39;disables search for keys via known plaintext cribs&#39;) = False,
    ):
        super().__init__(range=range, no_alph=no_alph, no_crib=no_crib)

    def process(self, data: bytearray):
        score = 0
        guess = None
        bounds: slice = self.args.range
        view = memoryview(data)

        n = len(view)

        if n &lt;= 1:
            return view
        if n &gt;= 0x100:
            view = view[:-4]

        start = bounds.start or 1
        stop = min(bounds.stop or n, n)

        if bounds.step is not None:
            step = bounds.step
            if bounds.start is None:
                start *= step
        else:
            step = 1

        self.log_debug(F&#39;received input range [{bounds.start}:{bounds.stop}:{bounds.step}], using [{start}:{stop}:{step}]&#39;)

        if not self.args.no_crib:
            for offsets, cribs_by_type in self._CRIBS.items():
                for name, cribs in cribs_by_type.items():
                    cribs = _generate_cribs(cribs)
                    for offset, crib in product(offsets, cribs):
                        if len(crib) &lt; start:
                            continue
                        if len(crib) &gt; stop:
                            continue
                        if (len(crib) - start) % step != 0:
                            continue
                        test = view[offset:offset + len(crib)]
                        if len(test) != len(crib):
                            continue
                        key = _cyclic_base(strxor(test, crib))
                        if key is not None:
                            self.log_info(F&#39;found key via crib for {name}:&#39;, crib)
                            shift = -offset % len(key)
                            return key[shift:] + key[:shift]

        if not self.args.no_alph:
            alphabets: dict[int, list[bytes]] = {}
            for alphabet in self._ENC_ALPHABETS:
                for suffix in (B&#39;&#39;, B&#39;\x20&#39;, B&#39;\x0A&#39;, B&#39;\x20\x0A&#39;):
                    a = alphabet + suffix
                    alphabets.setdefault(len(a), []).append(a)

            alphabets[len(self._WSH_ALPHABET)] = self._WSH_ALPHABET

        for keylen in range(start, stop + 1, step):
            patches = [view[j::keylen] for j in range(keylen)]
            histograms = [Counter(p) for p in patches]

            if not self.args.no_alph:
                hlc = Counter(len(h) for h in histograms)
                base, coverage = hlc.most_common(1)[0]

                if coverage * 2 &gt; keylen and base in alphabets:
                    self.log_info(F&#39;detected potential plaintext alphabet of size 0x{base:02X} at {keylen}&#39;)
                    keys: dict[bytes, bytes] = {}
                    for alphabet in alphabets[base]:
                        key = bytearray(keylen)
                        for k, patch in enumerate(patches):
                            keybyte = set(range(0x100))
                            for x in patch:
                                keybyte &amp;= {y ^ x for y in alphabet}
                                if len(keybyte) == 1:
                                    key[k] = next(iter(keybyte))
                                    break
                            else:
                                key = None
                                break
                        if key is not None:
                            keys[alphabet] = key
                    if len(keys) == 1:
                        alphabet, key = keys.popitem()
                        return key

            _guess = [h.most_common(1)[0] for h in histograms]
            _score = sum(letter_count for _, letter_count in _guess) / n
            # This scaling accounts for the smaller probability of larger keys. No proper statistical analysis has been
            # conducted to derive it; there might be plenty of room for improvement here.
            _score = _score * ((n - keylen) / (n - 1)) ** keylen

            logmsg = F&#39;got score {_score * 100:5.2f}% for length {keylen}&#39;
            if _score &gt; score:
                self.log_info(logmsg)
                score = _score
                guess = bytearray(value for value, _ in _guess)
            else:
                self.log_debug(logmsg)

        return guess</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.misc.xkey.xkey"><code class="flex name class">
<span>class <span class="ident">xkey</span></span>
<span>(</span><span>range=slice(1, 32, None), no_alph=False, no_crib=False)</span>
</code></dt>
<dd>
<section class="desc"><p>The unit expects encrypted input which was encrypted byte-wise with a polyalphabetic key. It
attempts do determine this key by three methods:</p>
<ol>
<li>Known plaintext cribs: The unit contains a library of file signatures that are expected to
occur at specific offsets. It uses these to attempt a known-plaintext attack against the
input. If a key is found that is at most half the size of such a crib, it is returned.</li>
<li>Known alphabets: For each given key length, the input is split into slices that would have
been encrypted with a single byte for keys of that length. Each such slice undergoes a
character frequency analysis. If the histogram indicates that an alphabet of a small size
was used (i.e. base64), then the unit attempts to determine the key based on this.</li>
<li>Known high frequency glyph: Works if the plaintext contains one letter that occurs with
very high frequency, i.e. zero padding in PE or ELF files, and the space character in text.
Based on this assumption, the unit computes the most likely key. This method will work best
on uncompressed files that were encrypted with a short key.</li>
</ol></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/668af76808fd0a712ccb43c4417a03c18188e85d/refinery/units/misc/xkey.py#L38-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class xkey(Unit):
    &#34;&#34;&#34;
    The unit expects encrypted input which was encrypted byte-wise with a polyalphabetic key. It
    attempts do determine this key by three methods:

    1. Known plaintext cribs: The unit contains a library of file signatures that are expected to
       occur at specific offsets. It uses these to attempt a known-plaintext attack against the
       input. If a key is found that is at most half the size of such a crib, it is returned.
    2. Known alphabets: For each given key length, the input is split into slices that would have
       been encrypted with a single byte for keys of that length. Each such slice undergoes a
       character frequency analysis. If the histogram indicates that an alphabet of a small size
       was used (i.e. base64), then the unit attempts to determine the key based on this.
    3. Known high frequency glyph: Works if the plaintext contains one letter that occurs with
       very high frequency, i.e. zero padding in PE or ELF files, and the space character in text.
       Based on this assumption, the unit computes the most likely key. This method will work best
       on uncompressed files that were encrypted with a short key.
    &#34;&#34;&#34;

    _CRIBS: dict[range, dict[str, bytes | tuple[bytes | tuple[bytes, ...], ...]]] = {
        range(0, 64, 4): {
            &#39;ZIP&#39;           : (B&#39;PK\x03\x04&#39;, (B&#39;\x14\x00&#39;, B&#39;\x0A\x00&#39;), (B&#39;\x08\x00&#39;, B&#39;\x00\x00&#39;)),
            &#39;RAR&#39;           : (B&#39;Rar!\x1A\x07&#39;, (B&#39;\x01\x00&#39;, B&#39;\x00&#39;)),
            &#39;ZPAQ&#39;          : (B&#39;\x37\x6B\x53\x74\xA0\x31\x83\xD3\x8C\xB2\x28\xB0\xD3\x7A\x50\x51&#39;),
            &#39;ZSTD&#39;          : (B&#39;\x28\xB5\x2F\xFD&#39;),
            &#39;ZZip&#39;          : (B&#39;7z\xBC\xAF\x27\x1C&#39;, (B&#39;\x00\x02&#39;, B&#39;\x00\x03&#39;, B&#39;\x00\x04&#39;)),
            &#39;APLib&#39;         : (B&#39;AP32\x18\0\0\0&#39;),
            &#39;BZip&#39;          : (B&#39;BZh&#39;),
            &#39;DDS&#39;           : (B&#39;\x00\x00\x00\x01Bud1&#39;),
            &#39;ELF&#39;           : (B&#39;\x7FELF&#39;),
            &#39;JavaClass&#39;     : (B&#39;\xCA\xFE\xBA\xBE&#39;),
            &#39;LZIP&#39;          : (B&#39;LZIP&#39;),
            &#39;SZDD&#39;          : (B&#39;SZDD\x88\xF0\x27\x33&#39;),
            &#39;LZMA&#39;          : (B&#39;\x5D\x00\x00\x00&#39;),
            &#39;LZMA/XZ&#39;       : (B&#39;\xFD7zXZ&#39;),
            &#39;LZO&#39;           : (B&#39;\x89\x4c\x5a\x4f\x00\x0d\x0a\x1a\x0a&#39;),
            &#39;MachO/BE&#39;      : (B&#39;\xCA\xFE\xBA\xBE&#39;),
            &#39;MachO/LE&#39;      : (B&#39;\xBE\xBA\xFE\xCA&#39;),
            &#39;MSCF&#39;          : (B&#39;\x0A\x51\xE5\xC0&#39;),
            &#39;OleDocument&#39;   : (B&#39;\xD0\xCF\x11\xE0&#39;),
            &#39;PdfDocument&#39;   : (B&#39;%PDF-&#39;, _S(B&#39;12&#39;), (B&#39;.&#39;), _S(B&#39;0123456789&#39;), _S(B&#39;\r\n&#39;)),
            &#39;SQLite&#39;        : (B&#39;SQLite format 3\0&#39;),
            &#39;GIF&#39;           : (B&#39;GIF87a&#39;, B&#39;GIF89a&#39;),
            &#39;PNG&#39;           : (B&#39;\x89PNG\r\n\x1A\n&#39;),
            &#39;DEX&#39;           : (B&#39;dex\n035\0&#39;),
            &#39;JPG&#39;           : (B&#39;\xFF\xD8\xFF&#39;, _S(B&#39;\xE0\xE1\xEE&#39;), (B&#39;\x00\x10\x4A\x46\x49\x46\x00\x01&#39;, B&#39;&#39;)),
            &#39;OneNote&#39;       : (B&#39;\xE4\x52\x5C\x7B\x8C\xD8\xA7\x4D\xAE\xB1\x53\x78\xD0\x29\x96\xD3&#39;),
            &#39;A3xScript&#39;     : (B&#39;\xA3\x48\x4B\xBE\x98\x6C\x4A\xA9\x99\x4C\x53\x0A\x86\xD6\x48\x7D&#39;),
            &#39;RTFDocument&#39;   : (B&#39;{\\rtf1&#39;, (B&#39;\\adeflang&#39;, B&#39;\\ansi&#39;, B&#39;&#39;)),
            &#39;CallToPop&#39;     : (B&#39;\xE8\0\0\0\0&#39;, (
                               B&#39;\x41\x58&#39;, B&#39;\x41\x59&#39;, B&#39;\x41\x5A&#39;, B&#39;\x41\x5B&#39;,
                                   B&#39;\x58&#39;,     B&#39;\x59&#39;,     B&#39;\x5A&#39;,     B&#39;\x5B&#39;,   # noqa
                                   B&#39;\x5C&#39;,     B&#39;\x5D&#39;,     B&#39;\x5E&#39;,     B&#39;\x5F&#39;,   # noqa
                               )),
            &#39;Cert&#39;          : (B&#39;-----BEGIN CERTIFICATE-----&#39;),
            &#39;PrivateKey&#39;    : (B&#39;-----BEGIN PRIVATE KEY-----&#39;),
            &#39;PrivateKeyDSA&#39; : (B&#39;-----BEGIN DSA PRIVATE KEY-----&#39;),
            &#39;PrivateKeyRSA&#39; : (B&#39;-----BEGIN RSA PRIVATE KEY-----&#39;),
            &#39;PrivateKeySSH&#39; : (B&#39;-----BEGIN OPENSSH PRIVATE KEY-----&#39;),
            &#39;PEM&#39;           : (B&#39;-----BEGIN &#39;),
            &#39;PuTTY-Key&#39;     : (B&#39;PuTTY-User-Key-File-&#39;, (B&#39;2:&#39;, B&#39;3:&#39;)),
            &#39;MsAccess&#39;      : (B&#39;\0\01\0\0Standard &#39;, (B&#39;ACE&#39;, B&#39;Jet&#39;), B&#39; DB&#39;),
        },
        range(0x10, 0x11): {
            &#39;ASAR&#39;          : (B&#39;{&#34;files&#34;:{&#34;&#39;),
        },
        range(0x40): {
            &#39;DocTypeLower&#39;  : (B&#39;&lt;!doctype&#39;),
            &#39;DocTypeUpper&#39;  : (B&#39;&lt;!DOCTYPE&#39;),
            &#39;HTMLLower&#39;     : (B&#39;&lt;html&gt;&#39;),
            &#39;HTMLUpper&#39;     : (B&#39;&lt;HTML&gt;&#39;),
            &#39;XML&#39;           : (B&#39;&lt;?xml version=&#34;&#39;),
            &#39;Ace&#39;           : (B&#39;**ACE**&#39;),
        },
        range(0x40, 0x60): {
            &#39;PEDelphiStub&#39;  : (B&#39;This program cannot be run in DOS mode.&#39;),
            &#39;PEStub&#39;        : (B&#39;This program must be run under Win&#39;, (B&#39;32&#39;, B&#39;64&#39;)),
        },
        range(0xD0, 0xD1): {
            &#39;Tar&#39;           : (B&#39;\x00&#39; * 0x30 + B&#39;ustar&#39;, (B&#39;\x20\x20\x00&#39;, B&#39;\x00\x30\x30&#39;)),
        },
        range(0x200): {
            &#39;EmailReceived&#39; : (B&#39;\nReceived:\x20from&#39;),
            &#39;EmailSubject&#39;  : (B&#39;\nSubject:\x20&#39;),
            &#39;EmailFrom&#39;     : (B&#39;\nFrom:\x20&#39;),
            &#39;EmailTo&#39;       : (B&#39;\nTo:\x20&#39;),
            &#39;PESectionData&#39; : (B&#39;.data\0\0\0&#39;),
            &#39;PESectionText&#39; : (B&#39;.text\0\0\0&#39;),
        },
    }

    _ENC_ALPHABETS = [
        B&#39;0123456789,&#39;,
        B&#39;0123456789;&#39;,
        B&#39;0123456789ABCDEF&#39;,
        B&#39;0123456789abcdef&#39;,
        B&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&#39;,
        B&#39;abcdefghijklmnopqrstuvwxyz234567&#39;,
        B&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/&#39;,
        B&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_&#39;,
    ]

    _WSH_ALPHABET = bytes(set(range(0x20, 0x80)) - {0x3C, 0x3E} | {0x09})

    def __init__(
        self,
        range: Arg.Bounds(help=&#39;range of length values to try in Python slice syntax, the default is {default}.&#39;) = slice(1, 32),
        no_alph: Arg.Switch(&#39;-na&#39;, &#39;--no-alph&#39;, help=&#39;disables search for keys via known encoder alphabets&#39;) = False,
        no_crib: Arg.Switch(&#39;-nc&#39;, &#39;--no-crib&#39;, help=&#39;disables search for keys via known plaintext cribs&#39;) = False,
    ):
        super().__init__(range=range, no_alph=no_alph, no_crib=no_crib)

    def process(self, data: bytearray):
        score = 0
        guess = None
        bounds: slice = self.args.range
        view = memoryview(data)

        n = len(view)

        if n &lt;= 1:
            return view
        if n &gt;= 0x100:
            view = view[:-4]

        start = bounds.start or 1
        stop = min(bounds.stop or n, n)

        if bounds.step is not None:
            step = bounds.step
            if bounds.start is None:
                start *= step
        else:
            step = 1

        self.log_debug(F&#39;received input range [{bounds.start}:{bounds.stop}:{bounds.step}], using [{start}:{stop}:{step}]&#39;)

        if not self.args.no_crib:
            for offsets, cribs_by_type in self._CRIBS.items():
                for name, cribs in cribs_by_type.items():
                    cribs = _generate_cribs(cribs)
                    for offset, crib in product(offsets, cribs):
                        if len(crib) &lt; start:
                            continue
                        if len(crib) &gt; stop:
                            continue
                        if (len(crib) - start) % step != 0:
                            continue
                        test = view[offset:offset + len(crib)]
                        if len(test) != len(crib):
                            continue
                        key = _cyclic_base(strxor(test, crib))
                        if key is not None:
                            self.log_info(F&#39;found key via crib for {name}:&#39;, crib)
                            shift = -offset % len(key)
                            return key[shift:] + key[:shift]

        if not self.args.no_alph:
            alphabets: dict[int, list[bytes]] = {}
            for alphabet in self._ENC_ALPHABETS:
                for suffix in (B&#39;&#39;, B&#39;\x20&#39;, B&#39;\x0A&#39;, B&#39;\x20\x0A&#39;):
                    a = alphabet + suffix
                    alphabets.setdefault(len(a), []).append(a)

            alphabets[len(self._WSH_ALPHABET)] = self._WSH_ALPHABET

        for keylen in range(start, stop + 1, step):
            patches = [view[j::keylen] for j in range(keylen)]
            histograms = [Counter(p) for p in patches]

            if not self.args.no_alph:
                hlc = Counter(len(h) for h in histograms)
                base, coverage = hlc.most_common(1)[0]

                if coverage * 2 &gt; keylen and base in alphabets:
                    self.log_info(F&#39;detected potential plaintext alphabet of size 0x{base:02X} at {keylen}&#39;)
                    keys: dict[bytes, bytes] = {}
                    for alphabet in alphabets[base]:
                        key = bytearray(keylen)
                        for k, patch in enumerate(patches):
                            keybyte = set(range(0x100))
                            for x in patch:
                                keybyte &amp;= {y ^ x for y in alphabet}
                                if len(keybyte) == 1:
                                    key[k] = next(iter(keybyte))
                                    break
                            else:
                                key = None
                                break
                        if key is not None:
                            keys[alphabet] = key
                    if len(keys) == 1:
                        alphabet, key = keys.popitem()
                        return key

            _guess = [h.most_common(1)[0] for h in histograms]
            _score = sum(letter_count for _, letter_count in _guess) / n
            # This scaling accounts for the smaller probability of larger keys. No proper statistical analysis has been
            # conducted to derive it; there might be plenty of room for improvement here.
            _score = _score * ((n - keylen) / (n - 1)) ** keylen

            logmsg = F&#39;got score {_score * 100:5.2f}% for length {keylen}&#39;
            if _score &gt; score:
                self.log_info(logmsg)
                score = _score
                guess = bytearray(value for value, _ in _guess)
            else:
                self.log_debug(logmsg)

        return guess</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.misc.autoxor.autoxor" href="autoxor.html#refinery.units.misc.autoxor.autoxor">autoxor</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.Arg" href="../index.html#refinery.units.Unit.Arg">Arg</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.reverse" href="../index.html#refinery.units.UnitBase.reverse">reverse</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.misc" href="index.html">refinery.units.misc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.misc.xkey.xkey" href="#refinery.units.misc.xkey.xkey">xkey</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>